From 848a0a865fd0ad6dfacafaf2d638587038c231e1 Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Mon, 27 Oct 2025 15:40:37 -0400
Subject: [PATCH 12/18] Use CaptureInfo for NoCapture on LLVM 21

---
 src/codegen.cpp | 38 ++++++++++++++++++++++++++++----------
 1 file changed, 28 insertions(+), 10 deletions(-)

diff --git a/src/codegen.cpp b/src/codegen.cpp
index 7ca0f4d2d3..5f24879eb6 100644
--- a/src/codegen.cpp
+++ b/src/codegen.cpp
@@ -605,6 +605,24 @@ AttributeSet Attributes(LLVMContext &C, std::initializer_list<Attribute::AttrKin
     return AttributeSet::get(C, ArrayRef<Attribute>(attrs));
 }
 
+static inline Attribute NoCaptureAttr(LLVMContext &C)
+{
+#if JL_LLVM_VERSION < 210000
+    return Attribute::get(C, Attribute::NoCapture);
+#else
+    return Attribute::getWithCaptureInfo(C, CaptureInfo(CaptureComponents::None));
+#endif
+}
+
+static inline void addNoCaptureAttr(AttrBuilder &param)
+{
+#if JL_LLVM_VERSION < 210000
+    param.addAttribute(Attribute::NoCapture);
+#else
+    param.addCapturesAttr(CaptureInfo(CaptureComponents::None));
+#endif
+}
+
 static Type *get_pjlvalue(LLVMContext &C) { return JuliaType::get_pjlvalue_ty(C); }
 
 static FunctionType *get_func_sig(LLVMContext &C) { return JuliaType::get_jlfunc_ty(C); }
@@ -617,7 +635,7 @@ static AttributeList get_func_attrs(LLVMContext &C)
             AttributeSet(),
             Attributes(C, {Attribute::NonNull}),
             {AttributeSet(),
-             Attributes(C, {Attribute::NoAlias, Attribute::ReadOnly, Attribute::NoCapture, Attribute::NoUndef})});
+             Attributes(C, {Attribute::NoAlias, Attribute::ReadOnly, Attribute::NoUndef}, {NoCaptureAttr(C)})});
 }
 
 static AttributeList get_attrs_noreturn(LLVMContext &C)
@@ -996,7 +1014,7 @@ static const auto jllockvalue_func = new JuliaFunction<>{
     [](LLVMContext &C) { return AttributeList::get(C,
             AttributeSet(),
             AttributeSet(),
-            {Attributes(C, {Attribute::NoCapture})}); },
+            {Attributes(C, {}, {NoCaptureAttr(C)})}); },
 };
 static const auto jlunlockvalue_func = new JuliaFunction<>{
     XSTR(jl_unlock_value),
@@ -1005,7 +1023,7 @@ static const auto jlunlockvalue_func = new JuliaFunction<>{
     [](LLVMContext &C) { return AttributeList::get(C,
             AttributeSet(),
             AttributeSet(),
-            {Attributes(C, {Attribute::NoCapture})}); },
+            {Attributes(C, {}, {NoCaptureAttr(C)})}); },
 };
 static const auto jllockfield_func = new JuliaFunction<>{
     XSTR(jl_lock_field),
@@ -1014,7 +1032,7 @@ static const auto jllockfield_func = new JuliaFunction<>{
     [](LLVMContext &C) { return AttributeList::get(C,
             AttributeSet(),
             AttributeSet(),
-            {Attributes(C, {Attribute::NoCapture})}); },
+            {Attributes(C, {}, {NoCaptureAttr(C)})}); },
 };
 static const auto jlunlockfield_func = new JuliaFunction<>{
     XSTR(jl_unlock_field),
@@ -1023,7 +1041,7 @@ static const auto jlunlockfield_func = new JuliaFunction<>{
     [](LLVMContext &C) { return AttributeList::get(C,
             AttributeSet(),
             AttributeSet(),
-            {Attributes(C, {Attribute::NoCapture})}); },
+            {Attributes(C, {}, {NoCaptureAttr(C)})}); },
 };
 static const auto jlenter_func = new JuliaFunction<>{
     XSTR(jl_enter_handler),
@@ -1489,7 +1507,7 @@ static const auto gc_loaded_func = new JuliaFunction<>{
         RetAttrs.addAttribute(Attribute::NonNull);
         RetAttrs.addAttribute(Attribute::NoUndef);
         return AttributeList::get(C, AttributeSet::get(C,FnAttrs), AttributeSet::get(C,RetAttrs),
-                { Attributes(C, {Attribute::NonNull, Attribute::NoUndef, Attribute::ReadNone, Attribute::NoCapture}),
+                { Attributes(C, {Attribute::NonNull, Attribute::NoUndef, Attribute::ReadNone}, {NoCaptureAttr(C)}),
                   Attributes(C, {Attribute::NonNull, Attribute::NoUndef, Attribute::ReadNone}) });
                   },
 };
@@ -7944,7 +7962,7 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module
         AttrBuilder param(M->getContext());
         param.addStructRetAttr(srt);
         param.addAttribute(Attribute::NoAlias);
-        param.addAttribute(Attribute::NoCapture);
+        addNoCaptureAttr(param);
         param.addAttribute(Attribute::NoUndef);
         attrs.push_back(AttributeSet::get(M->getContext(), param));
         assert(fsig.size() == 1);
@@ -7952,7 +7970,7 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module
     if (props.cc == jl_returninfo_t::Union) {
         AttrBuilder param(M->getContext());
         param.addAttribute(Attribute::NoAlias);
-        param.addAttribute(Attribute::NoCapture);
+        addNoCaptureAttr(param);
         param.addAttribute(Attribute::NoUndef);
         attrs.push_back(AttributeSet::get(M->getContext(), param));
         assert(fsig.size() == 1);
@@ -7961,7 +7979,7 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module
     if (props.return_roots) {
         AttrBuilder param(M->getContext());
         param.addAttribute(Attribute::NoAlias);
-        param.addAttribute(Attribute::NoCapture);
+        addNoCaptureAttr(param);
         param.addAttribute(Attribute::NoUndef);
         attrs.push_back(AttributeSet::get(M->getContext(), param));
         fsig.push_back(getPointerTy(M->getContext()));
@@ -7995,7 +8013,7 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module
         AttrBuilder param(M->getContext());
         Type *ty = et;
         if (et == nullptr || et->isAggregateType()) { // aggregate types are passed by pointer
-            param.addAttribute(Attribute::NoCapture);
+            addNoCaptureAttr(param);
             param.addAttribute(Attribute::ReadOnly);
             ty = PointerType::get(M->getContext(), AddressSpace::Derived);
         }
-- 
2.51.2

