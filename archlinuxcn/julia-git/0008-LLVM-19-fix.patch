From 3392819d29c67d8c55af74a007fa4ff101b8087a Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Thu, 23 Jan 2025 21:08:42 -0500
Subject: [PATCH 8/8] LLVM 19 fix

---
 src/cgmemmgr.cpp   |  4 +++-
 src/debuginfo.cpp  |  2 +-
 src/disasm.cpp     | 19 ++++++++++++++-----
 src/init.c         |  1 +
 src/jitlayers.cpp  | 10 +++++-----
 src/signals-mach.c |  2 +-
 6 files changed, 25 insertions(+), 13 deletions(-)

diff --git a/src/cgmemmgr.cpp b/src/cgmemmgr.cpp
index c257d2a2e3..99f78b81bf 100644
--- a/src/cgmemmgr.cpp
+++ b/src/cgmemmgr.cpp
@@ -182,15 +182,17 @@ static intptr_t get_anon_hdl(void) JL_NOTSAFEPOINT
     pid_t pid = getpid();
     // `shm_open` can't be mapped exec on mac
 #  ifndef _OS_DARWIN_
+    int shm_open_errno;
     do {
         snprintf(shm_name, sizeof(shm_name),
                  "julia-codegen-%d-%d", (int)pid, rand());
         fd = shm_open(shm_name, O_RDWR | O_CREAT | O_EXCL, S_IRWXU);
+        shm_open_errno = errno; // check_fd_or_close trashes errno, so save beforehand
         if (check_fd_or_close(fd)) {
             shm_unlink(shm_name);
             return fd;
         }
-    } while (errno == EEXIST);
+    } while (shm_open_errno == EEXIST);
 #  endif
     FILE *tmpf = tmpfile();
     if (tmpf) {
diff --git a/src/debuginfo.cpp b/src/debuginfo.cpp
index 17e093cecb..6db6a07c91 100644
--- a/src/debuginfo.cpp
+++ b/src/debuginfo.cpp
@@ -1249,7 +1249,7 @@ extern "C" JL_DLLEXPORT_CODEGEN int jl_getFunctionInfo_impl(jl_frame_t **frames_
     frames[0].line = -1;
     *frames_out = frames;
 
-    llvm::DIContext *context;
+    llvm::DIContext *context = nullptr;
     object::SectionRef Section;
     int64_t slide;
     uint64_t symsize;
diff --git a/src/disasm.cpp b/src/disasm.cpp
index 6a7985bd7e..1dee6d80ef 100644
--- a/src/disasm.cpp
+++ b/src/disasm.cpp
@@ -456,6 +456,9 @@ static void jl_strip_llvm_debug(Module *m, bool all_meta, LineNumberAnnotatedWri
                 if (AAW)
                     AAW->addDebugLoc(&inst, inst.getDebugLoc());
                 inst.setDebugLoc(DebugLoc());
+#if JL_LLVM_VERSION >= 190000
+                inst.dropDbgRecords();
+#endif
             }
             if (deletelast) {
                 deletelast->eraseFromParent();
@@ -869,6 +872,8 @@ static void jl_dump_asm_internal(
     SourceMgr SrcMgr;
 
     MCTargetOptions Options;
+    Options.AsmVerbose = true;
+    Options.MCUseDwarfDirectory = MCTargetOptions::EnableDwarfDirectory;
     std::unique_ptr<MCAsmInfo> MAI(
         TheTarget->createMCAsmInfo(*TheTarget->createMCRegInfo(TheTriple.str()), TheTriple.str(), Options));
     assert(MAI && "Unable to create target asm info!");
@@ -1237,6 +1242,11 @@ jl_value_t *jl_dump_function_asm_impl(jl_llvmf_dump_t* dump, char emit_mc, const
         });
         auto TMBase = jl_ExecutionEngine->cloneTargetMachine();
         LLVMTargetMachine *TM = static_cast<LLVMTargetMachine*>(TMBase.get());
+        MCTargetOptions &Options = TM->Options.MCOptions;
+        Options.AsmVerbose = true;
+        Options.MCUseDwarfDirectory = MCTargetOptions::EnableDwarfDirectory;
+        if (binary)
+            Options.ShowMCEncoding = true;
         legacy::PassManager PM;
         addTargetPasses(&PM, TM->getTargetTriple(), TM->getTargetIRAnalysis());
         if (emit_mc) {
@@ -1266,8 +1276,8 @@ jl_value_t *jl_dump_function_asm_impl(jl_llvmf_dump_t* dump, char emit_mc, const
                 OutputAsmDialect = 1;
             MCInstPrinter *InstPrinter = TM->getTarget().createMCInstPrinter(
                 jl_ExecutionEngine->getTargetTriple(), OutputAsmDialect, MAI, MII, MRI);
-             std::unique_ptr<MCAsmBackend> MAB(TM->getTarget().createMCAsmBackend(
-                STI, MRI, TM->Options.MCOptions));
+            std::unique_ptr<MCAsmBackend> MAB(TM->getTarget().createMCAsmBackend(
+                STI, MRI, Options));
             std::unique_ptr<MCCodeEmitter> MCE;
             if (binary) { // enable MCAsmStreamer::AddEncodingComment printing
                 MCE.reset(TM->getTarget().createMCCodeEmitter(MII, *Context));
@@ -1281,8 +1291,7 @@ jl_value_t *jl_dump_function_asm_impl(jl_llvmf_dump_t* dump, char emit_mc, const
                 std::move(MAB), false
 #endif
                     ));
-            std::unique_ptr<AsmPrinter> Printer(
-                TM->getTarget().createAsmPrinter(*TM, std::move(S)));
+            AsmPrinter *Printer = TM->getTarget().createAsmPrinter(*TM, std::move(S));
 #if JL_LLVM_VERSION >= 190000
             Printer->addDebugHandler(
                         std::make_unique<LineNumberPrinterHandler>(*Printer, debuginfo));
@@ -1293,7 +1302,7 @@ jl_value_t *jl_dump_function_asm_impl(jl_llvmf_dump_t* dump, char emit_mc, const
 #endif
             if (!Printer)
                 return jl_an_empty_string;
-            PM.add(Printer.release());
+            PM.add(Printer);
             PM.add(createFreeMachineFunctionPass());
             TSM->withModuleDo([&](Module &m){ PM.run(m); });
         }
diff --git a/src/init.c b/src/init.c
index e69467c75b..12e9493889 100644
--- a/src/init.c
+++ b/src/init.c
@@ -444,6 +444,7 @@ static void *init_stdio_handle(const char *stdio, uv_os_fd_t fd, int readable)
     // This also helps limit the impact other libraries can cause on our file handle.
     if ((err = uv_dup(fd, &fd)))
         jl_errorf("error initializing %s in uv_dup: %s (%s %d)", stdio, uv_strerror(err), uv_err_name(err), err);
+    assert(fd != -1); // This avoids a bug in clang's static analyzer, if an error did not occur, fd != -1
     switch(uv_guess_handle(fd)) {
     case UV_TTY:
         handle = malloc_s(sizeof(uv_tty_t));
diff --git a/src/jitlayers.cpp b/src/jitlayers.cpp
index 0acb7beaca..e21d63200e 100644
--- a/src/jitlayers.cpp
+++ b/src/jitlayers.cpp
@@ -1185,11 +1185,11 @@ public:
 
 class JLMemoryUsagePlugin : public ObjectLinkingLayer::Plugin {
 private:
-    std::atomic<size_t> &jit_bytes_size;
+    _Atomic(size_t)* jit_bytes_size;
 
 public:
 
-    JLMemoryUsagePlugin(std::atomic<size_t> &jit_bytes_size)
+    JLMemoryUsagePlugin(_Atomic(size_t)* jit_bytes_size)
         : jit_bytes_size(jit_bytes_size) {}
 
     Error notifyFailed(orc::MaterializationResponsibility &MR) override {
@@ -1226,7 +1226,7 @@ public:
             }
             (void) code_size;
             (void) data_size;
-            this->jit_bytes_size.fetch_add(graph_size, std::memory_order_relaxed);
+            jl_atomic_fetch_add_relaxed(this->jit_bytes_size, graph_size)
             jl_timing_counter_inc(JL_TIMING_COUNTER_JITSize, graph_size);
             jl_timing_counter_inc(JL_TIMING_COUNTER_JITCodeSize, code_size);
             jl_timing_counter_inc(JL_TIMING_COUNTER_JITDataSize, data_size);
@@ -1969,7 +1969,7 @@ JuliaOJIT::JuliaOJIT()
         ES, std::move(ehRegistrar)));
 
     ObjectLayer.addPlugin(std::make_unique<JLDebuginfoPlugin>());
-    ObjectLayer.addPlugin(std::make_unique<JLMemoryUsagePlugin>(jit_bytes_size));
+    ObjectLayer.addPlugin(std::make_unique<JLMemoryUsagePlugin>(&jit_bytes_size));
 #else
     UnlockedObjectLayer.setNotifyLoaded(registerRTDyldJITObject);
 #endif
@@ -2081,7 +2081,7 @@ JuliaOJIT::JuliaOJIT()
         reinterpret_cast<void *>(static_cast<uintptr_t>(msan_workaround::MSanTLS::origin))), JITSymbolFlags::Exported};
     cantFail(GlobalJD.define(orc::absoluteSymbols(msan_crt)));
 #endif
-#if JL_LLVM_VERSION < 190000
+#if JL_LLVM_VERSION < 200000
 #ifdef _COMPILER_ASAN_ENABLED_
     // this is a hack to work around a bad assertion:
     //   /workspace/srcdir/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:3028: llvm::Error llvm::orc::ExecutionSession::OL_notifyResolved(llvm::orc::MaterializationResponsibility&, const SymbolMap&): Assertion `(KV.second.getFlags() & ~JITSymbolFlags::Common) == (I->second & ~JITSymbolFlags::Common) && "Resolving symbol with incorrect flags"' failed.
diff --git a/src/signals-mach.c b/src/signals-mach.c
index 1c4af2cf9d..05f1111bab 100644
--- a/src/signals-mach.c
+++ b/src/signals-mach.c
@@ -339,7 +339,7 @@ static void jl_throw_in_thread(jl_ptls_t ptls2, mach_port_t thread, jl_value_t *
                             NULL /*current_task?*/);
         ptls2->sig_exception = exception;
         ptls2->io_wait = 0;
-        jl_task_t *ct = ptls2->current_task;
+        jl_task_t *ct = jl_atomic_load_relaxed(&ptls2->current_task);
         jl_handler_t *eh = ct->eh;
         if (eh != NULL) {
             asan_unpoison_task_stack(ct, &eh->eh_ctx);
-- 
2.48.1

