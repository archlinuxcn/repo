
# HG changeset patch
# User Henri Sivonen <hsivonen@hsivonen.fi>
# Date 1604046593 0
# Node ID 632353012d05c8e71314d27edca945ce9c13f4ea
# Parent  2876425c75f75f638b41e8c6093e84b817938a9a
Bug 1667736 - Update packed_simd to compile on Rust 1.48. r=glandium

Differential Revision: https://phabricator.services.mozilla.com/D91572

diff --git a/.cargo/config.in b/.cargo/config.in
--- a/.cargo/config.in
+++ b/.cargo/config.in
@@ -45,7 +45,7 @@ rev = "21c26326f5f45f415c49eac4ba5bc41a2
 [source."https://github.com/hsivonen/packed_simd"]
 git = "https://github.com/hsivonen/packed_simd"
 replace-with = "vendored-sources"
-rev = "3541e3818fdc7c2a24f87e3459151a4ce955a67a"
+rev = "0917fe780032a6bbb23d71be545f9c1834128d75"
 
 [source."https://github.com/djg/cubeb-pulse-rs"]
 git = "https://github.com/djg/cubeb-pulse-rs"
diff --git a/Cargo.lock b/Cargo.lock
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -3573,18 +3573,18 @@ version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "49a4b8ea2179e6a2e27411d3bca09ca6dd630821cf6894c6c7c8467a8ee7ef13"
 dependencies = [
  "stable_deref_trait",
 ]
 
 [[package]]
 name = "packed_simd"
-version = "0.3.3"
-source = "git+https://github.com/hsivonen/packed_simd?rev=3541e3818fdc7c2a24f87e3459151a4ce955a67a#3541e3818fdc7c2a24f87e3459151a4ce955a67a"
+version = "0.3.4"
+source = "git+https://github.com/hsivonen/packed_simd?rev=0917fe780032a6bbb23d71be545f9c1834128d75#0917fe780032a6bbb23d71be545f9c1834128d75"
 dependencies = [
  "cfg-if",
 ]
 
 [[package]]
 name = "parity-wasm"
 version = "0.41.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
diff --git a/Cargo.toml b/Cargo.toml
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -66,7 +66,7 @@ panic = "abort"
 
 [patch.crates-io]
 libudev-sys = { path = "dom/webauthn/libudev-sys" }
-packed_simd = { git = "https://github.com/hsivonen/packed_simd", rev="3541e3818fdc7c2a24f87e3459151a4ce955a67a" }
+packed_simd = { git = "https://github.com/hsivonen/packed_simd", rev="0917fe780032a6bbb23d71be545f9c1834128d75" }
 rlbox_lucet_sandbox = { git = "https://github.com/PLSysSec/rlbox_lucet_sandbox/", rev="d510da5999a744c563b0acd18056069d1698273f" }
 nix = { git = "https://github.com/shravanrn/nix/", branch = "r0.13.1", rev="4af6c367603869a30fddb5ffb0aba2b9477ba92e" }
 spirv_cross = { git = "https://github.com/kvark/spirv_cross", branch = "wgpu3", rev = "20191ad2f370afd6d247edcb9ff9da32d3bedb9c" }
diff --git a/third_party/rust/packed_simd/.cargo-checksum.json b/third_party/rust/packed_simd/.cargo-checksum.json
--- a/third_party/rust/packed_simd/.cargo-checksum.json
+++ b/third_party/rust/packed_simd/.cargo-checksum.json
@@ -1,1 +1,1 @@
-{"files":{".appveyor.yml":"f1ed01850e0d725f9498f52a1a63ddf40702ad6e0bf5b2d7c4c04d76e96794a3",".travis.yml":"e9258d9a54fdaf4cbc12405fe5993ac4497eb2b29021691dbc91b19cb9b52227","Cargo.toml":"089941ba3c89ea111cbea3cc3abdcdcf2b9d0ae0db268d7269ee38226db950e5","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","bors.toml":"dee881dc69b9b7834e4eba5d95c3ed5a416d4628815a167d6a22d4cb4fb064b8","build.rs":"f3baefc5e5bb9b250e762a1466371b922fd7ee4243c217b2d014307603c2f57a","ci/all.sh":"a23d14e10cb26a0eb719e389c30eb955fa53cddcd436890646df09af640bd2eb","ci/android-install-ndk.sh":"0f1746108cc30bf9b9ba45bcde7b19fc1a8bdf5b0258035b4eb8dc69b75efac4","ci/android-install-sdk.sh":"3490432022c5c8f5a115c084f7a9aca1626f96c0c87ffb62019228c4346b47e4","ci/android-sysimage.sh":"ebf4e5daa1f0fe1b2092b79f0f3f161c4c4275cb744e52352c4d81ab451e4c5a","ci/benchmark.sh":"b61d19ef6b90deba8fb79dee74c8b062d94844676293da346da87bb78a9a49a4","ci/deploy_and_run_on_ios_simulator.rs":"ec8ecf82d92072676aa47f0d1a3d021b60a7ae3531153ef12d2ff4541fc294dc","ci/docker/aarch64-linux-android/Dockerfile":"ace2e7d33c87bc0f6d3962a4a3408c04557646f7f51ab99cfbf574906796b016","ci/docker/aarch64-unknown-linux-gnu/Dockerfile":"1ecdac757101d951794fb2ab0deaa278199cf25f2e08a15c7d40ff31a8556184","ci/docker/arm-linux-androideabi/Dockerfile":"370e55d3330a413a3ccf677b3afb3e0ef9018a5fab263faa97ae8ac017fc2286","ci/docker/arm-unknown-linux-gnueabi/Dockerfile":"e25d88f6c0c94aada3d2e3f08243f755feb7e869dc5dc505b3799719cb1af591","ci/docker/arm-unknown-linux-gnueabihf/Dockerfile":"f126f4c7bae8c11ab8b16df06ad997863f0838825a9c08c9899a3eedb6d570bd","ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile":"b647545c158ee480a4c581dbdc1f57833aef056c8d498acc04b573e842bf803c","ci/docker/i586-unknown-linux-gnu/Dockerfile":"0d492759017307ccf74dc2aa4a8cf6623daf3dc728c708dc2b18fa7940800cba","ci/docker/i686-unknown-linux-gnu/Dockerfile":"0d492759017307ccf74dc2aa4a8cf6623daf3dc728c708dc2b18fa7940800cba","ci/docker/mips-unknown-linux-gnu/Dockerfile":"323776469bb7b160385f3621d66e3ee14c75242f8180f916e65af048a29d4ea0","ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile":"c647f6948a9a43b0be695cbed4eac752120d0faf28e5e69c718cb10406921dab","ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile":"77bfd00cc8639509be381b394f077e39b45a00158ad61b4e1656714c714665d1","ci/docker/mipsel-unknown-linux-musl/Dockerfile":"ec5bea6c98a3b626731fdb95f9ff2d1182639c76e8fb16d3271d0fc884901524","ci/docker/powerpc-unknown-linux-gnu/Dockerfile":"4f2b662de66e83d1354f650b7077692309637f786c2ea5516c31b5c2ee10af2d","ci/docker/powerpc64-unknown-linux-gnu/Dockerfile":"a9595402b772bc365982e22a0096a8988825d90b09b5faa97ab192e76072f71d","ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile":"df3c381c157439695ae8cd10ab71664702c061e3b4ab22906a5ad6c2680acfed","ci/docker/s390x-unknown-linux-gnu/Dockerfile":"93fb44df3d7fd31ead158570667c97b5076a05c3d968af4a84bc13819a8f2db8","ci/docker/sparc64-unknown-linux-gnu/Dockerfile":"da1c39a3ff1fe22e41395fa7c8934e90b4c1788e551b9aec6e38bfd94effc437","ci/docker/thumbv7neon-linux-androideabi/Dockerfile":"c2decd5591bd7a09378901bef629cd944acf052eb55e4f35b79eb9cb4d62246a","ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile":"75c0c56161c7382b439de74c00de1c0e3dc9d59560cd6720976a751034b78714","ci/docker/wasm32-unknown-unknown/Dockerfile":"3e5f294bc1e004aa599086c2af49d6f3e7459fa250f5fbdd60cf67d53db78758","ci/docker/x86_64-linux-android/Dockerfile":"685040273cf350d5509e580ac451555efa19790c8723ca2af066adadc6880ad2","ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile":"44b6203d9290bfdc53d81219f0937e1110847a23dd982ec8c4de388354f01536","ci/docker/x86_64-unknown-linux-gnu/Dockerfile":"d253c86803b22da428fa9cc671a05f18d3318eca7733b8dccb4f7be1ddf524c5","ci/dox.sh":"5b61711be47a4e3dde0ddd15ba73d256ea95fd75af3897732c24db1dc7e66366","ci/linux-s390x.sh":"d6b732d7795b4ba131326aff893bca6228a7d2eb0e9402f135705413dbbe0dce","ci/linux-sparc64.sh":"c92966838b1ab7ad3b7a344833ee726aba6b647cf5952e56f0ad1ba420b13325","ci/lld-shim.rs":"3d7f71ec23a49e2b67f694a0168786f9a954dda15f5a138815d966643fd3fcc3","ci/max_line_width.sh":"0a1518bba4c9ecaa55694cb2e9930d0e19c265baabf73143f17f9cf285aaa5bb","ci/run-docker.sh":"92e036390ad9b0d16f109579df1b5ced2e72e9afea40c7d011400ebd3a2a90de","ci/run.sh":"63259e22a96ba539f53c06b1b39f53e3a78a71171652e7afc170836110ccd913","ci/run_examples.sh":"d1a23c6c35374a0678ba5114b9b8fefd8be0a79e774872a8bf0898d1baca18d0","ci/runtest-android.rs":"145a8e9799a5223975061fe7e586ade5669ee4877a7d7a4cf6b4ab48e8e36c7c","ci/setup_benchmarks.sh":"73fb981a8fdb1dcd54409d3c0fbbfb8f77a3ceabf8626a6b9bf9d21d6bc8ce72","ci/test-runner-linux":"c8aa6025cff5306f4f31d0c61dc5f9d4dd5a1d189ab613ef8d4c367c694d9ccd","contributing.md":"2cc8c9c560ae17867e69b06d09b758dbf7bc39eb774ada50a743724b10acc0a2","perf-guide/.gitignore":"fe82c7da551079d832cf74200b0b359b4df9828cb4a0416fa7384f07a2ae6a13","perf-guide/book.toml":"115a98284126c6b180178b44713314cc494f08a71662ee2ce15cf67f17a51064","perf-guide/src/SUMMARY.md":"3e03bffc991fdc2050f3d51842d72d9d21ea6abab56a3baf3b2d5973a78b89e1","perf-guide/src/ascii.css":"29afb08833b2fe2250f0412e1fa1161a2432a0820a14953c87124407417c741a","perf-guide/src/bound_checks.md":"5e4991ff58a183ef0cd9fdc1feb4cd12d083b44bdf87393bbb0927808ef3ce7d","perf-guide/src/float-math/approx.md":"8c09032fa2d795a0c5db1775826c850d28eb2627846d0965c60ee72de63735ad","perf-guide/src/float-math/fma.md":"311076ba4b741d604a82e74b83a8d7e8c318fcbd7f64c4392d1cf5af95c60243","perf-guide/src/float-math/fp.md":"04153e775ab6e4f0d7837bcc515230d327b04edfa34c84ce9c9e10ebaeef2be8","perf-guide/src/float-math/svml.md":"0798873b8eedaeda5fed62dc91645b57c20775a02d3cd74d8bd06958f1516506","perf-guide/src/introduction.md":"9f5a19e9e6751f25d2daad39891a0cc600974527ec4c8305843f9618910671bd","perf-guide/src/prof/linux.md":"447731eb5de7d69166728fdbc5ecb0c0c9db678ea493b45a592d67dd002184c0","perf-guide/src/prof/mca.md":"f56d54f3d20e7aa4d32052186e8237b03d65971eb5d112802b442570ff11d344","perf-guide/src/prof/profiling.md":"8a650c0fd6ede0964789bb6577557eeef1d8226a896788602ce61528e260e43c","perf-guide/src/target-feature/attribute.md":"615f88dca0a707b6c416fa605435dd6e1fb5361cc639429cbf68cd87624bd78b","perf-guide/src/target-feature/features.md":"17077760ff24c006b606dd21889c53d87228f4311f3ba3a574f9afdeacd86165","perf-guide/src/target-feature/inlining.md":"7ed1d7068d8173a00d84c16cfe5871cd68b9f04f8d0cca2d01ebc84957ebf2f6","perf-guide/src/target-feature/practice.md":"c4b371842e0086df178488fec97f20def8f0c62ee588bcd25fd948b9b1fa227e","perf-guide/src/target-feature/runtime.md":"835425f5ee597fb3e51d36e725a81ebee29f4561231d19563cd4da81dbb1cfcb","perf-guide/src/target-feature/rustflags.md":"ab49712e9293a65d74d540ba4784fcb57ff1119ec05a575d895c071f1a620f64","perf-guide/src/vert-hor-ops.md":"c6211c0ee91e60552ec592d89d9d957eedc21dee3cbd89e1ad6765ea06a27471","readme.md":"585a8f0e16877fb9abb00cd17a175fcb9d7857840c6c61209f1827ffab095070","rustfmt.toml":"de6101d0670bad65fb3b337d56957d2a024e017e5ab146ec784d77312daaf8ff","src/api.rs":"331a3a4abb19cee2df5f2df4ad7c3e88b45e62cf23fdacfc9bbaa633dc5cf788","src/api/bit_manip.rs":"e68290ee679cc5abc9c73afbe635c1035f8cbfe849e5c751a1680e459244c39e","src/api/cast.rs":"03b94a3d316ac7b7be7068810044911e965e889a0ace7bae762749ca74a92747","src/api/cast/macros.rs":"b0a14d0c83ad2ebb7a275180f6d9e3f2bc312ba57a7d3d6c39fad4e0f20f9408","src/api/cast/v128.rs":"63e28c6a3edf1a7a635f51b8d3c6adbb1d46f884d92a196b3d4a6e743d809416","src/api/cast/v16.rs":"2a584eeb57fd47baad6f3533764301b04aaaac23702b7a8db12598ac02899262","src/api/cast/v256.rs":"b91c15ed8d1536ecd97b4eb79ff9d5aba0552cd9b6f0ea6435b05f2273e23b3a","src/api/cast/v32.rs":"62ec89fcce7fa7f28497ee5770adc8f81d2d3a6b2925b02f7dc06504c40e8f38","src/api/cast/v512.rs":"d855cb943ae7106e9599ef38e30a3afb1c6bd5433178baca54cb128fd9a7d143","src/api/cast/v64.rs":"fe0f7dfaf4fc0c0c1a78c96fcfcdfdc2a1e2845843b11aa797a0c6fb52a8f774","src/api/cmp.rs":"357c3a2a09c6d4611c32dd7fa95be2fae933d513e229026ec9b44451a77b884e","src/api/cmp/eq.rs":"60f70f355bae4cb5b17db53204cacc3890f70670611c17df638d4c04f7cc8075","src/api/cmp/ord.rs":"589f7234761c294fa5df8f525bc4acd5a47cdb602207d524a0d4e19804cd9695","src/api/cmp/partial_eq.rs":"3ed23d2a930b0f9750c3a5309da766b03dc4f9c4d375b42ad3c50fe732693d15","src/api/cmp/partial_ord.rs":"e16b11805c94048acd058c93994b5bc74bb187f8d7e3b86a87df60e1601467f9","src/api/cmp/vertical.rs":"de3d62f38eba817299aa16f1e1939954c9a447e316509397465c2830852ba053","src/api/default.rs":"b61f92fc0e33a2633b3375eb405beba480da071cde03df4d437d8a6058afcd97","src/api/fmt.rs":"67fb804bb86b6cd77cf8cd492b5733ce437071b66fe3297278b8a6552c325dda","src/api/fmt/binary.rs":"35cb5c266197d6224d598fb3d286e5fe48ef0c01ed356c2ff6fe9ba946f96a92","src/api/fmt/debug.rs":"aa18eea443bf353fea3db8b1a025132bbcaf91e747ecfa43b8d9fce9af395a0c","src/api/fmt/lower_hex.rs":"69d5be366631af309f214e8031c8c20267fcc27a695eac6f45c6bc1df72a67e6","src/api/fmt/octal.rs":"9eb11ba3d990213f3c7f1ec25edba7ce997cb1320e16d308c83498ba6b9bfbd9","src/api/fmt/upper_hex.rs":"a4637d085b7bb20e759ce58e08435b510a563ba3dd468af2b03560fdc5511562","src/api/from.rs":"2e599d8329cb05eaf06224cc441355c4b7b51254fc19256619333be8c149d444","src/api/from/from_array.rs":"4151593c7bba7455821fffa5b59867005a77c95d32f1f0cc3fd87294000157d9","src/api/from/from_vector.rs":"9764371aa9e6005aace74dea14f59e5611a095b7cf42707940924749282c52f0","src/api/hash.rs":"562cfa3f1d8eb9a733c035a3665a599c2f1e341ee820d8fbdd102a4398a441bc","src/api/into_bits.rs":"82297f0697d67b5a015e904e7e6e7b2a7066ba825bc54b94b4ff3e22d7a1eefb","src/api/into_bits/arch_specific.rs":"1f925390b0ce7132587d95f2419c6e2ad3e1a9d17eb1d9c120a1c1c4bdf4277e","src/api/into_bits/macros.rs":"d762406de25aedff88d460dec7a80dc8e825a2a419d53218ce007efa6a1d3e04","src/api/into_bits/v128.rs":"ecdc5893664c71d7ab1ff3697c3fbe490d20d8748b9b76881d05e7625e40d74c","src/api/into_bits/v16.rs":"5459ec7dad1ad7bd30dc7e48374580b993abf23701d9c3cb22203fa0a9aabb6d","src/api/into_bits/v256.rs":"90ea351da0380ead1bf0f63b620afd40d01d638d09f7e7be31840bd2c1d9c663","src/api/into_bits/v32.rs":"ee1dc5a430050e16f51154b5fe85b1536f5feddf2ea23dd1d3859b67c4afc6fc","src/api/into_bits/v512.rs":"f72098ed1c9a23944f3d01abaf5e0f2d0e81d35a06fdadd2183e896d41b59867","src/api/into_bits/v64.rs":"6394462facdfe7827349c742b7801f1291e75a720dfb8c0b52100df46f371c98","src/api/math.rs":"8b2a2fc651917a850539f993aa0b9e5bf4da67b11685285b8de8cdca311719ec","src/api/math/float.rs":"61d2794d68262a1090ae473bd30793b5f65cf732f32a6694a3af2ce5d9225616","src/api/math/float/abs.rs":"5b6b2701e2e11135b7ce58a05052ea8120e10e4702c95d046b9d21b827b26bf8","src/api/math/float/consts.rs":"78acba000d3fa527111300b6327c1932de9c4c1e02d4174e1a5615c01463d38c","src/api/math/float/cos.rs":"4c2dd7173728ef189314f1576c9486e03be21b7da98843b2f9011282a7979e31","src/api/math/float/exp.rs":"7c6d5f1e304f498a01cfa23b92380c815d7da0ad94eae3483783bc377d287eef","src/api/math/float/ln.rs":"54c7583f3df793b39ff57534fade27b41bb992439e5dc178252f5ca3190a3e54","src/api/math/float/mul_add.rs":"62cac77660d20159276d4c9ef066eb90c81cbddb808e8e157182c607625ad2eb","src/api/math/float/mul_adde.rs":"bae056ee9f3a70df39ec3c3b2f6437c65303888a7b843ef1a5bcf1f5aca0e602","src/api/math/float/powf.rs":"9ddb938984b36d39d82a82f862f80df8f7fb013f1d222d45698d41d88472f568","src/api/math/float/recpre.rs":"589225794ff1dbf31158dff660e6d4509ecc8befbb57c633900dea5ac0b840d6","src/api/math/float/rsqrte.rs":"a32abdcc318d7ccc8448231f54d75b884b7cbeb03a7d595713ab6243036f4dbf","src/api/math/float/sin.rs":"cbd3622b7df74f19691743001c8cf747a201f8977ad90542fee915f37dcd1e49","src/api/math/float/sqrt.rs":"0c66d5d63fb08e4d99c6b82a8828e41173aff1ac9fa1a2764a11fac217ccf2ac","src/api/math/float/sqrte.rs":"731e1c9f321b662accdd27dacb3aac2e8043b7aecb2f2161dde733bd9f025362","src/api/minimal.rs":"1f22bcc528555444e76de569ec0ae2029b9ae9d04805efeafa93369c8098036b","src/api/minimal/iuf.rs":"c501a6696950cf5e521765f178de548af64fdfb6e10d026616d09fab93ca2d17","src/api/minimal/mask.rs":"42e415f536c5193d0218f5a754b34b87fd7c971bff068009f958712166ff056d","src/api/minimal/ptr.rs":"a9ee482d1dd1c956fb8f3f179e6e620b1de4e9d713961461d4c6923a4ef2e67c","src/api/ops.rs":"3e273b277a0f3019d42c3c59ca94a5afd4885d5ae6d2182e5089bbeec9de42ee","src/api/ops/scalar_arithmetic.rs":"d2d5ad897a59dd0787544f927e0e7ca4072c3e58b0f4a2324083312b0d5a21d7","src/api/ops/scalar_bitwise.rs":"482204e459ca6be79568e1c9f70adbe2d2151412ddf122fb2161be8ebb51c40c","src/api/ops/scalar_mask_bitwise.rs":"c250f52042e37b22d57256c80d4604104cfd2fbe2a2e127c676267270ca5d350","src/api/ops/scalar_shifts.rs":"987f8fdebeedc16e3d77c1b732e7826ef70633c541d16dfa290845d5c6289150","src/api/ops/vector_arithmetic.rs":"ddca15d09ddeef502c2ed66117a62300ca65d87e959e8b622d767bdf1c307910","src/api/ops/vector_bitwise.rs":"b3968f7005b649edcc22a54e2379b14d5ee19045f2e784029805781ae043b5ee","src/api/ops/vector_float_min_max.rs":"f5155dce75219f4ba11275b1f295d2fdcddd49d174a6f1fb2ace7ea42813ce41","src/api/ops/vector_int_min_max.rs":"a378789c6ff9b32a51fbd0a97ffd36ed102cd1fe6a067d2b02017c1df342def6","src/api/ops/vector_mask_bitwise.rs":"5052d18517d765415d40327e6e8e55a312daaca0a5e2aec959bfa54b1675f9c8","src/api/ops/vector_neg.rs":"5c62f6b0221983cdbd23cd0a3af3672e6ba1255f0dfe8b19aae6fbd6503e231b","src/api/ops/vector_rotates.rs":"03cbe8a400fd7c688e4ee771a990a6754f2031b1a59b19ae81158b21471167e5","src/api/ops/vector_shifts.rs":"9bf69d0087268f61009e39aea52e03a90f378910206b6a28e8393178b6a5d0e0","src/api/ptr.rs":"8a793251bed6130dcfb2f1519ceaa18b751bbb15875928d0fb6deb5a5e07523a","src/api/ptr/gather_scatter.rs":"9ddd960365e050674b25b2fd3116e24d94669b4375d74e71c03e3f1469576066","src/api/reductions.rs":"ae5baca81352ecd44526d6c30c0a1feeda475ec73ddd3c3ec6b14e944e5448ee","src/api/reductions/bitwise.rs":"8bf910ae226188bd15fc7e125f058cd2566b6186fcd0cd8fd020f352c39ce139","src/api/reductions/float_arithmetic.rs":"e58c8c87806a95df2b2b5b48ac5991036df024096d9d7c171a480fe9282896a4","src/api/reductions/integer_arithmetic.rs":"47471da1c5f859489680bb5d34ced3d3aa20081c16053a3af121a4496fcb57bf","src/api/reductions/mask.rs":"db83327a950e33a317f37fd33ca4e20c347fb415975ec024f3e23da8509425af","src/api/reductions/min_max.rs":"f27be3aa28e1c1f46de7890198db6e12f00c207085e89ef2de7e57ee443cdb98","src/api/select.rs":"a98e2ccf9fc6bdeed32d337c8675bc96c2fbe2cc34fbf149ad6047fb8e749774","src/api/shuffle.rs":"da58200790868c09659819322a489929a5b6e56c596ed07e6a44293ea02e7d09","src/api/shuffle1_dyn.rs":"bfea5a91905b31444e9ef7ca6eddb7a9606b7e22d3f71bb842eb2795a0346620","src/api/slice.rs":"ee87484e8af329547b9a5d4f2a69e8bed6ea10bbd96270d706083843d4eea2ac","src/api/slice/from_slice.rs":"4d4fe8a329c885fcb4fbcbedf99efb15a95296fe6b3f595056cc37037450d5ac","src/api/slice/write_to_slice.rs":"f5b23b2c4b91cfb26b713a9013a6c0da7f45eaefb79ba06dcbc27f3f23bda679","src/api/swap_bytes.rs":"4a6792a2e49a77475e1b237592b4b2804dbddb79c474331acd0dd71b36934259","src/codegen.rs":"c6eebc3d3665420aa6a2f317977e3c41a4f43e0550ac630cdbe8e4bbed5e2031","src/codegen/bit_manip.rs":"5559e095105a80003e0de35af1d19b0c65c9ab04eb743c7e01c5442d882eb34e","src/codegen/llvm.rs":"d1299c189abb17a6133f047574cffc7a6db4c1be37cb7d4785491cb5e8f8cf54","src/codegen/math.rs":"35f96e37a78fcf0cdb02146b7f27a45108fe06a37fc2a54d8851ce131a326178","src/codegen/math/float.rs":"dd86c0449e576c83b719700962ac017c332987fac08d91f2b7a2b1b883598170","src/codegen/math/float/abs.rs":"f56e2b4b8055ea861c1f5cbc6b6e1d8e7e5af163b62c13574ddee4e09513bfbc","src/codegen/math/float/cos.rs":"ef3b511a24d23045b310315e80348a9b7fedb576fc2de52d74290616a0abeb2a","src/codegen/math/float/cos_pi.rs":"4e7631a5d73dac21531e09ef1802d1180f8997509c2c8fa9f67f322194263a97","src/codegen/math/float/exp.rs":"61b691598c41b5622f24e4320c1bdd08701e612a516438bdddcc728fc3405c8c","src/codegen/math/float/ln.rs":"46b718b1ba8c9d99e1ad40f53d20dfde08a3063ca7bd2a9fdd6698e060da687e","src/codegen/math/float/macros.rs":"dd42135fff13f9aca4fd3a1a4e14c7e6c31aadc6d817d63b0d2fb9e62e062744","src/codegen/math/float/mul_add.rs":"a37bf764345d4b1714f97e83897b7cf0855fc2811704bcbc0012db91825339e1","src/codegen/math/float/mul_adde.rs":"c75702bfcb361de45964a93caf959a695ef2376bd069227600b8c6872665c755","src/codegen/math/float/powf.rs":"642346e982bc4c39203de0864d2149c4179cd7b21cf67a2951687932b4675872","src/codegen/math/float/sin.rs":"9d68164c90cdca6a85155040cdac42e27342ebe0b925273ef1593df721af4258","src/codegen/math/float/sin_cos_pi.rs":"9be02ad48585a1e8d99129382fbffbaed47852f15459256a708850b6b7a75405","src/codegen/math/float/sin_pi.rs":"9890347905b4d4a3c7341c3eb06406e46e60582bcf6960688bd727e5dadc6c57","src/codegen/math/float/sqrt.rs":"e3c60dcfb0c6d2fc62adabcc931b2d4040b83cab294dea36443fb4b89eb79e34","src/codegen/math/float/sqrte.rs":"f0f4ef9eb475ae41bcc7ec6a95ad744ba6b36925faa8b2c2814004396d196b63","src/codegen/pointer_sized_int.rs":"a70697169c28218b56fd2e8d5353f2e00671d1150d0c8cef77d613bdfacd84cb","src/codegen/reductions.rs":"645e2514746d01387ddd07f0aa4ffd8430cc9ab428d4fb13773ea319fa25dd95","src/codegen/reductions/mask.rs":"8f1afe6aabf096a3278e1fc3a30f736e04aa8b9ce96373cee22162d18cfe2702","src/codegen/reductions/mask/aarch64.rs":"cba6e17603d39795dcfe8339b6b7d8714c3e162a1f0a635979f037aa24fe4206","src/codegen/reductions/mask/arm.rs":"9447904818aa2c7c25d0963eead452a639a11ca7dbd6d21eedbfcaade07a0f33","src/codegen/reductions/mask/fallback.rs":"7a0ef9f7fd03ae318b495b95e121350cd61caffc5cc6ee17fabf130d5d933453","src/codegen/reductions/mask/fallback_impl.rs":"76547f396e55ef403327c77c314cf8db8c7a5c9b9819bfb925abeacf130249e5","src/codegen/reductions/mask/x86.rs":"14bd2c482071f2355beebcf7b7ecf950ff2dfcdb08c3ca50993092434a9de717","src/codegen/reductions/mask/x86/avx.rs":"b4913d87844c522903641cbbf10db4551addb1ce5e9e78278e21612fa65c733b","src/codegen/reductions/mask/x86/avx2.rs":"677aed3f056285285daa3adff8bc65e739630b4424defa6d9665e160f027507e","src/codegen/reductions/mask/x86/sse.rs":"226610b4ff88c676d5187114dd57b4a8800de6ce40884675e9198445b1ed0306","src/codegen/reductions/mask/x86/sse2.rs":"bc38e6c31cb4b3d62147eba6cac264e519e2a48e0f7ce9010cfa9ef0cf0ec9fd","src/codegen/shuffle.rs":"0abca97e92cdce49a58a39cc447eb09dc7d7715ef256c8dbd2181a186e61bb64","src/codegen/shuffle1_dyn.rs":"04523e9338133bdedb012dd076c2c564b79ce5593b0fc56d0fb6910e04190a81","src/codegen/swap_bytes.rs":"1d6cdc716eadddc92b4fd506b2445a821caa8dc00860447de09d7ebd69c2087f","src/codegen/v128.rs":"94226b31ec403d18d9d2fe06713f147c9c79e9b5f9105089088266313f843185","src/codegen/v16.rs":"ddec4ffb66b6f7aaffb9a1780c5ddba82557abd74f45073d335047e04cf74924","src/codegen/v256.rs":"6b63917f0444118d6b1595bff2045e59b97c4d24012bd575f69f1f0efc5a0241","src/codegen/v32.rs":"3477b3c5540aed86e61e2f5807dd31db947413cec9181c587d93ed6ec74f0eba","src/codegen/v512.rs":"5854f99d3aabc4cd42b28a20d9ce447756dc2ba024a409a69b6a8ae1f1842fc5","src/codegen/v64.rs":"e9e89caebfe63d10c0cbca61e4dfdba3b7e02ee0989170f80beed23237ddd950","src/codegen/vPtr.rs":"96d609a9eece4dcbbcc01ba0b8744d7f5958be12774176a2945bc676f4e6b5cb","src/codegen/vSize.rs":"eeee9858749aa82142b27bc120d1989bb74a6b82e1e4efbbeaccc9634dc9acfc","src/lib.rs":"1b5d419ff05ee0370d671810423ccc254708cc8d415c1dbac2a7a36be4bf63a8","src/masks.rs":"870f429967b2d7d5133f4d28d6c753fc5cef0570b27b29d4e966a066d22d2d0e","src/sealed.rs":"ff7f0324276408ae8249941cfa32c90b8835a54d750896b683efea857af19db2","src/testing.rs":"1d3a7862ef625e235a5734ad7204e68d350f902c0695182b1f08a0552432416e","src/testing/macros.rs":"6378856d7a40ba5ec5c7c0dad6327d79f0c77266921c24296d10aed6c68e9b98","src/testing/utils.rs":"d6fd5a5017f1f85d9d99585754f8f6ad06fc3d683b34083543e67a7cc6c1772c","src/v128.rs":"18fe263c4aa28cd06461c7070b0269f69f4a2e75749b8f142a83dfdfe4d22bf5","src/v16.rs":"e5c663c9fb3547eaeac78a5f7db9969f4d8b5ec96112bf2954602fff11f0aebd","src/v256.rs":"68732cd688ad12a56d8b4f8ddf279f77bdfe1be2943c7dc0c1b4f1a76798aa0f","src/v32.rs":"785b22a1ccb4a41bb53dfeb0670f624c0ce42e6cdf62d1747e3283777a1c70bd","src/v512.rs":"d1337bfe07f06a8f37f8e8fa7d4315b9307476ee435ad80dd5269eaed564fbfa","src/v64.rs":"3077468d65125b8f085e9454c8b2463a4d5225697464ba6a1300f8799528fd4b","src/vPtr.rs":"c9a53f41f466e17b6648a4ce390fd8f4d3a848d440eb8a9a803a11608d76eb05","src/vSize.rs":"5c46d3e8c3ee5863d9b6e37e681f871386e0efc254d6d84ba711edb529ce7b3c","tests/endianness.rs":"541a144be017e3dd7da7c8ea49d907dc02538245e8c5f3deb5bd43da92c929e1"},"package":null}
\ No newline at end of file
+{"files":{".appveyor.yml":"f1ed01850e0d725f9498f52a1a63ddf40702ad6e0bf5b2d7c4c04d76e96794a3",".travis.yml":"d56de6531d3c4880e3aada85ac8e6d7388e5d781871e181cb8ade2a746d5d5f5","Cargo.toml":"e94ccb82002e8b55680c2c5fec554a9e864c5f354e113278d0aa927df279330d","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","README.md":"49d01e49a33393af64fa6c813b6a724f68a4d1abfbedcb96413651ed105aa820","bors.toml":"dee881dc69b9b7834e4eba5d95c3ed5a416d4628815a167d6a22d4cb4fb064b8","build.rs":"c3312e786c7fcb8f16c0785fe235ebbcf43fbeab6d7d683752f62043ca92d887","ci/all.sh":"2ae6b2445b4db83833e40b37efd0016c6b9879ee988b9b3ef94db5439a3e1606","ci/android-install-ndk.sh":"0f1746108cc30bf9b9ba45bcde7b19fc1a8bdf5b0258035b4eb8dc69b75efac4","ci/android-install-sdk.sh":"3490432022c5c8f5a115c084f7a9aca1626f96c0c87ffb62019228c4346b47e4","ci/android-sysimage.sh":"ebf4e5daa1f0fe1b2092b79f0f3f161c4c4275cb744e52352c4d81ab451e4c5a","ci/benchmark.sh":"b61d19ef6b90deba8fb79dee74c8b062d94844676293da346da87bb78a9a49a4","ci/deploy_and_run_on_ios_simulator.rs":"ec8ecf82d92072676aa47f0d1a3d021b60a7ae3531153ef12d2ff4541fc294dc","ci/docker/aarch64-linux-android/Dockerfile":"ace2e7d33c87bc0f6d3962a4a3408c04557646f7f51ab99cfbf574906796b016","ci/docker/aarch64-unknown-linux-gnu/Dockerfile":"da88c0d50f16dc08448c7fdf1fa5ed2cbe576acf9e7dd85b5b818621b2a8c702","ci/docker/arm-linux-androideabi/Dockerfile":"370e55d3330a413a3ccf677b3afb3e0ef9018a5fab263faa97ae8ac017fc2286","ci/docker/arm-unknown-linux-gnueabi/Dockerfile":"bb5f8ae890707c128652290ffc544447643bf12037ddd73c6ad6989f848cb380","ci/docker/arm-unknown-linux-gnueabihf/Dockerfile":"1afaefcbc05b740859acd4e067bc92439be6bcbe8f2e9678474fb434bcd398d9","ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile":"8282ea707a94109beed47a57574755e2d58401735904a03f85fb64c578c53b4f","ci/docker/i586-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/i686-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/mips-unknown-linux-gnu/Dockerfile":"b2ebc25797612c4f8395fe9d407725156044955bfbcf442036b7f55b43a5f9da","ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile":"b0c1692ac65bc56dd30494b1993d8e929c48cc9c4b92029b7c7592af6d4f9220","ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile":"4e9249c179300138141d0b2b7401b11897f64aed69f541f078c1db4594df2827","ci/docker/mipsel-unknown-linux-musl/Dockerfile":"3164c52b0dcbb01afa78292b15b5c43503ccf0491cf6eb801ec2bf22ae274e52","ci/docker/powerpc-unknown-linux-gnu/Dockerfile":"786f799d0b56eb54d7b6c4b00e1aed4ce81776e14e44767e083c89d014b72004","ci/docker/powerpc64-unknown-linux-gnu/Dockerfile":"e8bc363837cd9c2d8b22402acb8c1c329efc11ba5d12170603d2fe2eae9da059","ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile":"47998d45b781d797b9e6085ebe898d90de0c952b54537a8db4e8d7503eb032d9","ci/docker/s390x-unknown-linux-gnu/Dockerfile":"93fb44df3d7fd31ead158570667c97b5076a05c3d968af4a84bc13819a8f2db8","ci/docker/sparc64-unknown-linux-gnu/Dockerfile":"da1c39a3ff1fe22e41395fa7c8934e90b4c1788e551b9aec6e38bfd94effc437","ci/docker/thumbv7neon-linux-androideabi/Dockerfile":"c2decd5591bd7a09378901bef629cd944acf052eb55e4f35b79eb9cb4d62246a","ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile":"51955a8bf3c4d440f47382af6f5426ebff94ab01a04da36175babda9a057740f","ci/docker/wasm32-unknown-unknown/Dockerfile":"3e5f294bc1e004aa599086c2af49d6f3e7459fa250f5fbdd60cf67d53db78758","ci/docker/x86_64-linux-android/Dockerfile":"685040273cf350d5509e580ac451555efa19790c8723ca2af066adadc6880ad2","ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile":"44b6203d9290bfdc53d81219f0937e1110847a23dd982ec8c4de388354f01536","ci/docker/x86_64-unknown-linux-gnu/Dockerfile":"7f4e3ca5fa288ea70edb4d1f75309708cd30b192e2e4444e61c4d5b3b58f89cf","ci/dox.sh":"434e9611c52e389312d2b03564adf09429f10cc76fe66a8644adb104903b87b7","ci/linux-s390x.sh":"d6b732d7795b4ba131326aff893bca6228a7d2eb0e9402f135705413dbbe0dce","ci/linux-sparc64.sh":"c92966838b1ab7ad3b7a344833ee726aba6b647cf5952e56f0ad1ba420b13325","ci/lld-shim.rs":"3d7f71ec23a49e2b67f694a0168786f9a954dda15f5a138815d966643fd3fcc3","ci/max_line_width.sh":"0a1518bba4c9ecaa55694cb2e9930d0e19c265baabf73143f17f9cf285aaa5bb","ci/run-docker.sh":"92e036390ad9b0d16f109579df1b5ced2e72e9afea40c7d011400ebd3a2a90de","ci/run.sh":"41dd6a60efaaeae9661a01370cce98b631f78392859a0cf68c946c0a16edf5f7","ci/run_examples.sh":"d1a23c6c35374a0678ba5114b9b8fefd8be0a79e774872a8bf0898d1baca18d0","ci/runtest-android.rs":"145a8e9799a5223975061fe7e586ade5669ee4877a7d7a4cf6b4ab48e8e36c7c","ci/setup_benchmarks.sh":"fae3960023f6f3d1388cd2ad22fdbab4b075f1f29dd4292d7994a20783beb6cf","ci/test-runner-linux":"c8aa6025cff5306f4f31d0c61dc5f9d4dd5a1d189ab613ef8d4c367c694d9ccd","contributing.md":"2cc8c9c560ae17867e69b06d09b758dbf7bc39eb774ada50a743724b10acc0a2","perf-guide/.gitignore":"fe82c7da551079d832cf74200b0b359b4df9828cb4a0416fa7384f07a2ae6a13","perf-guide/book.toml":"115a98284126c6b180178b44713314cc494f08a71662ee2ce15cf67f17a51064","perf-guide/src/SUMMARY.md":"3e03bffc991fdc2050f3d51842d72d9d21ea6abab56a3baf3b2d5973a78b89e1","perf-guide/src/ascii.css":"29afb08833b2fe2250f0412e1fa1161a2432a0820a14953c87124407417c741a","perf-guide/src/bound_checks.md":"5e4991ff58a183ef0cd9fdc1feb4cd12d083b44bdf87393bbb0927808ef3ce7d","perf-guide/src/float-math/approx.md":"8c09032fa2d795a0c5db1775826c850d28eb2627846d0965c60ee72de63735ad","perf-guide/src/float-math/fma.md":"311076ba4b741d604a82e74b83a8d7e8c318fcbd7f64c4392d1cf5af95c60243","perf-guide/src/float-math/fp.md":"04153e775ab6e4f0d7837bcc515230d327b04edfa34c84ce9c9e10ebaeef2be8","perf-guide/src/float-math/svml.md":"0798873b8eedaeda5fed62dc91645b57c20775a02d3cd74d8bd06958f1516506","perf-guide/src/introduction.md":"9f5a19e9e6751f25d2daad39891a0cc600974527ec4c8305843f9618910671bd","perf-guide/src/prof/linux.md":"447731eb5de7d69166728fdbc5ecb0c0c9db678ea493b45a592d67dd002184c0","perf-guide/src/prof/mca.md":"f56d54f3d20e7aa4d32052186e8237b03d65971eb5d112802b442570ff11d344","perf-guide/src/prof/profiling.md":"8a650c0fd6ede0964789bb6577557eeef1d8226a896788602ce61528e260e43c","perf-guide/src/target-feature/attribute.md":"615f88dca0a707b6c416fa605435dd6e1fb5361cc639429cbf68cd87624bd78b","perf-guide/src/target-feature/features.md":"17077760ff24c006b606dd21889c53d87228f4311f3ba3a574f9afdeacd86165","perf-guide/src/target-feature/inlining.md":"7ed1d7068d8173a00d84c16cfe5871cd68b9f04f8d0cca2d01ebc84957ebf2f6","perf-guide/src/target-feature/practice.md":"c4b371842e0086df178488fec97f20def8f0c62ee588bcd25fd948b9b1fa227e","perf-guide/src/target-feature/runtime.md":"835425f5ee597fb3e51d36e725a81ebee29f4561231d19563cd4da81dbb1cfcb","perf-guide/src/target-feature/rustflags.md":"ab49712e9293a65d74d540ba4784fcb57ff1119ec05a575d895c071f1a620f64","perf-guide/src/vert-hor-ops.md":"c6211c0ee91e60552ec592d89d9d957eedc21dee3cbd89e1ad6765ea06a27471","rustfmt.toml":"de6101d0670bad65fb3b337d56957d2a024e017e5ab146ec784d77312daaf8ff","src/api.rs":"f6e92f056565e6fd93f98829a408aee9e790251e0cbd8a8bc30c8662b4d6fabb","src/api/bit_manip.rs":"c47a4d0f7451f7e35d07715e4f39a472e07457fd456fdb726864a4f6887252a3","src/api/bitmask.rs":"6d2beefd62ee5d9c8eb060bee6abc641616bf828c99f82abf97b21bf004e894b","src/api/cast.rs":"03b94a3d316ac7b7be7068810044911e965e889a0ace7bae762749ca74a92747","src/api/cast/macros.rs":"b0a14d0c83ad2ebb7a275180f6d9e3f2bc312ba57a7d3d6c39fad4e0f20f9408","src/api/cast/v128.rs":"2107ea6a426a0fe37a0aa6a03a579ff0bdeb5a1599ea76e2d81734a82f41276d","src/api/cast/v16.rs":"d785cf93b8e61200c9ae1c32b9f5e9d9518e87c261c56bcaf92f2e47b0009eb4","src/api/cast/v256.rs":"b81fcfd367a5de532d922dedf18579e53666facef7957c0e1bc827825e500ae6","src/api/cast/v32.rs":"2aac9ec0a67a97328ba908b13a1ff98da3dcd7781910d592d31f9207cbd9a7d2","src/api/cast/v512.rs":"33b33de818f8d4eccc982bc2f3951a8b3d03e9762ec02789b3df82e3f5ed3fc3","src/api/cast/v64.rs":"ec878917d52a8c952633251b3a938a2cbe0a63fee6d12c15840d9f1343d1f394","src/api/cmp.rs":"357c3a2a09c6d4611c32dd7fa95be2fae933d513e229026ec9b44451a77b884e","src/api/cmp/eq.rs":"60f70f355bae4cb5b17db53204cacc3890f70670611c17df638d4c04f7cc8075","src/api/cmp/ord.rs":"589f7234761c294fa5df8f525bc4acd5a47cdb602207d524a0d4e19804cd9695","src/api/cmp/partial_eq.rs":"3ed23d2a930b0f9750c3a5309da766b03dc4f9c4d375b42ad3c50fe732693d15","src/api/cmp/partial_ord.rs":"e16b11805c94048acd058c93994b5bc74bb187f8d7e3b86a87df60e1601467f9","src/api/cmp/vertical.rs":"de3d62f38eba817299aa16f1e1939954c9a447e316509397465c2830852ba053","src/api/default.rs":"67bf21c134127d12a7028c8b88a57f0ceee8ccbd74976da8ca74eb9f16a174d5","src/api/fmt.rs":"67fb804bb86b6cd77cf8cd492b5733ce437071b66fe3297278b8a6552c325dda","src/api/fmt/binary.rs":"35cb5c266197d6224d598fb3d286e5fe48ef0c01ed356c2ff6fe9ba946f96a92","src/api/fmt/debug.rs":"aa18eea443bf353fea3db8b1a025132bbcaf91e747ecfa43b8d9fce9af395a0c","src/api/fmt/lower_hex.rs":"69d5be366631af309f214e8031c8c20267fcc27a695eac6f45c6bc1df72a67e6","src/api/fmt/octal.rs":"9eb11ba3d990213f3c7f1ec25edba7ce997cb1320e16d308c83498ba6b9bfbd9","src/api/fmt/upper_hex.rs":"a4637d085b7bb20e759ce58e08435b510a563ba3dd468af2b03560fdc5511562","src/api/from.rs":"2e599d8329cb05eaf06224cc441355c4b7b51254fc19256619333be8c149d444","src/api/from/from_array.rs":"dd3fc64fb17d6184bb60343f8da26a05edf0e5f3c14caf55d49fa15e21d948dc","src/api/from/from_vector.rs":"9764371aa9e6005aace74dea14f59e5611a095b7cf42707940924749282c52f0","src/api/hash.rs":"5076ece87969592c876486f5b1ea8affbeaec379d1a14a30859e0aa5592019de","src/api/into_bits.rs":"82297f0697d67b5a015e904e7e6e7b2a7066ba825bc54b94b4ff3e22d7a1eefb","src/api/into_bits/arch_specific.rs":"4acab22af90112072a2608fafc66fccf18cbf2e641b72af28404d30833cfe5c6","src/api/into_bits/macros.rs":"d762406de25aedff88d460dec7a80dc8e825a2a419d53218ce007efa6a1d3e04","src/api/into_bits/v128.rs":"3c502b9ce85bfcc727d6f053d49030b0ba9f46bd8e9fa5aa109382a2033f9f87","src/api/into_bits/v16.rs":"f4f4f61ba88aa51b158ec56ca3dce234349aea0daf2b3029a14ab5125d1e41e5","src/api/into_bits/v256.rs":"c24c3676707a0feb868dabe00766d74deab176794f905f79056337198c7cf790","src/api/into_bits/v32.rs":"905ba683d342fa32f4202b80bb46530807bd0a5b588f6c2e8c9f475223c47775","src/api/into_bits/v512.rs":"7cd89005215a9326eed8a742125dcbf981cba1aca72a313478eabf3df71b1160","src/api/into_bits/v64.rs":"d6238022ccff7b92e55b3f6017fc269acb6f36330a6d7e8fb389853a0f1b6478","src/api/math.rs":"8b2a2fc651917a850539f993aa0b9e5bf4da67b11685285b8de8cdca311719ec","src/api/math/float.rs":"61d2794d68262a1090ae473bd30793b5f65cf732f32a6694a3af2ce5d9225616","src/api/math/float/abs.rs":"5b6b2701e2e11135b7ce58a05052ea8120e10e4702c95d046b9d21b827b26bf8","src/api/math/float/consts.rs":"78acba000d3fa527111300b6327c1932de9c4c1e02d4174e1a5615c01463d38c","src/api/math/float/cos.rs":"4c2dd7173728ef189314f1576c9486e03be21b7da98843b2f9011282a7979e31","src/api/math/float/exp.rs":"7c6d5f1e304f498a01cfa23b92380c815d7da0ad94eae3483783bc377d287eef","src/api/math/float/ln.rs":"54c7583f3df793b39ff57534fade27b41bb992439e5dc178252f5ca3190a3e54","src/api/math/float/mul_add.rs":"62cac77660d20159276d4c9ef066eb90c81cbddb808e8e157182c607625ad2eb","src/api/math/float/mul_adde.rs":"bae056ee9f3a70df39ec3c3b2f6437c65303888a7b843ef1a5bcf1f5aca0e602","src/api/math/float/powf.rs":"9ddb938984b36d39d82a82f862f80df8f7fb013f1d222d45698d41d88472f568","src/api/math/float/recpre.rs":"589225794ff1dbf31158dff660e6d4509ecc8befbb57c633900dea5ac0b840d6","src/api/math/float/rsqrte.rs":"a32abdcc318d7ccc8448231f54d75b884b7cbeb03a7d595713ab6243036f4dbf","src/api/math/float/sin.rs":"cbd3622b7df74f19691743001c8cf747a201f8977ad90542fee915f37dcd1e49","src/api/math/float/sqrt.rs":"0c66d5d63fb08e4d99c6b82a8828e41173aff1ac9fa1a2764a11fac217ccf2ac","src/api/math/float/sqrte.rs":"731e1c9f321b662accdd27dacb3aac2e8043b7aecb2f2161dde733bd9f025362","src/api/minimal.rs":"1f22bcc528555444e76de569ec0ae2029b9ae9d04805efeafa93369c8098036b","src/api/minimal/iuf.rs":"819cff26d3e196f807645bcc1d79eb27d9f175edb89910f2274d52a1e913cd11","src/api/minimal/mask.rs":"0cae10ae1fc65f5070e686c0c79bfba27b86b33d6c399367bd4848fb367dcec4","src/api/minimal/ptr.rs":"f65ebf21866a863485344432d9a7a9b7418f7fad5fdf841a4e2fa56ec0766ad0","src/api/ops.rs":"3e273b277a0f3019d42c3c59ca94a5afd4885d5ae6d2182e5089bbeec9de42ee","src/api/ops/scalar_arithmetic.rs":"d2d5ad897a59dd0787544f927e0e7ca4072c3e58b0f4a2324083312b0d5a21d7","src/api/ops/scalar_bitwise.rs":"482204e459ca6be79568e1c9f70adbe2d2151412ddf122fb2161be8ebb51c40c","src/api/ops/scalar_mask_bitwise.rs":"c250f52042e37b22d57256c80d4604104cfd2fbe2a2e127c676267270ca5d350","src/api/ops/scalar_shifts.rs":"987f8fdebeedc16e3d77c1b732e7826ef70633c541d16dfa290845d5c6289150","src/api/ops/vector_arithmetic.rs":"ddca15d09ddeef502c2ed66117a62300ca65d87e959e8b622d767bdf1c307910","src/api/ops/vector_bitwise.rs":"b3968f7005b649edcc22a54e2379b14d5ee19045f2e784029805781ae043b5ee","src/api/ops/vector_float_min_max.rs":"76bf8cb607e2c442923c1da1061a6b80d742d607408033c2a3761161114cf2a0","src/api/ops/vector_int_min_max.rs":"a378789c6ff9b32a51fbd0a97ffd36ed102cd1fe6a067d2b02017c1df342def6","src/api/ops/vector_mask_bitwise.rs":"5052d18517d765415d40327e6e8e55a312daaca0a5e2aec959bfa54b1675f9c8","src/api/ops/vector_neg.rs":"5c62f6b0221983cdbd23cd0a3af3672e6ba1255f0dfe8b19aae6fbd6503e231b","src/api/ops/vector_rotates.rs":"03cbe8a400fd7c688e4ee771a990a6754f2031b1a59b19ae81158b21471167e5","src/api/ops/vector_shifts.rs":"9bf69d0087268f61009e39aea52e03a90f378910206b6a28e8393178b6a5d0e0","src/api/ptr.rs":"8a793251bed6130dcfb2f1519ceaa18b751bbb15875928d0fb6deb5a5e07523a","src/api/ptr/gather_scatter.rs":"138b02b0fa1fdd785b95fc7048488be7e3ef277e0bc6ac5affb26af6a11d41a6","src/api/reductions.rs":"ae5baca81352ecd44526d6c30c0a1feeda475ec73ddd3c3ec6b14e944e5448ee","src/api/reductions/bitwise.rs":"8bf910ae226188bd15fc7e125f058cd2566b6186fcd0cd8fd020f352c39ce139","src/api/reductions/float_arithmetic.rs":"3997125f87c7bac07fffda3a1d814e0e6c77ca83099546a9e2fb8dc92231129f","src/api/reductions/integer_arithmetic.rs":"47471da1c5f859489680bb5d34ced3d3aa20081c16053a3af121a4496fcb57bf","src/api/reductions/mask.rs":"db83327a950e33a317f37fd33ca4e20c347fb415975ec024f3e23da8509425af","src/api/reductions/min_max.rs":"d40ccad10220ae5982785015bef92e4b0749583c2b060cad0aa4f92d99491c3b","src/api/select.rs":"a98e2ccf9fc6bdeed32d337c8675bc96c2fbe2cc34fbf149ad6047fb8e749774","src/api/shuffle.rs":"da58200790868c09659819322a489929a5b6e56c596ed07e6a44293ea02e7d09","src/api/shuffle1_dyn.rs":"bfea5a91905b31444e9ef7ca6eddb7a9606b7e22d3f71bb842eb2795a0346620","src/api/slice.rs":"ee87484e8af329547b9a5d4f2a69e8bed6ea10bbd96270d706083843d4eea2ac","src/api/slice/from_slice.rs":"53691dc9958dec4180004a42d140552b405e8cd875caa282e89af378dd63c8bc","src/api/slice/write_to_slice.rs":"3dd2e511af43dc6fa911dd0b12f6f00323e0acd1202a01365db400557d52a89b","src/api/swap_bytes.rs":"4a6792a2e49a77475e1b237592b4b2804dbddb79c474331acd0dd71b36934259","src/codegen.rs":"a29d38fa0a85eaf787fb49989e625bf64effd5f39c126fbb2a24be206d2a3917","src/codegen/bit_manip.rs":"17ecebcff1f080e712fea5eb51602a73f4201ed56a198220342c8eb55bb92692","src/codegen/llvm.rs":"b1f24237f61b7c5ddb8d47f3943aab79a95ce0e75af87ab2d1c88d842faffd39","src/codegen/math.rs":"35f96e37a78fcf0cdb02146b7f27a45108fe06a37fc2a54d8851ce131a326178","src/codegen/math/float.rs":"dd86c0449e576c83b719700962ac017c332987fac08d91f2b7a2b1b883598170","src/codegen/math/float/abs.rs":"f56e2b4b8055ea861c1f5cbc6b6e1d8e7e5af163b62c13574ddee4e09513bfbc","src/codegen/math/float/cos.rs":"ef3b511a24d23045b310315e80348a9b7fedb576fc2de52d74290616a0abeb2a","src/codegen/math/float/cos_pi.rs":"4e7631a5d73dac21531e09ef1802d1180f8997509c2c8fa9f67f322194263a97","src/codegen/math/float/exp.rs":"61b691598c41b5622f24e4320c1bdd08701e612a516438bdddcc728fc3405c8c","src/codegen/math/float/ln.rs":"46b718b1ba8c9d99e1ad40f53d20dfde08a3063ca7bd2a9fdd6698e060da687e","src/codegen/math/float/macros.rs":"dd42135fff13f9aca4fd3a1a4e14c7e6c31aadc6d817d63b0d2fb9e62e062744","src/codegen/math/float/mul_add.rs":"a37bf764345d4b1714f97e83897b7cf0855fc2811704bcbc0012db91825339e1","src/codegen/math/float/mul_adde.rs":"c75702bfcb361de45964a93caf959a695ef2376bd069227600b8c6872665c755","src/codegen/math/float/powf.rs":"642346e982bc4c39203de0864d2149c4179cd7b21cf67a2951687932b4675872","src/codegen/math/float/sin.rs":"9d68164c90cdca6a85155040cdac42e27342ebe0b925273ef1593df721af4258","src/codegen/math/float/sin_cos_pi.rs":"9be02ad48585a1e8d99129382fbffbaed47852f15459256a708850b6b7a75405","src/codegen/math/float/sin_pi.rs":"9890347905b4d4a3c7341c3eb06406e46e60582bcf6960688bd727e5dadc6c57","src/codegen/math/float/sqrt.rs":"e3c60dcfb0c6d2fc62adabcc931b2d4040b83cab294dea36443fb4b89eb79e34","src/codegen/math/float/sqrte.rs":"f0f4ef9eb475ae41bcc7ec6a95ad744ba6b36925faa8b2c2814004396d196b63","src/codegen/pointer_sized_int.rs":"a70697169c28218b56fd2e8d5353f2e00671d1150d0c8cef77d613bdfacd84cb","src/codegen/reductions.rs":"645e2514746d01387ddd07f0aa4ffd8430cc9ab428d4fb13773ea319fa25dd95","src/codegen/reductions/mask.rs":"8f1afe6aabf096a3278e1fc3a30f736e04aa8b9ce96373cee22162d18cfe2702","src/codegen/reductions/mask/aarch64.rs":"cba6e17603d39795dcfe8339b6b7d8714c3e162a1f0a635979f037aa24fe4206","src/codegen/reductions/mask/arm.rs":"9447904818aa2c7c25d0963eead452a639a11ca7dbd6d21eedbfcaade07a0f33","src/codegen/reductions/mask/fallback.rs":"7a0ef9f7fd03ae318b495b95e121350cd61caffc5cc6ee17fabf130d5d933453","src/codegen/reductions/mask/fallback_impl.rs":"76547f396e55ef403327c77c314cf8db8c7a5c9b9819bfb925abeacf130249e5","src/codegen/reductions/mask/x86.rs":"4c0457b6276f9809223590092a4c77e73812330326cdabd28df06820de10a310","src/codegen/reductions/mask/x86/avx.rs":"b4913d87844c522903641cbbf10db4551addb1ce5e9e78278e21612fa65c733b","src/codegen/reductions/mask/x86/avx2.rs":"677aed3f056285285daa3adff8bc65e739630b4424defa6d9665e160f027507e","src/codegen/reductions/mask/x86/sse.rs":"5a827c6f8e1074e324f6e4c778942badb6c09d747a7142de01cadec1240b3428","src/codegen/reductions/mask/x86/sse2.rs":"bc38e6c31cb4b3d62147eba6cac264e519e2a48e0f7ce9010cfa9ef0cf0ec9fd","src/codegen/shuffle.rs":"99a0b52c2470097b028af134221099baba383446a01c7dc3ae560209880bcdb7","src/codegen/shuffle1_dyn.rs":"abbc95305dad815ab2ded3e8357791bcff080414668b55a4d397558a1d202d01","src/codegen/swap_bytes.rs":"1d6cdc716eadddc92b4fd506b2445a821caa8dc00860447de09d7ebd69c2087f","src/codegen/v128.rs":"94226b31ec403d18d9d2fe06713f147c9c79e9b5f9105089088266313f843185","src/codegen/v16.rs":"ddec4ffb66b6f7aaffb9a1780c5ddba82557abd74f45073d335047e04cf74924","src/codegen/v256.rs":"6b63917f0444118d6b1595bff2045e59b97c4d24012bd575f69f1f0efc5a0241","src/codegen/v32.rs":"3477b3c5540aed86e61e2f5807dd31db947413cec9181c587d93ed6ec74f0eba","src/codegen/v512.rs":"5854f99d3aabc4cd42b28a20d9ce447756dc2ba024a409a69b6a8ae1f1842fc5","src/codegen/v64.rs":"e9e89caebfe63d10c0cbca61e4dfdba3b7e02ee0989170f80beed23237ddd950","src/codegen/vPtr.rs":"711c753a08d53a2879c4fb87a0762c46ce4e34c22f0ca88d2e4c557a0f679969","src/codegen/vSize.rs":"eeee9858749aa82142b27bc120d1989bb74a6b82e1e4efbbeaccc9634dc9acfc","src/lib.rs":"b842b5e47008b9bd59af4d2e309b84204d90a53d36595684082adc46b6934987","src/masks.rs":"be05e923ac58fe6eb61311561b5583cd306574f206dc09fe8e3c7de3dd0c1433","src/sealed.rs":"ae7fdeaf5d84cd7710ed730ca72ca7eaba93df6cb0acb183e5c0a7327acf197f","src/testing.rs":"1d3a7862ef625e235a5734ad7204e68d350f902c0695182b1f08a0552432416e","src/testing/macros.rs":"6378856d7a40ba5ec5c7c0dad6327d79f0c77266921c24296d10aed6c68e9b98","src/testing/utils.rs":"5ec6a47b836f364ec6dede19750a19eaac704162327d03041eb0f007d5f8d75c","src/v128.rs":"16cf9a8e7156b899ee9b9cd3f2dba9d13ec63289bea8c3ee9ae2e43ad9510288","src/v16.rs":"cb6465cf1e00bf530183af1819b9fe3d7eec978f8765d5e85d9b58a39a4b4045","src/v256.rs":"fe235017da18c7f3c361831c60e3173ad304d8ea1e95d64ebebc79da2d708511","src/v32.rs":"145d347855bac59b2de6508f9e594654e6c330423af9edc0e2ac8f4d1abdf45e","src/v512.rs":"f372f277f3e62eb5c945bb1c460333fdb17b6974fcc876633788ff53bded9599","src/v64.rs":"0b8079881b71575e3414be0b7f8f7eaba65281ba6732f2b2f61f73e95b6f48f7","src/vPtr.rs":"8b3e433d487180bb4304ff71245ecad90f0010f43e139a72027b672abe58facc","src/vSize.rs":"eda5aa020706cbf94d15bada41a0c2a35fc8f3f37cb7c2cd6f34d201399a495e","tests/endianness.rs":"7db22078f31fe1421fc2d21f2e6b9df5eb0bdc99c10f6985d3a74c0df8f205dc"},"package":null}
\ No newline at end of file
diff --git a/third_party/rust/packed_simd/.travis.yml b/third_party/rust/packed_simd/.travis.yml
--- a/third_party/rust/packed_simd/.travis.yml
+++ b/third_party/rust/packed_simd/.travis.yml
@@ -1,291 +1,222 @@
 language: rust
-sudo: false
 rust: nightly
+os: linux
+dist: focal
 
 stages:
   - tools
-  - linux-tier1
-  - osx-tier1
-  - osx-tier2
-  - linux-tier2
-  - android
+  - build-test-verify # Passes full test suite, permit no regressions (unless it's rustup :/)
+  - 32bit-tier1
+  - 64bit-tier2
+  - 32bit-tier2
 
-matrix:
-  fast_finish: true    
+jobs:
+  fast_finish: true
   include:
     # Android:
-    - env: TARGET=x86_64-linux-android NOVERIFY=1
+    - env: TARGET=x86_64-linux-android
       name: "x86_64-unknown-linux-android + SSE2"
-      stage: android
+      stage: build-test-verify
     - env: TARGET=arm-linux-androideabi
       name: "arm-linux-androideabi"
-      stage: android
+      stage: build-test-verify
     - env: TARGET=arm-linux-androideabi RUSTFLAGS="-C target-feature=+v7,+neon"
       name: "arm-linux-androideabi + NEON"
-      stage: android
-    - env: TARGET=aarch64-linux-android
-      name: "aarch64-unknown-linux-android"
-      stage: android
-    - env: TARGET=aarch64-linux-android RUSTFLAGS="-C target-feature=+neon"
-      name: "aarch64-unknown-linux-android + NEON"
-      stage: android
+      stage: build-test-verify
+    - name: "aarch64-unknown-linux-android + NEON"
+      env: TARGET=aarch64-linux-android RUSTFLAGS="-C target-feature=+neon"
+      stage: build-test-verify
     - env: TARGET="thumbv7neon-linux-androideabi"
       name: "thumbv7neon-linux-androideabi"
-      stage: android
+      stage: 32bit-tier2
     # Linux:
     - env: TARGET=i586-unknown-linux-gnu
       name: "i586-unknown-linux-gnu"
-      stage: linux-tier2
+      stage: 32bit-tier2
     - env: TARGET=i586-unknown-linux-gnu RUSTFLAGS="-C target-feature=+sse"
       name: "i586-unknown-linux-gnu + SSE"
-      stage: linux-tier2
+      stage: 32bit-tier2
     - env: TARGET=i586-unknown-linux-gnu RUSTFLAGS="-C target-feature=+sse2"
       name: "i586-unknown-linux-gnu + SSE2"
-      stage: linux-tier2
+      stage: 32bit-tier2
     - env: TARGET=i686-unknown-linux-gnu
       name: "i686-unknown-linux-gnu + SSE2"
-      stage: linux-tier1
+      stage: 32bit-tier1
     - env: TARGET=i686-unknown-linux-gnu RUSTFLAGS="-C target-feature=+sse4.2"
       name: "i686-unknown-linux-gnu + SSE4.2"
-      stage: linux-tier1
+      stage: 32bit-tier1
     - env: TARGET=i686-unknown-linux-gnu RUSTFLAGS="-C target-feature=+avx2"
       name: "i686-unknown-linux-gnu + AVX2"
-      stage: linux-tier1
-    - env: TARGET=x86_64-unknown-linux-gnu
-      name: "x86_64-unknown-linux-gnu + SSE2"
-      install: rustup component add rustfmt-preview
-      stage: linux-tier1
+      stage: 32bit-tier1
     - env: TARGET=x86_64-unknown-linux-gnu RUSTFLAGS="-C target-feature=+sse4.2"
       name: "x86_64-unknown-linux-gnu + SSE4.2"
       install: rustup component add rustfmt-preview
-      stage: linux-tier1
-    - env: TARGET=x86_64-unknown-linux-gnu RUSTFLAGS="-C target-feature=+avx"
-      name: "x86_64-unknown-linux-gnu + AVX"
-      install: rustup component add rustfmt-preview
-      stage: linux-tier1
+      stage: build-test-verify
     - env: TARGET=x86_64-unknown-linux-gnu RUSTFLAGS="-C target-feature=+avx2"
       name: "x86_64-unknown-linux-gnu + AVX2"
       install: rustup component add rustfmt-preview
-      stage: linux-tier1
-    - env: TARGET=x86_64-unknown-linux-gnu-emulated
-      name: "Intel SDE + SSE2"
-      install: true
-      stage: linux-tier1
-    - env: TARGET=x86_64-unknown-linux-gnu-emulated RUSTFLAGS="-C target-feature=+sse4.2"
-      name: "Intel SDE + SSE4.2"
-      install: true
-      stage: linux-tier1
-    - env: TARGET=x86_64-unknown-linux-gnu-emulated RUSTFLAGS="-C target-feature=+avx"
-      name: "Intel SDE + AVX"
-      install: true
-      stage: linux-tier1
-    - env: TARGET=x86_64-unknown-linux-gnu-emulated RUSTFLAGS="-C target-feature=+avx2"
-      name: "Intel SDE + AVX2"
-      install: true
-      stage: linux-tier1
-    - env: TARGET=x86_64-unknown-linux-gnu-emulated RUSTFLAGS="-C target-feature=+avx-512f"
-      name: "Intel SDE + AVX-512"
-      install: true
-      stage: linux-tier1
-    - env: TARGET=arm-unknown-linux-gnueabi
-      name: "arm-unknown-linux-gnueabi"
-      stage: linux-tier2
+      stage: build-test-verify
     - env: TARGET=arm-unknown-linux-gnueabi RUSTFLAGS="-C target-feature=+v7,+neon"
       name: "arm-unknown-linux-gnueabi + NEON"
-      stage: linux-tier2
+      stage: build-test-verify
     - env: TARGET=arm-unknown-linux-gnueabihf
       name: "arm-unknown-linux-gnueabihf"
-      stage: linux-tier2
+      stage: build-test-verify
     - env: TARGET=arm-unknown-linux-gnueabihf RUSTFLAGS="-C target-feature=+v7,+neon"
       name: "arm-unknown-linux-gnueabihf + NEON"
-      stage: linux-tier2
+      stage: build-test-verify
     - env: TARGET=armv7-unknown-linux-gnueabihf
       name: "armv7-unknown-linux-gnueabihf"
-      stage: linux-tier2
+      stage: build-test-verify
     - env: TARGET=armv7-unknown-linux-gnueabihf RUSTFLAGS="-C target-feature=+neon"
       name: "armv7-unknown-linux-gnueabihf + NEON"
-      stage: linux-tier2
+      stage: build-test-verify
     - env: TARGET="thumbv7neon-unknown-linux-gnueabihf"
       name: "thumbv7neon-unknown-linux-gnueabihf"
-      stage: linux-tier2
-    - env: TARGET=aarch64-unknown-linux-gnu
-      name: "aarch64-unknown-linux-gnu"
-      stage: linux-tier2
-    - env: TARGET=aarch64-unknown-linux-gnu RUSTFLAGS="-C target-feature=+neon"
-      name: "aarch64-unknown-linux-gnu + NEON"
-      stage: linux-tier2
+      stage: 32bit-tier2
+    - name: "aarch64-unknown-linux-gnu + NEON"
+      env: TARGET=aarch64-unknown-linux-gnu RUSTFLAGS="-C target-feature=+neon"
+      stage: build-test-verify
     - env: TARGET=mips-unknown-linux-gnu
       name: "mips-unknown-linux-gnu"
-      stage: linux-tier2
+      stage: 32bit-tier2
     - env: TARGET=mipsel-unknown-linux-musl
       name: "mipsel-unknown-linux-musl"
-      stage: linux-tier2
+      stage: 32bit-tier2
     - env: TARGET=mips64-unknown-linux-gnuabi64
       name: "mips64-unknown-linux-gnuabi64"
-      stage: linux-tier2
+      stage: 64bit-tier2
     - env: TARGET=mips64el-unknown-linux-gnuabi64
       name: "mips64el-unknown-linux-gnuabi64"
-      stage: linux-tier2
+      stage: 64bit-tier2
       # FIXME: https://github.com/rust-lang-nursery/packed_simd/issues/18
       # env: TARGET=mips64el-unknown-linux-gnuabi64 RUSTFLAGS="-C target-feature=+msa -C target-cpu=mips64r6"
     - env: TARGET=powerpc-unknown-linux-gnu
       name: "powerpc-unknown-linux-gnu"
-      stage: linux-tier2
+      stage: 32bit-tier2
     - env: TARGET=powerpc64-unknown-linux-gnu
       name: "powerpc64-unknown-linux-gnu"
-      stage: linux-tier2
-    - env: TARGET=powerpc64le-unknown-linux-gnu
-      name: "powerpc64le-unknown-linux-gnu"
-      stage: linux-tier2
-    - env: TARGET=powerpc64le-unknown-linux-gnu RUSTFLAGS="-C target-feature=+altivec"
-      name: "powerpc64le-unknown-linux-gnu + ALTIVEC"
-      stage: linux-tier2
-    - env: TARGET=powerpc64le-unknown-linux-gnu RUSTFLAGS="-C target-feature=+vsx"
-      name: "powerpc64le-unknown-linux-gnu + VSX"
-      stage: linux-tier2
-    - env: TARGET=s390x-unknown-linux-gnu
-      name: "s390x-unknown-linux-gnu"
-      stage: linux-tier2
+      stage: 64bit-tier2
+    - name: "powerpc64le-unknown-linux-gnu"
+      env: TARGET=powerpc64le-unknown-linux-gnu
+      stage: build-test-verify
+    - name: "powerpc64le-unknown-linux-gnu + ALTIVEC"
+      env: TARGET=powerpc64le-unknown-linux-gnu RUSTFLAGS="-C target-feature=+altivec"
+      stage: build-test-verify
+    - name: "powerpc64le-unknown-linux-gnu + VSX"
+      env: TARGET=powerpc64le-unknown-linux-gnu RUSTFLAGS="-C target-feature=+vsx"
+      stage: build-test-verify
+    - name: "s390x-unknown-linux-gnu"
+      env: TARGET=s390x-unknown-linux-gnu
+      stage: 64bit-tier2
     - env: TARGET=sparc64-unknown-linux-gnu
       name: "sparc64-unknown-linux-gnu"
-      stage: linux-tier2
+      stage: 64bit-tier2
     # WebAssembly:
     - env: TARGET=wasm32-unknown-unknown
       name: "wasm32-unknown-unknown"
-      stage: osx-tier1 # For now
+      stage: 32bit-tier2
     # MacOSX:
     - os: osx
-      env: TARGET=i686-apple-darwin
-      name: "i686-apple-darwin + SSE2"
-      script: ci/run.sh
-      osx_image: xcode10
-      stage: osx-tier1
-    - os: osx
-      env: TARGET=i686-apple-darwin RUSTFLAGS="-C target-feature=+sse4.2"
-      name: "i686-apple-darwin + SSE4.2"
-      script: ci/run.sh
-      osx_image: xcode10
-      stage: osx-tier1
-      # Travis-CI OSX build bots do not support AVX2:
-    - os: osx
-      env: TARGET=i686-apple-darwin RUSTFLAGS="-C target-feature=+avx"
-      name: "i686-apple-darwin + AVX"
-      script: ci/run.sh
-      osx_image: xcode10
-      stage: osx-tier1
-    - os: osx
-      env: TARGET=x86_64-apple-darwin
-      name: "x86_64-apple-darwin + SSE2"
-      install: true
-      script: ci/run.sh
-      osx_image: xcode10
-      stage: osx-tier1
-    - os: osx
       env: TARGET=x86_64-apple-darwin RUSTFLAGS="-C target-feature=+sse4.2"
       name: "x86_64-apple-darwin + SSE4.2"
       install: true
       script: ci/run.sh
       osx_image: xcode10
-      stage: osx-tier1
+      stage: build-test-verify
       # Travis-CI OSX build bots do not support AVX2:
     - os: osx
       env: TARGET=x86_64-apple-darwin RUSTFLAGS="-C target-feature=+avx"
       name: "x86_64-apple-darwin + AVX"
       install: true
       script: ci/run.sh
       osx_image: xcode10
-      stage: osx-tier1
+      stage: build-test-verify
     # *BSDs:
     #- env: TARGET=i686-unknown-freebsd NORUN=1
     #  script: ci/run.sh
     #- env: TARGET=x86_64-unknown-freebsd NORUN=1
     #  script: ci/run.sh
     #- env: TARGET=x86_64-unknown-netbsd NORUN=1
     #  script: ci/run.sh
     # Solaris:
     #- env: TARGET=x86_64-sun-solaris NORUN=1
     #  script: ci/run.sh
     # iOS:
     - os: osx
-      env: TARGET=i386-apple-ios
-      name: "i386-apple-ios"
-      script: ci/run.sh
-      osx_image: xcode9.4
-      stage: osx-tier2
-    - os: osx
       env: TARGET=x86_64-apple-ios
       name: "x86_64-apple-ios + SSE2"
       script: ci/run.sh
       osx_image: xcode9.4
-      stage: osx-tier2
-    - os: osx
-      env: TARGET=armv7-apple-ios NORUN=1
-      name: "armv7-apple-ios [Build only]"
-      script: ci/run.sh
+      stage: 64bit-tier2
+    - name: "aarch64-apple-ios + NEON"
+      env: TARGET=aarch64-apple-ios RUSTFLAGS="-C target-feature=+neon"
+      os: osx
       osx_image: xcode9.4
-      stage: osx-tier2
-    - os: osx
-      env: TARGET=aarch64-apple-ios NORUN=1
-      name: "aarch64-apple-ios [Build only]"
       script: ci/run.sh
-      osx_image: xcode9.4
-      stage: osx-tier2
+      stage: 64bit-tier2
     # BENCHMARKS:
     - name: "Benchmarks - x86_64-unknown-linux-gnu"
       install: TARGET=x86_64-unknown-linux-gnu ./ci/setup_benchmarks.sh
-      script: PATH=$(pwd):$PATH NORUN=1 VERIFY=1 FEATURES=core_arch,ispc,sleef-sys ci/benchmark.sh
+      # FIXME: Use `core_arch,sleef-sys` features once they works again
+      script: PATH=$(pwd):$PATH NORUN=1 VERIFY=1 FEATURES=ispc ci/benchmark.sh
       stage: tools
     - name: "Benchmarks - x86_64-apple-darwin"
       install: TARGET=x86_64-apple-darwin ./ci/setup_benchmarks.sh
-      script: PATH=$(pwd):$PATH NORUN=1 VERIFY=1 FEATURES=core_arch,ispc,sleef-sys ci/benchmark.sh
+      # FIXME: Use `core_arch,sleef-sys` features once they works again
+      script: PATH=$(pwd):$PATH NORUN=1 VERIFY=1 FEATURES=ispc ci/benchmark.sh
       os: osx
       osx_image: xcode9.4
       stage: tools
     # TOOLS:
     - name: "Documentation"
-      install: cargo install mdbook
+      before_install:
+        - sudo add-apt-repository -y ppa:deadsnakes/ppa
+        - sudo apt-get update -y
+        - sudo apt-get install -y python3.9
+      install:
+        - cargo install mdbook
       script: ci/dox.sh
       stage: tools
     - name: "rustfmt"
       install: true
-      before_script: rustup component add rustfmt-preview
-      script: ci/all.sh check_fmt || true
+      script: |
+        if rustup component add rustfmt-preview ; then
+            ci/all.sh check_fmt || true
+        fi
       stage: tools
     - name: "clippy"
       install: true
-      before_script: rustup component add clippy-preview
-      script: ci/all.sh clippy
+      script: |
+        if rustup component add clippy-preview ; then
+            ci/all.sh clippy
+        fi
       stage: tools
 
   allow_failures:
     # FIXME: ISPC cannot be found?
     - name: "Benchmarks - x86_64-apple-darwin"
-    # FIXME: TBD
-    - env: TARGET=powerpc-unknown-linux-gnu
-    - env: TARGET=powerpc64-unknown-linux-gnu
-    - env: TARGET=powerpc64le-unknown-linux-gnu
-    - env: TARGET=powerpc64le-unknown-linux-gnu RUSTFLAGS="-C target-feature=+altivec"
-    - env: TARGET=powerpc64le-unknown-linux-gnu RUSTFLAGS="-C target-feature=+vsx"
+    # FIXME: i686 fails in inlining, apparently
+    - stage: 32bit-tier1
     #- env: TARGET=i686-unknown-freebsd NORUN=1
     #- env: TARGET=x86_64-unknown-freebsd NORUN=1
     #- env: TARGET=x86_64-unknown-netbsd NORUN=1
     #- env: TARGET=x86_64-sun-solaris NORUN=1
 
     # FIXME: TBD
-    - env: TARGET=arm-linux-androideabi
-    - env: TARGET=arm-linux-androideabi RUSTFLAGS="-C target-feature=+v7,+neon"
-    - env: TARGET=aarch64-linux-android
-    - env: TARGET=aarch64-linux-android RUSTFLAGS="-C target-feature=+neon"
+    - stage: 64bit-tier2
+    - stage: 32bit-tier2
 
     # FIXME: iOS
     # https://github.com/rust-lang-nursery/packed_simd/issues/26
-    - env: TARGET=i386-apple-ios
     - env: TARGET=x86_64-apple-ios
+    # Is this related to the above? Mysterious test failure
+    - name: "aarch64-apple-ios + NEON"
 
     # FIXME: https://github.com/rust-lang-nursery/packed_simd/issues/182
     - env: TARGET=arm-unknown-linux-gnueabi RUSTFLAGS="-C target-feature=+v7,+neon"
     - env: TARGET=arm-unknown-linux-gnueabihf RUSTFLAGS="-C target-feature=+v7,+neon"
     - env: TARGET=armv7-unknown-linux-gnueabihf RUSTFLAGS="-C target-feature=+neon"
 
     # FIXME: https://github.com/rust-lang-nursery/packed_simd/issues/183
     - env: TARGET=wasm32-unknown-unknown
diff --git a/third_party/rust/packed_simd/Cargo.toml b/third_party/rust/packed_simd/Cargo.toml
--- a/third_party/rust/packed_simd/Cargo.toml
+++ b/third_party/rust/packed_simd/Cargo.toml
@@ -1,11 +1,11 @@
 [package]
 name = "packed_simd"
-version = "0.3.3"
+version = "0.3.4"
 authors = ["Gonzalo Brito Gadeschi <gonzalobg88@gmail.com>"]
 description = "Portable Packed SIMD vectors"
 documentation = "https://docs.rs/crate/packed_simd/"
 homepage = "https://github.com/rust-lang-nursery/packed_simd"
 repository = "https://github.com/rust-lang-nursery/packed_simd"
 keywords = ["simd", "vector", "portability"]
 categories = ["hardware-support", "concurrency", "no-std", "data-structures"]
 license = "MIT/Apache-2.0"
@@ -16,27 +16,27 @@ edition = "2018"
 appveyor = { repository = "rust-lang-nursery/packed_simd" }
 travis-ci = { repository = "rust-lang-nursery/packed_simd" }
 codecov = { repository = "rust-lang-nursery/packed_simd" }
 is-it-maintained-issue-resolution = { repository = "rust-lang-nursery/packed_simd" }
 is-it-maintained-open-issues = { repository = "rust-lang-nursery/packed_simd" }
 maintenance = { status = "experimental" }
 
 [dependencies]
-cfg-if = "^0.1.6"
-core_arch = { version = "^0.1.3", optional = true }
+cfg-if = "0.1.10"
+core_arch = { version = "0.1.5", optional = true }
 
 [features]
 default = []
 into_bits = []
 libcore_neon = []
 
 [dev-dependencies]
 paste = "^0.1.3"
-arrayvec = { version = "^0.4", default-features = false }
+arrayvec = { version = "^0.5", default-features = false }
 
 [target.'cfg(target_arch = "x86_64")'.dependencies.sleef-sys]
-version = "^0.1.2"
+version = "0.1.2"
 optional = true
 
 [target.wasm32-unknown-unknown.dev-dependencies]
-wasm-bindgen = "=0.2.19"
-wasm-bindgen-test = "=0.2.19"
\ No newline at end of file
+wasm-bindgen = "=0.2.52"
+wasm-bindgen-test = "=0.3.2"
diff --git a/third_party/rust/packed_simd/readme.md b/third_party/rust/packed_simd/README.md
rename from third_party/rust/packed_simd/readme.md
rename to third_party/rust/packed_simd/README.md
--- a/third_party/rust/packed_simd/readme.md
+++ b/third_party/rust/packed_simd/README.md
@@ -1,24 +1,22 @@
 # `Simd<[T; N]>`
 
 ## Implementation of [Rust RFC #2366: `std::simd`][rfc2366]
 
 [![Travis-CI Status]][travis] [![Appveyor Status]][appveyor] [![Latest Version]][crates.io] [![docs]][master_docs]
 
-> This aims to be a 100% conforming implementation of Rust RFC 2366 for stabilization.
-
-**WARNING**: this crate only supports the most recent nightly Rust toolchain.
+**WARNING**: this crate only supports the most recent nightly Rust toolchain
+and will be superceded by [stdsimd](https://github.com/rust-lang/stdsimd).
 
 ## Documentation
 
 * [API docs (`master` branch)][master_docs]
 * [Performance guide][perf_guide]
-* [API docs (`docs.rs`)][docs.rs]: **CURRENTLY DOWN** due to
-  https://github.com/rust-lang-nursery/packed_simd/issues/110
+* [API docs (`docs.rs`)][docs.rs]
 * [RFC2366 `std::simd`][rfc2366]: - contains motivation, design rationale,
   discussion, etc.
 
 ## Examples
 
 Most of the examples come with both a scalar and a vectorized implementation.
 
 * [`aobench`](https://github.com/rust-lang-nursery/packed_simd/tree/master/examples/aobench)
@@ -34,27 +32,16 @@ Most of the examples come with both a sc
 
 ## Cargo features
 
 * `into_bits` (default: disabled): enables `FromBits`/`IntoBits` trait
   implementations for the vector types. These allow reinterpreting the bits of a
   vector type as those of another vector type safely by just using the
   `.into_bits()` method.
 
-* `core_arch` (default: disabled): enable this feature to recompile `core::arch`
-  for the target-features enabled. `packed_simd` includes optimizations for some
-  target feature combinations that are enabled by this feature. Note, however,
-  that this is an unstable dependency, that rustc might break at any time.
-
-* `sleef-sys` (default: disabled - `x86_64` only): internally uses the [SLEEF]
-  short-vector math library when profitable via the [`sleef-sys`][sleef_sys]
-  crate. [SLEEF] is licensed under the [Boost Software License
-  v1.0][boost_license], an extremely permissive license, and can be statically
-  linked without issues.
-
 ## Performance
 
 The following [ISPC] examples are also part of `packed_simd`'s
 [`examples/`](https://github.com/rust-lang-nursery/packed_simd/tree/master/examples/)
 directory, where `packed_simd`+[`rayon`][rayon] are used to emulate [ISPC]'s
 Single-Program-Multiple-Data (SPMD) programming model. The performance results
 on different hardware is shown in the `readme.md` of each example. The following
 table summarizes the performance ranges, where `+` means speed-up and `-`
@@ -70,70 +57,50 @@ slowdown:
  While SPMD is not the intended use case for `packed_simd`, it is possible to
  combine the library with [`rayon`][rayon] to poorly emulate [ISPC]'s SPMD programming
  model in Rust. Writing performant code is not as straightforward as with
  [ISPC], but with some care (e.g. see the [Performance Guide][perf_guide]) one
  can easily match and often out-perform [ISPC]'s "default performance".
 
 ## Platform support
 
-The following table describes the supported platforms: `build` shows whether the
-library compiles without issues for a given target, while `run` shows whether
-the full testsuite passes on the target.
+The following table describes the supported platforms: `build` shows whether
+the library compiles without issues for a given target, while `run` shows
+whether the test suite passes for a given target.
 
-| Linux targets:                    | build     | run     |
-|-----------------------------------|-----------|---------|
-| `i586-unknown-linux-gnu`          |          |        |
-| `i686-unknown-linux-gnu`          |          |        |
-| `x86_64-unknown-linux-gnu`        |          |        |
-| `arm-unknown-linux-gnueabi`       |          |        |
-| `arm-unknown-linux-gnueabihf`     |          |        |
-| `armv7-unknown-linux-gnueabi`     |          |        |
-| `aarch64-unknown-linux-gnu`       |          |        |
-| `mips-unknown-linux-gnu`          |          |        |
-| `mipsel-unknown-linux-musl`       |          |        |
-| `mips64-unknown-linux-gnuabi64`   |          |        |
-| `mips64el-unknown-linux-gnuabi64` |          |        |
-| `powerpc-unknown-linux-gnu`       |          |        |
-| `powerpc64-unknown-linux-gnu`     |          |        |
-| `powerpc64le-unknown-linux-gnu`   |          |        |
-| `s390x-unknown-linux-gnu`         |          | *      |
-| `sparc64-unknown-linux-gnu`       |          | *      |
-| `thumbv7neon-unknown-linux-gnueabihf` |          |       |
-| **MacOSX targets:**               | **build** | **run** |
-| `x86_64-apple-darwin`             |          |        |
-| `i686-apple-darwin`               |          |        |
-| **Windows targets:**              | **build** | **run** |
-| `x86_64-pc-windows-msvc`          |          |        |
-| `i686-pc-windows-msvc`            |          |        |
-| `x86_64-pc-windows-gnu`           |           |         |
-| `i686-pc-windows-gnu`             |           |         |
-| **WebAssembly targets:**          | **build** | **run** |
-| `wasm32-unknown-unknown`          |          |       |
-| **Android targets:**              | **build** | **run** |
-| `x86_64-linux-android`            |          |        |
-| `arm-linux-androideabi`           |          |        |
-| `aarch64-linux-android`           |          |        |
-| `thumbv7neon-linux-androideabi`  |          |        |
-| **iOS targets:**                  | **build** | **run** |
-| `i386-apple-ios`                  |          |        |
-| `x86_64-apple-ios`                |          |        |
-| `armv7-apple-ios`                 |          | **     |
-| `aarch64-apple-ios`               |          | **     |
-| **xBSD targets:**                 | **build** | **run** |
-| `i686-unknown-freebsd`            |          | **     |
-| `x86_64-unknown-freebsd`          |          | **     |
-| `x86_64-unknown-netbsd`           |          | **     |
-| **Solaris targets:**              | **build** | **run** |
-| `x86_64-sun-solaris`              |          | **     |
+| **Linux**                             | **build** | **run** |
+|---------------------------------------|-----------|---------|
+| `i586-unknown-linux-gnu`              |          |        |
+| `i686-unknown-linux-gnu`              |          |        |
+| `x86_64-unknown-linux-gnu`            |          |        |
+| `arm-unknown-linux-gnueabi`           |          |        |
+| `arm-unknown-linux-gnueabihf`         |          |        |
+| `armv7-unknown-linux-gnueabi`         |          |        |
+| `aarch64-unknown-linux-gnu`           |          |        |
+| `mips-unknown-linux-gnu`              |          |        |
+| `mipsel-unknown-linux-musl`           |          |        |
+| `mips64-unknown-linux-gnuabi64`       |          |        |
+| `mips64el-unknown-linux-gnuabi64`     |          |        |
+| `powerpc-unknown-linux-gnu`           |          |        |
+| `powerpc64-unknown-linux-gnu`         |          |        |
+| `powerpc64le-unknown-linux-gnu`       |          |        |
+| `s390x-unknown-linux-gnu`             |          |        |
+| `sparc64-unknown-linux-gnu`           |          |        |
+| `thumbv7neon-unknown-linux-gnueabihf` |          |        |
+| **MacOSX**                            | **build** | **run** |
+| `x86_64-apple-darwin`                 |          |        |
+| **Android**                           | **build** | **run** |
+| `x86_64-linux-android`                |          |        |
+| `arm-linux-androideabi`               |          |        |
+| `aarch64-linux-android`               |          |        |
+| `thumbv7neon-linux-androideabi`       |          |        |
+| **iOS**                               | **build** | **run** |
+| `x86_64-apple-ios`                    |          |        |
+| `aarch64-apple-ios`                   |          |        |
 
-[*] most of the test suite passes correctly on these platform but
-there are correctness bugs open in the issue tracker.
-
-[**] it is currently not easily possible to run these platforms on CI.
 
 ## Machine code verification
 
 The
 [`verify/`](https://github.com/rust-lang-nursery/packed_simd/tree/master/verify)
 crate tests disassembles the portable packed vector APIs at run-time and
 compares the generated machine code against the desired one to make sure that
 this crate remains efficient.
@@ -157,18 +124,18 @@ Please see the [contributing instruction
 
 Contributions in any form (issues, pull requests, etc.) to this project
 must adhere to Rust's [Code of Conduct].
 
 Unless you explicitly state otherwise, any contribution intentionally submitted
 for inclusion in `packed_simd` by you, as defined in the Apache-2.0 license, shall be
 dual licensed as above, without any additional terms or conditions.
 
-[travis]: https://travis-ci.org/rust-lang-nursery/packed_simd
-[Travis-CI Status]: https://travis-ci.org/rust-lang-nursery/packed_simd.svg?branch=master
+[travis]: https://travis-ci.com/rust-lang-nursery/packed_simd
+[Travis-CI Status]: https://travis-ci.com/rust-lang-nursery/packed_simd.svg?branch=master
 [appveyor]: https://ci.appveyor.com/project/gnzlbg/packed-simd
 [Appveyor Status]: https://ci.appveyor.com/api/projects/status/hd7v9dvr442hgdix?svg=true
 [Latest Version]: https://img.shields.io/crates/v/packed_simd.svg
 [crates.io]: https://crates.io/crates/packed_simd
 [docs]: https://docs.rs/packed_simd/badge.svg
 [docs.rs]: https://docs.rs/packed_simd/
 [master_docs]: https://rust-lang-nursery.github.io/packed_simd/packed_simd/
 [perf_guide]: https://rust-lang-nursery.github.io/packed_simd/perf-guide/
diff --git a/third_party/rust/packed_simd/build.rs b/third_party/rust/packed_simd/build.rs
--- a/third_party/rust/packed_simd/build.rs
+++ b/third_party/rust/packed_simd/build.rs
@@ -1,8 +1,8 @@
 fn main() {
-	println!("cargo:rustc-env=RUSTC_BOOTSTRAP=1");
+    println!("cargo:rustc-env=RUSTC_BOOTSTRAP=1");
     let target = std::env::var("TARGET")
         .expect("TARGET environment variable not defined");
     if target.contains("neon") {
         println!("cargo:rustc-cfg=libcore_neon");
     }
 }
diff --git a/third_party/rust/packed_simd/ci/all.sh b/third_party/rust/packed_simd/ci/all.sh
--- a/third_party/rust/packed_simd/ci/all.sh
+++ b/third_party/rust/packed_simd/ci/all.sh
@@ -16,17 +16,17 @@ cargo_check_fmt() {
     cargo fmt --all -- --check
 }
 
 cargo_fmt() {
     cargo fmt --all
 }
 
 cargo_clippy() {
-    cargo clippy --all -- -D clippy::pedantic
+    cargo clippy --all -- -D clippy::perf
 }
 
 CMD="-1"
 
 case $op in
     clean*)
         CMD=cargo_clean
         ;;
diff --git a/third_party/rust/packed_simd/ci/docker/aarch64-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd/ci/docker/aarch64-unknown-linux-gnu/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/aarch64-unknown-linux-gnu/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/aarch64-unknown-linux-gnu/Dockerfile
@@ -1,9 +1,9 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 RUN apt-get update && apt-get install -y --no-install-recommends \
   gcc \
   ca-certificates \
   libc6-dev \
   gcc-aarch64-linux-gnu \
   libc6-dev-arm64-cross \
   qemu-user \
   make \
diff --git a/third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabi/Dockerfile b/third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabi/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabi/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabi/Dockerfile
@@ -1,9 +1,9 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 RUN apt-get update && apt-get install -y --no-install-recommends \
   gcc \
   ca-certificates \
   libc6-dev \
   libc6-armel-cross \
   libc6-dev-armel-cross \
   binutils-arm-linux-gnueabi \
   gcc-arm-linux-gnueabi \
diff --git a/third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile b/third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile
@@ -1,9 +1,9 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 RUN apt-get update && apt-get install -y --no-install-recommends \
   gcc \
   ca-certificates \
   libc6-dev \
   gcc-arm-linux-gnueabihf \
   libc6-dev-armhf-cross \
   qemu-user \
   make \
diff --git a/third_party/rust/packed_simd/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile b/third_party/rust/packed_simd/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile
@@ -1,9 +1,9 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 RUN apt-get update && apt-get install -y --no-install-recommends \
   gcc \
   ca-certificates \
   libc6-dev \
   gcc-arm-linux-gnueabihf \
   libc6-dev-armhf-cross \
   qemu-user \
   make \
diff --git a/third_party/rust/packed_simd/ci/docker/i586-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd/ci/docker/i586-unknown-linux-gnu/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/i586-unknown-linux-gnu/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/i586-unknown-linux-gnu/Dockerfile
@@ -1,7 +1,7 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 RUN apt-get update && apt-get install -y --no-install-recommends \
   gcc-multilib \
   libc6-dev \
   file \
   make \
   ca-certificates
diff --git a/third_party/rust/packed_simd/ci/docker/i686-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd/ci/docker/i686-unknown-linux-gnu/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/i686-unknown-linux-gnu/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/i686-unknown-linux-gnu/Dockerfile
@@ -1,7 +1,7 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 RUN apt-get update && apt-get install -y --no-install-recommends \
   gcc-multilib \
   libc6-dev \
   file \
   make \
   ca-certificates
diff --git a/third_party/rust/packed_simd/ci/docker/mips-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd/ci/docker/mips-unknown-linux-gnu/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/mips-unknown-linux-gnu/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/mips-unknown-linux-gnu/Dockerfile
@@ -1,9 +1,9 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 
 RUN apt-get update && apt-get install -y --no-install-recommends \
         gcc libc6-dev qemu-user ca-certificates \
         gcc-mips-linux-gnu libc6-dev-mips-cross \
         qemu-system-mips \
         qemu-user \
         make \
         file
diff --git a/third_party/rust/packed_simd/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile b/third_party/rust/packed_simd/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile
@@ -1,9 +1,9 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 
 RUN apt-get update && apt-get install -y --no-install-recommends \
         gcc libc6-dev qemu-user ca-certificates \
         gcc-mips64-linux-gnuabi64 libc6-dev-mips64-cross \
         qemu-system-mips64 qemu-user
 
 ENV CARGO_TARGET_MIPS64_UNKNOWN_LINUX_GNUABI64_LINKER=mips64-linux-gnuabi64-gcc \
     CARGO_TARGET_MIPS64_UNKNOWN_LINUX_GNUABI64_RUNNER="qemu-mips64 -L /usr/mips64-linux-gnuabi64" \
diff --git a/third_party/rust/packed_simd/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile b/third_party/rust/packed_simd/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile
@@ -1,9 +1,9 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 
 RUN apt-get update && apt-get install -y --no-install-recommends \
         gcc libc6-dev qemu-user ca-certificates \
         gcc-mips64el-linux-gnuabi64 libc6-dev-mips64el-cross \
         qemu-system-mips64el
 
 ENV CARGO_TARGET_MIPS64EL_UNKNOWN_LINUX_GNUABI64_LINKER=mips64el-linux-gnuabi64-gcc \
     CARGO_TARGET_MIPS64EL_UNKNOWN_LINUX_GNUABI64_RUNNER="qemu-mips64el -L /usr/mips64el-linux-gnuabi64" \
diff --git a/third_party/rust/packed_simd/ci/docker/mipsel-unknown-linux-musl/Dockerfile b/third_party/rust/packed_simd/ci/docker/mipsel-unknown-linux-musl/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/mipsel-unknown-linux-musl/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/mipsel-unknown-linux-musl/Dockerfile
@@ -11,15 +11,15 @@ RUN apt-get update && \
     bzip2 \
     curl \
     file
 
 RUN mkdir /toolchain
 
 # Note that this originally came from:
 # https://downloads.openwrt.org/snapshots/trunk/malta/generic/OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2
-RUN curl -L https://s3-us-west-1.amazonaws.com/rust-lang-ci2/libc/OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2 | \
+RUN curl -L https://ci-mirrors.rust-lang.org/libc/OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2 | \
       tar xjf - -C /toolchain --strip-components=2
 
 ENV PATH=$PATH:/rust/bin:/toolchain/bin \
     CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \
     CARGO_TARGET_MIPSEL_UNKNOWN_LINUX_MUSL_LINKER=mipsel-openwrt-linux-gcc \
-    CARGO_TARGET_MIPSEL_UNKNOWN_LINUX_MUSL_RUNNER="qemu-mipsel -L /toolchain"
\ No newline at end of file
+    CARGO_TARGET_MIPSEL_UNKNOWN_LINUX_MUSL_RUNNER="qemu-mipsel -L /toolchain"
diff --git a/third_party/rust/packed_simd/ci/docker/powerpc-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd/ci/docker/powerpc-unknown-linux-gnu/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/powerpc-unknown-linux-gnu/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/powerpc-unknown-linux-gnu/Dockerfile
@@ -1,12 +1,13 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 
 RUN apt-get update && apt-get install -y --no-install-recommends \
         gcc libc6-dev qemu-user ca-certificates \
         gcc-powerpc-linux-gnu libc6-dev-powerpc-cross \
         qemu-system-ppc \
         make \
         file
 
 ENV CARGO_TARGET_POWERPC_UNKNOWN_LINUX_GNU_LINKER=powerpc-linux-gnu-gcc \
     CARGO_TARGET_POWERPC_UNKNOWN_LINUX_GNU_RUNNER="qemu-ppc -cpu Vger -L /usr/powerpc-linux-gnu" \
+    CC=powerpc-linux-gnu-gcc \
     OBJDUMP=powerpc-linux-gnu-objdump
diff --git a/third_party/rust/packed_simd/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile
@@ -1,9 +1,9 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 
 RUN apt-get update && apt-get install -y --no-install-recommends \
     gcc \
     ca-certificates \
     libc6-dev \
     gcc-powerpc64-linux-gnu \
     libc6-dev-ppc64-cross \
     qemu-user  \
diff --git a/third_party/rust/packed_simd/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile
@@ -1,9 +1,9 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 
 RUN apt-get update && apt-get install -y --no-install-recommends \
         gcc libc6-dev qemu-user ca-certificates \
         gcc-powerpc64le-linux-gnu libc6-dev-ppc64el-cross \
         qemu-system-ppc file make
 
 ENV CARGO_TARGET_POWERPC64LE_UNKNOWN_LINUX_GNU_LINKER=powerpc64le-linux-gnu-gcc \
     CARGO_TARGET_POWERPC64LE_UNKNOWN_LINUX_GNU_RUNNER="qemu-ppc64le -L /usr/powerpc64le-linux-gnu" \
diff --git a/third_party/rust/packed_simd/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile b/third_party/rust/packed_simd/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile
@@ -1,9 +1,9 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 RUN apt-get update && apt-get install -y --no-install-recommends \
   gcc \
   ca-certificates \
   libc6-dev \
   gcc-arm-linux-gnueabihf \
   libc6-dev-armhf-cross \
   qemu-user \
   make \
diff --git a/third_party/rust/packed_simd/ci/docker/x86_64-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd/ci/docker/x86_64-unknown-linux-gnu/Dockerfile
--- a/third_party/rust/packed_simd/ci/docker/x86_64-unknown-linux-gnu/Dockerfile
+++ b/third_party/rust/packed_simd/ci/docker/x86_64-unknown-linux-gnu/Dockerfile
@@ -1,9 +1,9 @@
-FROM ubuntu:17.10
+FROM ubuntu:18.04
 RUN apt-get update && apt-get install -y --no-install-recommends \
   gcc \
   libc6-dev \
   file \
   make \
   ca-certificates \
   cmake \
   libclang-dev \
diff --git a/third_party/rust/packed_simd/ci/dox.sh b/third_party/rust/packed_simd/ci/dox.sh
--- a/third_party/rust/packed_simd/ci/dox.sh
+++ b/third_party/rust/packed_simd/ci/dox.sh
@@ -13,12 +13,15 @@ cargo doc --features=into_bits
 # mdbook build perf-guide -d target/doc/perf-guide
 cd perf-guide
 mdbook build
 cd -
 cp -r perf-guide/book target/doc/perf-guide
 
 # If we're on travis, not a PR, and on the right branch, publish!
 if [ "$TRAVIS_PULL_REQUEST" = "false" ] && [ "$TRAVIS_BRANCH" = "master" ]; then
-  pip install ghp_import --install-option="--prefix=$HOME/.local"
-  $HOME/.local/bin/ghp-import -n target/doc
+  python3 -vV
+  pip -vV
+  python3.9 -vV
+  pip install ghp_import --user
+  ghp-import -n target/doc
   git push -qf https://${GH_PAGES}@github.com/${TRAVIS_REPO_SLUG}.git gh-pages
 fi
diff --git a/third_party/rust/packed_simd/ci/run.sh b/third_party/rust/packed_simd/ci/run.sh
--- a/third_party/rust/packed_simd/ci/run.sh
+++ b/third_party/rust/packed_simd/ci/run.sh
@@ -73,19 +73,21 @@ cargo_test_impl() {
 # Debug run:
 if [[ "${TARGET}" != "wasm32-unknown-unknown" ]]; then
    # Run wasm32-unknown-unknown in release mode only
    cargo_test_impl
 fi
 
 if [[ "${TARGET}" == "x86_64-unknown-linux-gnu" ]] || [[ "${TARGET}" == "x86_64-pc-windows-msvc" ]]; then
     # use sleef on linux and windows x86_64 builds
-    cargo_test_impl --release --features=into_bits,core_arch,sleef-sys
+    # FIXME: Use `core_arch,sleef-sys` features once they works again
+    cargo_test_impl --release --features=into_bits
 else
-    cargo_test_impl --release --features=into_bits,core_arch
+    # FIXME: Use `core_arch` feature once it works again
+    cargo_test_impl --release --features=into_bits
 fi
 
 # Verify code generation
 if [[ "${NOVERIFY}" != "1" ]]; then
     cp -r verify/verify target/verify
     export STDSIMD_ASSERT_INSTR_LIMIT=30
     if [[ "${TARGET}" == "i586-unknown-linux-gnu" ]]; then
         export STDSIMD_ASSERT_INSTR_LIMIT=50
diff --git a/third_party/rust/packed_simd/ci/setup_benchmarks.sh b/third_party/rust/packed_simd/ci/setup_benchmarks.sh
--- a/third_party/rust/packed_simd/ci/setup_benchmarks.sh
+++ b/third_party/rust/packed_simd/ci/setup_benchmarks.sh
@@ -1,10 +1,7 @@
 #!/usr/bin/env bash
 
 set -ex
 
 # Get latest ISPC binary for the target and put it in the path
 git clone https://github.com/gnzlbg/ispc-binaries
 cp ispc-binaries/ispc-${TARGET} ispc
-
-# Rust-bindgen requires RUSTFMT
-rustup component add rustfmt-preview
diff --git a/third_party/rust/packed_simd/src/api.rs b/third_party/rust/packed_simd/src/api.rs
--- a/third_party/rust/packed_simd/src/api.rs
+++ b/third_party/rust/packed_simd/src/api.rs
@@ -1,10 +1,12 @@
 //! Implements the Simd<[T; N]> APIs
 
+#[macro_use]
+mod bitmask;
 crate mod cast;
 #[macro_use]
 mod cmp;
 #[macro_use]
 mod default;
 #[macro_use]
 mod fmt;
 #[macro_use]
@@ -34,17 +36,17 @@ mod swap_bytes;
 #[macro_use]
 mod bit_manip;
 
 #[cfg(feature = "into_bits")]
 crate mod into_bits;
 
 macro_rules! impl_i {
     ([$elem_ty:ident; $elem_n:expr]: $tuple_id:ident, $mask_ty:ident
-     | $ielem_ty:ident | $test_tt:tt | $($elem_ids:ident),*
+     | $ielem_ty:ident, $ibitmask_ty:ident | $test_tt:tt | $($elem_ids:ident),*
      | From: $($from_vec_ty:ident),* | $(#[$doc:meta])*) => {
         impl_minimal_iuf!([$elem_ty; $elem_n]: $tuple_id | $ielem_ty | $test_tt
                           | $($elem_ids),* | $(#[$doc])*);
         impl_ops_vector_arithmetic!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
         impl_ops_scalar_arithmetic!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
         impl_ops_vector_bitwise!(
             [$elem_ty; $elem_n]: $tuple_id | $test_tt | (!(0 as $elem_ty), 0)
         );
@@ -88,26 +90,27 @@ macro_rules! impl_i {
             [$elem_ty; $elem_n]: $tuple_id | $test_tt | (0, 1)
         );
         impl_cmp_eq!([$elem_ty; $elem_n]: $tuple_id | $test_tt | (0, 1));
         impl_cmp_vertical!(
             [$elem_ty; $elem_n]: $tuple_id, $mask_ty, false, (1, 0) | $test_tt
         );
         impl_cmp_partial_ord!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
         impl_cmp_ord!([$elem_ty; $elem_n]: $tuple_id | $test_tt | (0, 1));
+        impl_bitmask!($tuple_id | $ibitmask_ty | (-1, 0) | $test_tt);
 
         test_select!($elem_ty, $mask_ty, $tuple_id, (1, 2) | $test_tt);
         test_cmp_partial_ord_int!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
         test_shuffle1_dyn!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
     }
 }
 
 macro_rules! impl_u {
     ([$elem_ty:ident; $elem_n:expr]: $tuple_id:ident, $mask_ty:ident
-     | $ielem_ty:ident | $test_tt:tt | $($elem_ids:ident),*
+     | $ielem_ty:ident, $ibitmask_ty:ident | $test_tt:tt | $($elem_ids:ident),*
      | From: $($from_vec_ty:ident),* | $(#[$doc:meta])*) => {
         impl_minimal_iuf!([$elem_ty; $elem_n]: $tuple_id | $ielem_ty | $test_tt
                           | $($elem_ids),* | $(#[$doc])*);
         impl_ops_vector_arithmetic!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
         impl_ops_scalar_arithmetic!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
         impl_ops_vector_bitwise!(
             [$elem_ty; $elem_n]: $tuple_id | $test_tt | (!(0 as $elem_ty), 0)
         );
@@ -150,16 +153,18 @@ macro_rules! impl_u {
             [$elem_ty; $elem_n]: $tuple_id | $test_tt | (1, 0)
         );
         impl_cmp_eq!([$elem_ty; $elem_n]: $tuple_id | $test_tt | (0, 1));
         impl_cmp_vertical!(
             [$elem_ty; $elem_n]: $tuple_id, $mask_ty, false, (1, 0) | $test_tt
         );
         impl_cmp_partial_ord!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
         impl_cmp_ord!([$elem_ty; $elem_n]: $tuple_id | $test_tt | (0, 1));
+        impl_bitmask!($tuple_id | $ibitmask_ty | ($ielem_ty::max_value(), 0) |
+                      $test_tt);
 
         test_select!($elem_ty, $mask_ty, $tuple_id, (1, 2) | $test_tt);
         test_cmp_partial_ord_int!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
         test_shuffle1_dyn!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
     }
 }
 
 macro_rules! impl_f {
@@ -217,17 +222,18 @@ macro_rules! impl_f {
         test_reduction_float_min_max!(
             [$elem_ty; $elem_n]: $tuple_id | $test_tt
         );
         test_shuffle1_dyn!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
     }
 }
 
 macro_rules! impl_m {
-    ([$elem_ty:ident; $elem_n:expr]: $tuple_id:ident | $ielem_ty:ident
+    ([$elem_ty:ident; $elem_n:expr]: $tuple_id:ident
+     | $ielem_ty:ident, $ibitmask_ty:ident
      | $test_tt:tt | $($elem_ids:ident),* | From: $($from_vec_ty:ident),*
      | $(#[$doc:meta])*) => {
         impl_minimal_mask!(
             [$elem_ty; $elem_n]: $tuple_id | $ielem_ty | $test_tt
             | $($elem_ids),* | $(#[$doc])*
         );
         impl_ops_vector_mask_bitwise!(
             [$elem_ty; $elem_n]: $tuple_id | $test_tt | (true, false)
@@ -260,16 +266,17 @@ macro_rules! impl_m {
             | $test_tt
         );
         impl_select!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
         impl_cmp_partial_ord!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
         impl_cmp_ord!(
             [$elem_ty; $elem_n]: $tuple_id | $test_tt | (false, true)
         );
         impl_shuffle1_dyn!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
+        impl_bitmask!($tuple_id | $ibitmask_ty | (true, false) | $test_tt);
 
         test_cmp_partial_ord_mask!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
         test_shuffle1_dyn_mask!([$elem_ty; $elem_n]: $tuple_id | $test_tt);
     }
 }
 
 macro_rules! impl_const_p {
     ([$elem_ty:ty; $elem_n:expr]: $tuple_id:ident, $mask_ty:ident,
diff --git a/third_party/rust/packed_simd/src/api/bit_manip.rs b/third_party/rust/packed_simd/src/api/bit_manip.rs
--- a/third_party/rust/packed_simd/src/api/bit_manip.rs
+++ b/third_party/rust/packed_simd/src/api/bit_manip.rs
@@ -32,16 +32,17 @@ macro_rules! impl_bit_manip {
             }
         }
 
         test_if! {
             $test_tt:
             paste::item_with_macros! {
                 #[allow(overflowing_literals)]
                 pub mod [<$id _bit_manip>] {
+                    #![allow(const_item_mutation)]
                     use super::*;
 
                     const LANE_WIDTH: usize = mem::size_of::<$elem_ty>() * 8;
 
                     macro_rules! test_func {
                         ($x:expr, $func:ident) => {{
                             let mut actual = $x;
                             for i in 0..$id::lanes() {
diff --git a/third_party/rust/packed_simd/src/api/bitmask.rs b/third_party/rust/packed_simd/src/api/bitmask.rs
new file mode 100644
--- /dev/null
+++ b/third_party/rust/packed_simd/src/api/bitmask.rs
@@ -0,0 +1,82 @@
+//! Bitmask API
+
+macro_rules! impl_bitmask {
+    ($id:ident | $ibitmask_ty:ident | ($set:expr, $clear:expr)
+     | $test_tt:tt) => {
+        impl $id {
+            /// Creates a bitmask with the MSB of each vector lane.
+            ///
+            /// If the vector has less than 8 lanes, the bits that do not
+            /// correspond to any vector lanes are cleared.
+            #[inline]
+            pub fn bitmask(self) -> $ibitmask_ty {
+                unsafe { codegen::llvm::simd_bitmask(self.0) }
+            }
+        }
+
+        test_if! {
+            $test_tt:
+            paste::item! {
+                #[cfg(not(any(
+                    // FIXME: https://github.com/rust-lang-nursery/packed_simd/issues/210
+                    all(target_arch = "mips", target_endian = "big"),
+                    all(target_arch = "mips64", target_endian = "big"),
+                    target_arch = "sparc64",
+                    target_arch = "s390x",
+                )))]
+                pub mod [<$id _bitmask>] {
+                    use super::*;
+                    #[cfg_attr(not(target_arch = "wasm32"), test)]
+                    #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
+                    fn bitmask() {
+                        // clear all lanes
+                        let vec = $id::splat($clear as _);
+                        let bitmask: $ibitmask_ty = 0;
+                        assert_eq!(vec.bitmask(), bitmask);
+
+                        // set even lanes
+                        let mut vec = $id::splat($clear as _);
+                        for i in 0..$id::lanes() {
+                            if i % 2 == 0 {
+                                vec = vec.replace(i, $set as _);
+                            }
+                        }
+                        // create bitmask with even lanes set:
+                        let mut bitmask: $ibitmask_ty = 0;
+                        for i in 0..$id::lanes() {
+                            if i % 2 == 0 {
+                                bitmask |= 1 << i;
+                            }
+                        }
+                        assert_eq!(vec.bitmask(), bitmask);
+
+
+                        // set odd lanes
+                        let mut vec = $id::splat($clear as _);
+                        for i in 0..$id::lanes() {
+                            if i % 2 != 0 {
+                                vec = vec.replace(i, $set as _);
+                            }
+                        }
+                        // create bitmask with odd lanes set:
+                        let mut bitmask: $ibitmask_ty = 0;
+                        for i in 0..$id::lanes() {
+                            if i % 2 != 0 {
+                                bitmask |= 1 << i;
+                            }
+                        }
+                        assert_eq!(vec.bitmask(), bitmask);
+
+                        // set all lanes
+                        let vec = $id::splat($set as _);
+                        let mut bitmask: $ibitmask_ty = 0;
+                        for i in 0..$id::lanes() {
+                            bitmask |= 1 << i;
+                        }
+                        assert_eq!(vec.bitmask(), bitmask);
+                    }
+                }
+            }
+        }
+    };
+}
diff --git a/third_party/rust/packed_simd/src/api/cast/v128.rs b/third_party/rust/packed_simd/src/api/cast/v128.rs
--- a/third_party/rust/packed_simd/src/api/cast/v128.rs
+++ b/third_party/rust/packed_simd/src/api/cast/v128.rs
@@ -1,10 +1,10 @@
 //! `FromCast` and `IntoCast` implementations for portable 128-bit wide vectors
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 use crate::*;
 
 impl_from_cast!(
     i8x16[test_v128]: u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16
 );
 impl_from_cast!(
     u8x16[test_v128]: i8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16
diff --git a/third_party/rust/packed_simd/src/api/cast/v16.rs b/third_party/rust/packed_simd/src/api/cast/v16.rs
--- a/third_party/rust/packed_simd/src/api/cast/v16.rs
+++ b/third_party/rust/packed_simd/src/api/cast/v16.rs
@@ -1,10 +1,10 @@
 //! `FromCast` and `IntoCast` implementations for portable 16-bit wide vectors
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 use crate::*;
 
 impl_from_cast!(
     i8x2[test_v16]: u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
     i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
 );
 impl_from_cast!(
diff --git a/third_party/rust/packed_simd/src/api/cast/v256.rs b/third_party/rust/packed_simd/src/api/cast/v256.rs
--- a/third_party/rust/packed_simd/src/api/cast/v256.rs
+++ b/third_party/rust/packed_simd/src/api/cast/v256.rs
@@ -1,10 +1,10 @@
 //! `FromCast` and `IntoCast` implementations for portable 256-bit wide vectors
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 use crate::*;
 
 impl_from_cast!(i8x32[test_v256]: u8x32, m8x32, i16x32, u16x32, m16x32);
 impl_from_cast!(u8x32[test_v256]: i8x32, m8x32, i16x32, u16x32, m16x32);
 impl_from_cast_mask!(m8x32[test_v256]: i8x32, u8x32, i16x32, u16x32, m16x32);
 
 impl_from_cast!(
diff --git a/third_party/rust/packed_simd/src/api/cast/v32.rs b/third_party/rust/packed_simd/src/api/cast/v32.rs
--- a/third_party/rust/packed_simd/src/api/cast/v32.rs
+++ b/third_party/rust/packed_simd/src/api/cast/v32.rs
@@ -1,10 +1,10 @@
 //! `FromCast` and `IntoCast` implementations for portable 32-bit wide vectors
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 use crate::*;
 
 impl_from_cast!(
     i8x4[test_v32]: u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
     i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
 );
 impl_from_cast!(
diff --git a/third_party/rust/packed_simd/src/api/cast/v512.rs b/third_party/rust/packed_simd/src/api/cast/v512.rs
--- a/third_party/rust/packed_simd/src/api/cast/v512.rs
+++ b/third_party/rust/packed_simd/src/api/cast/v512.rs
@@ -1,10 +1,10 @@
 //! `FromCast` and `IntoCast` implementations for portable 512-bit wide vectors
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 use crate::*;
 
 impl_from_cast!(i8x64[test_v512]: u8x64, m8x64);
 impl_from_cast!(u8x64[test_v512]: i8x64, m8x64);
 impl_from_cast_mask!(m8x64[test_v512]: i8x64, u8x64);
 
 impl_from_cast!(i16x32[test_v512]: i8x32, u8x32, m8x32, u16x32, m16x32);
diff --git a/third_party/rust/packed_simd/src/api/cast/v64.rs b/third_party/rust/packed_simd/src/api/cast/v64.rs
--- a/third_party/rust/packed_simd/src/api/cast/v64.rs
+++ b/third_party/rust/packed_simd/src/api/cast/v64.rs
@@ -1,10 +1,10 @@
 //! `FromCast` and `IntoCast` implementations for portable 64-bit wide vectors
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 use crate::*;
 
 impl_from_cast!(
     i8x8[test_v64]: u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
     i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
 );
 impl_from_cast!(
diff --git a/third_party/rust/packed_simd/src/api/default.rs b/third_party/rust/packed_simd/src/api/default.rs
--- a/third_party/rust/packed_simd/src/api/default.rs
+++ b/third_party/rust/packed_simd/src/api/default.rs
@@ -7,16 +7,18 @@ macro_rules! impl_default {
             fn default() -> Self {
                 Self::splat($elem_ty::default())
             }
         }
 
         test_if!{
             $test_tt:
             paste::item! {
+                // Comparisons use integer casts within mantissa^1 range.
+                #[allow(clippy::float_cmp)]
                 pub mod [<$id _default>] {
                     use super::*;
                     #[cfg_attr(not(target_arch = "wasm32"), test)] #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     fn default() {
                         let a = $id::default();
                         for i in 0..$id::lanes() {
                             assert_eq!(a.extract(i), $elem_ty::default());
                         }
diff --git a/third_party/rust/packed_simd/src/api/from/from_array.rs b/third_party/rust/packed_simd/src/api/from/from_array.rs
--- a/third_party/rust/packed_simd/src/api/from/from_array.rs
+++ b/third_party/rust/packed_simd/src/api/from/from_array.rs
@@ -51,16 +51,18 @@ macro_rules! impl_from_array {
                 unsafe { U { array: self }.vec }
             }
         }
         */
 
         test_if! {
             $test_tt:
             paste::item! {
+                // Comparisons use integer casts within mantissa^1 range.
+                #[allow(clippy::float_cmp)]
                 mod [<$id _from>] {
                     use super::*;
                     #[test]
                     fn array() {
                         let vec: $id = Default::default();
 
                         // FIXME: Workaround for arrays with more than 32
                         // elements.
diff --git a/third_party/rust/packed_simd/src/api/hash.rs b/third_party/rust/packed_simd/src/api/hash.rs
--- a/third_party/rust/packed_simd/src/api/hash.rs
+++ b/third_party/rust/packed_simd/src/api/hash.rs
@@ -31,16 +31,18 @@ macro_rules! impl_hash {
                             crate::mem::size_of::<A>(),
                             crate::mem::size_of::<$id>()
                         );
                         #[allow(deprecated)]
                         let mut a_hash = SipHasher13::new();
                         let mut v_hash = a_hash.clone();
                         a.hash(&mut a_hash);
 
+                        // Integer within mantissa^1 range.
+                        #[allow(clippy::float_cmp)]
                         let v = $id::splat(42 as $elem_ty);
                         v.hash(&mut v_hash);
                         assert_eq!(a_hash.finish(), v_hash.finish());
                     }
                 }
             }
         }
     };
diff --git a/third_party/rust/packed_simd/src/api/into_bits/arch_specific.rs b/third_party/rust/packed_simd/src/api/into_bits/arch_specific.rs
--- a/third_party/rust/packed_simd/src/api/into_bits/arch_specific.rs
+++ b/third_party/rust/packed_simd/src/api/into_bits/arch_specific.rs
@@ -1,11 +1,11 @@
 //! `FromBits` and `IntoBits` between portable vector types and the
 //! architecture-specific vector types.
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 // FIXME: MIPS FromBits/IntoBits
 
 #[allow(unused)]
 use crate::*;
 
 /// This macro implements FromBits for the portable and the architecture
 /// specific vector types.
@@ -79,17 +79,16 @@ macro_rules! impl_arch {
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Implementations for the 64-bit wide vector types:
 
 // FIXME: 64-bit single element types
 // FIXME: arm/aarch float16x4_t missing
 impl_arch!(
-    [x86["x86"]: __m64], [x86_64["x86_64"]: __m64],
     [arm["arm"]: int8x8_t, uint8x8_t, poly8x8_t, int16x4_t, uint16x4_t,
      poly16x4_t, int32x2_t, uint32x2_t, float32x2_t, int64x1_t,
      uint64x1_t],
     [aarch64["aarch64"]: int8x8_t, uint8x8_t, poly8x8_t, int16x4_t, uint16x4_t,
      poly16x4_t, int32x2_t, uint32x2_t, float32x2_t, int64x1_t, uint64x1_t,
      float64x1_t] |
     from: i8x8, u8x8, m8x8, i16x4, u16x4, m16x4, i32x2, u32x2, f32x2, m32x2 |
     into: i8x8, u8x8, i16x4, u16x4, i32x2, u32x2, f32x2 |
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v128.rs b/third_party/rust/packed_simd/src/api/into_bits/v128.rs
--- a/third_party/rust/packed_simd/src/api/into_bits/v128.rs
+++ b/third_party/rust/packed_simd/src/api/into_bits/v128.rs
@@ -1,10 +1,10 @@
 //! `FromBits` and `IntoBits` implementations for portable 128-bit wide vectors
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 #[allow(unused)]  // wasm_bindgen_test
 use crate::*;
 
 impl_from_bits!(i8x16[test_v128]: u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
 impl_from_bits!(u8x16[test_v128]: i8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
 impl_from_bits!(m8x16[test_v128]: m16x8, m32x4, m64x2, m128x1);
 
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v16.rs b/third_party/rust/packed_simd/src/api/into_bits/v16.rs
--- a/third_party/rust/packed_simd/src/api/into_bits/v16.rs
+++ b/third_party/rust/packed_simd/src/api/into_bits/v16.rs
@@ -1,9 +1,9 @@
 //! `FromBits` and `IntoBits` implementations for portable 16-bit wide vectors
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 #[allow(unused)]  // wasm_bindgen_test
 use crate::*;
 
 impl_from_bits!(i8x2[test_v16]: u8x2, m8x2);
 impl_from_bits!(u8x2[test_v16]: i8x2, m8x2);
 // note: m8x2 cannot be constructed from all i8x2 or u8x2 bit patterns
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v256.rs b/third_party/rust/packed_simd/src/api/into_bits/v256.rs
--- a/third_party/rust/packed_simd/src/api/into_bits/v256.rs
+++ b/third_party/rust/packed_simd/src/api/into_bits/v256.rs
@@ -1,10 +1,10 @@
 //! `FromBits` and `IntoBits` implementations for portable 256-bit wide vectors
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 #[allow(unused)]  // wasm_bindgen_test
 use crate::*;
 
 impl_from_bits!(i8x32[test_v256]: u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
 impl_from_bits!(u8x32[test_v256]: i8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
 impl_from_bits!(m8x32[test_v256]: m16x16, m32x8, m64x4, m128x2);
 
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v32.rs b/third_party/rust/packed_simd/src/api/into_bits/v32.rs
--- a/third_party/rust/packed_simd/src/api/into_bits/v32.rs
+++ b/third_party/rust/packed_simd/src/api/into_bits/v32.rs
@@ -1,10 +1,10 @@
 //! `FromBits` and `IntoBits` implementations for portable 32-bit wide vectors
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 #[allow(unused)]  // wasm_bindgen_test
 use crate::*;
 
 impl_from_bits!(i8x4[test_v32]: u8x4, m8x4, i16x2, u16x2, m16x2);
 impl_from_bits!(u8x4[test_v32]: i8x4, m8x4, i16x2, u16x2, m16x2);
 impl_from_bits!(m8x4[test_v32]: m16x2);
 
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v512.rs b/third_party/rust/packed_simd/src/api/into_bits/v512.rs
--- a/third_party/rust/packed_simd/src/api/into_bits/v512.rs
+++ b/third_party/rust/packed_simd/src/api/into_bits/v512.rs
@@ -1,10 +1,10 @@
 //! `FromBits` and `IntoBits` implementations for portable 512-bit wide vectors
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 #[allow(unused)]  // wasm_bindgen_test
 use crate::*;
 
 impl_from_bits!(i8x64[test_v512]: u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
 impl_from_bits!(u8x64[test_v512]: i8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
 impl_from_bits!(m8x64[test_v512]: m16x32, m32x16, m64x8, m128x4);
 
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v64.rs b/third_party/rust/packed_simd/src/api/into_bits/v64.rs
--- a/third_party/rust/packed_simd/src/api/into_bits/v64.rs
+++ b/third_party/rust/packed_simd/src/api/into_bits/v64.rs
@@ -1,10 +1,10 @@
 //! `FromBits` and `IntoBits` implementations for portable 64-bit wide vectors
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 #[allow(unused)]  // wasm_bindgen_test
 use crate::*;
 
 impl_from_bits!(i8x8[test_v64]: u8x8, m8x8, i16x4, u16x4, m16x4, i32x2, u32x2, f32x2, m32x2);
 impl_from_bits!(u8x8[test_v64]: i8x8, m8x8, i16x4, u16x4, m16x4, i32x2, u32x2, f32x2, m32x2);
 impl_from_bits!(m8x8[test_v64]: m16x4, m32x2);
 
diff --git a/third_party/rust/packed_simd/src/api/minimal/iuf.rs b/third_party/rust/packed_simd/src/api/minimal/iuf.rs
--- a/third_party/rust/packed_simd/src/api/minimal/iuf.rs
+++ b/third_party/rust/packed_simd/src/api/minimal/iuf.rs
@@ -48,17 +48,17 @@ macro_rules! impl_minimal_iuf {
             #[inline]
             pub fn extract(self, index: usize) -> $elem_ty {
                 assert!(index < $elem_count);
                 unsafe { self.extract_unchecked(index) }
             }
 
             /// Extracts the value at `index`.
             ///
-            /// # Precondition
+            /// # Safety
             ///
             /// If `index >= Self::lanes()` the behavior is undefined.
             #[inline]
             pub unsafe fn extract_unchecked(self, index: usize) -> $elem_ty {
                 use crate::llvm::simd_extract;
                 let e: $ielem_ty = simd_extract(self.0, index as u32);
                 e as $elem_ty
             }
@@ -75,17 +75,17 @@ macro_rules! impl_minimal_iuf {
             ]
             pub fn replace(self, index: usize, new_value: $elem_ty) -> Self {
                 assert!(index < $elem_count);
                 unsafe { self.replace_unchecked(index, new_value) }
             }
 
             /// Returns a new vector where the value at `index` is replaced by `new_value`.
             ///
-            /// # Precondition
+            /// # Safety
             ///
             /// If `index >= Self::lanes()` the behavior is undefined.
             #[inline]
             #[must_use = "replace_unchecked does not modify the original value - \
                           it returns a new vector with the value at `index` \
                           replaced by `new_value`d"
             ]
             pub unsafe fn replace_unchecked(
@@ -96,16 +96,18 @@ macro_rules! impl_minimal_iuf {
                 use crate::llvm::simd_insert;
                 Simd(simd_insert(self.0, index as u32, new_value as $ielem_ty))
             }
         }
 
         test_if!{
             $test_tt:
             paste::item! {
+                // Comparisons use integer casts within mantissa^1 range.
+                #[allow(clippy::float_cmp)]
                 pub mod [<$id _minimal>] {
                     use super::*;
                     #[cfg_attr(not(target_arch = "wasm32"), test)]
                     #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     fn minimal() {
                         // lanes:
                         assert_eq!($elem_count, $id::lanes());
 
diff --git a/third_party/rust/packed_simd/src/api/minimal/mask.rs b/third_party/rust/packed_simd/src/api/minimal/mask.rs
--- a/third_party/rust/packed_simd/src/api/minimal/mask.rs
+++ b/third_party/rust/packed_simd/src/api/minimal/mask.rs
@@ -53,16 +53,18 @@ macro_rules! impl_minimal_mask {
             #[inline]
             pub fn extract(self, index: usize) -> bool {
                 assert!(index < $elem_count);
                 unsafe { self.extract_unchecked(index) }
             }
 
             /// Extracts the value at `index`.
             ///
+            /// # Safety
+            ///
             /// If `index >= Self::lanes()` the behavior is undefined.
             #[inline]
             pub unsafe fn extract_unchecked(self, index: usize) -> bool {
                 use crate::llvm::simd_extract;
                 let x: $ielem_ty = simd_extract(self.0, index as u32);
                 x != 0
             }
 
@@ -80,19 +82,19 @@ macro_rules! impl_minimal_mask {
             pub fn replace(self, index: usize, new_value: bool) -> Self {
                 assert!(index < $elem_count);
                 unsafe { self.replace_unchecked(index, new_value) }
             }
 
             /// Returns a new vector where the value at `index` is replaced by
             /// `new_value`.
             ///
-            /// # Panics
+            /// # Safety
             ///
-            /// If `index >= Self::lanes()`.
+            /// If `index >= Self::lanes()` the behavior is undefined.
             #[inline]
             #[must_use = "replace_unchecked does not modify the original value - \
                           it returns a new vector with the value at `index` \
                           replaced by `new_value`d"
             ]
             pub unsafe fn replace_unchecked(
                 self,
                 index: usize,
diff --git a/third_party/rust/packed_simd/src/api/minimal/ptr.rs b/third_party/rust/packed_simd/src/api/minimal/ptr.rs
--- a/third_party/rust/packed_simd/src/api/minimal/ptr.rs
+++ b/third_party/rust/packed_simd/src/api/minimal/ptr.rs
@@ -63,17 +63,17 @@ macro_rules! impl_minimal_p {
             #[inline]
             pub fn extract(self, index: usize) -> $elem_ty {
                 assert!(index < $elem_count);
                 unsafe { self.extract_unchecked(index) }
             }
 
             /// Extracts the value at `index`.
             ///
-            /// # Precondition
+            /// # Safety
             ///
             /// If `index >= Self::lanes()` the behavior is undefined.
             #[inline]
             pub unsafe fn extract_unchecked(self, index: usize) -> $elem_ty {
                 use crate::llvm::simd_extract;
                 simd_extract(self.0, index as u32)
             }
 
@@ -91,17 +91,17 @@ macro_rules! impl_minimal_p {
             #[allow(clippy::not_unsafe_ptr_arg_deref)]
             pub fn replace(self, index: usize, new_value: $elem_ty) -> Self {
                 assert!(index < $elem_count);
                 unsafe { self.replace_unchecked(index, new_value) }
             }
 
             /// Returns a new vector where the value at `index` is replaced by `new_value`.
             ///
-            /// # Precondition
+            /// # Safety
             ///
             /// If `index >= Self::lanes()` the behavior is undefined.
             #[inline]
             #[must_use = "replace_unchecked does not modify the original value - \
                           it returns a new vector with the value at `index` \
                           replaced by `new_value`d"
             ]
             pub unsafe fn replace_unchecked(
@@ -210,17 +210,17 @@ macro_rules! impl_minimal_p {
         impl<T> crate::fmt::Debug for $id<T> {
             #[allow(clippy::missing_inline_in_public_items)]
             fn fmt(&self, f: &mut crate::fmt::Formatter<'_>)
                    -> crate::fmt::Result {
                 write!(
                     f,
                     "{}<{}>(",
                     stringify!($id),
-                    unsafe { crate::intrinsics::type_name::<T>() }
+                    crate::intrinsics::type_name::<T>()
                 )?;
                 for i in 0..$elem_count {
                     if i > 0 {
                         write!(f, ", ")?;
                     }
                     self.extract(i).fmt(f)?;
                 }
                 write!(f, ")")
@@ -545,21 +545,17 @@ macro_rules! impl_minimal_p {
                         let values = [1_i32; $elem_count];
 
                         let mut vec: $id<i32> = Default::default();
                         let mut array = [
                             $id::<i32>::null().extract(0); $elem_count
                         ];
 
                         for i in 0..$elem_count {
-                            let ptr = unsafe {
-                                crate::mem::transmute(
-                                    &values[i] as *const i32
-                                )
-                            };
+                            let ptr = &values[i] as *const i32 as *mut i32;
                             vec = vec.replace(i, ptr);
                             array[i] = ptr;
                         }
 
                         // FIXME: there is no impl of From<$id<T>> for [$elem_ty; N]
                         // let a0 = From::from(vec);
                         // assert_eq!(a0, array);
                         #[allow(unused_assignments)]
@@ -606,30 +602,30 @@ macro_rules! impl_minimal_p {
                 unsafe {
                     assert!(slice.len() >= $elem_count);
                     Self::from_slice_unaligned_unchecked(slice)
                 }
             }
 
             /// Instantiates a new vector with the values of the `slice`.
             ///
-            /// # Precondition
+            /// # Safety
             ///
             /// If `slice.len() < Self::lanes()` or `&slice[0]` is not aligned
             /// to an `align_of::<Self>()` boundary, the behavior is undefined.
             #[inline]
             pub unsafe fn from_slice_aligned_unchecked(slice: &[$elem_ty])
                                                        -> Self {
                 #[allow(clippy::cast_ptr_alignment)]
                 *(slice.get_unchecked(0) as *const $elem_ty as *const Self)
             }
 
             /// Instantiates a new vector with the values of the `slice`.
             ///
-            /// # Precondition
+            /// # Safety
             ///
             /// If `slice.len() < Self::lanes()` the behavior is undefined.
             #[inline]
             pub unsafe fn from_slice_unaligned_unchecked(
                 slice: &[$elem_ty],
             ) -> Self {
                 use crate::mem::size_of;
                 let target_ptr =
@@ -822,33 +818,33 @@ macro_rules! impl_minimal_p {
                 unsafe {
                     assert!(slice.len() >= $elem_count);
                     self.write_to_slice_unaligned_unchecked(slice);
                 }
             }
 
             /// Writes the values of the vector to the `slice`.
             ///
-            /// # Precondition
+            /// # Safety
             ///
             /// If `slice.len() < Self::lanes()` or `&slice[0]` is not
             /// aligned to an `align_of::<Self>()` boundary, the behavior is
             /// undefined.
             #[inline]
             pub unsafe fn write_to_slice_aligned_unchecked(
                 self, slice: &mut [$elem_ty],
             ) {
                 #[allow(clippy::cast_ptr_alignment)]
                 *(slice.get_unchecked_mut(0) as *mut $elem_ty as *mut Self) =
                     self;
             }
 
             /// Writes the values of the vector to the `slice`.
             ///
-            /// # Precondition
+            /// # Safety
             ///
             /// If `slice.len() < Self::lanes()` the behavior is undefined.
             #[inline]
             pub unsafe fn write_to_slice_unaligned_unchecked(
                 self, slice: &mut [$elem_ty],
             ) {
                 let target_ptr =
                     slice.get_unchecked_mut(0) as *mut $elem_ty as *mut u8;
@@ -1020,21 +1016,17 @@ macro_rules! impl_minimal_p {
 
                         let mut vec: $id<i32> = Default::default();
                         let mut array = [
                             $id::<i32>::null().extract(0);
                             $elem_count
                         ];
 
                         for i in 0..$elem_count {
-                            let ptr = unsafe {
-                                crate::mem::transmute(
-                                    &values[i] as *const i32
-                                )
-                            };
+                            let ptr = &values[i] as *const i32 as *mut i32;
                             vec = vec.replace(i, ptr);
                             array[i] = ptr;
                         }
 
                         #[allow(deprecated)]
                         let mut a_hash = SipHasher13::new();
                         let mut v_hash = a_hash.clone();
                         array.hash(&mut a_hash);
@@ -1146,17 +1138,17 @@ macro_rules! impl_minimal_p {
             /// allocation. For instance, no known 64-bit platform can ever
             /// serve a request for 263 bytes due to page-table limitations or
             /// splitting the address space. However, some 32-bit and 16-bit
             /// platforms may successfully serve a request for more than
             /// `isize::MAX` bytes with things like Physical Address Extension.
             /// As such, memory acquired directly from allocators or memory
             /// mapped files may be too large to handle with this function.
             ///
-            /// Consider using wrapping_offset_from instead if these constraints
+            /// Consider using `wrapping_offset_from` instead if these constraints
             /// are difficult to satisfy. The only advantage of this method is
             /// that it enables more aggressive compiler optimizations.
             #[inline]
             pub unsafe fn offset_from(self, origin: Self) -> $isize_ty {
                 // FIXME: should use LLVM's `sub nsw nuw`.
                 self.wrapping_offset_from(origin)
             }
 
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_float_min_max.rs b/third_party/rust/packed_simd/src/api/ops/vector_float_min_max.rs
--- a/third_party/rust/packed_simd/src/api/ops/vector_float_min_max.rs
+++ b/third_party/rust/packed_simd/src/api/ops/vector_float_min_max.rs
@@ -21,16 +21,21 @@ macro_rules! impl_ops_vector_float_min_m
             pub fn max(self, x: Self) -> Self {
                 use crate::llvm::simd_fmax;
                 unsafe { Simd(simd_fmax(self.0, x.0)) }
             }
         }
         test_if!{
             $test_tt:
             paste::item! {
+                #[cfg(not(any(
+                    // FIXME: https://github.com/rust-lang-nursery/packed_simd/issues/223
+                    all(target_arch = "mips", target_endian = "big"),
+                    target_arch = "mips64",
+                )))]
                 pub mod [<$id _ops_vector_min_max>] {
                     use super::*;
                     #[cfg_attr(not(target_arch = "wasm32"), test)] #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     fn min_max() {
                         let n = crate::$elem_ty::NAN;
                         let o = $id::splat(1. as $elem_ty);
                         let t = $id::splat(2. as $elem_ty);
 
diff --git a/third_party/rust/packed_simd/src/api/ptr/gather_scatter.rs b/third_party/rust/packed_simd/src/api/ptr/gather_scatter.rs
--- a/third_party/rust/packed_simd/src/api/ptr/gather_scatter.rs
+++ b/third_party/rust/packed_simd/src/api/ptr/gather_scatter.rs
@@ -44,19 +44,19 @@ macro_rules! impl_ptr_read {
                         let mut v = [0_i32; $elem_count];
                         for i in 0..$elem_count {
                             v[i] = i as i32;
                         }
 
                         let mut ptr = $id::<i32>::null();
 
                         for i in 0..$elem_count {
-                            ptr = ptr.replace(i, unsafe {
-                                crate::mem::transmute(&v[i] as *const i32)
-                            });
+                            ptr = ptr.replace(i,
+                                &v[i] as *const i32 as *mut i32
+                            );
                         }
 
                         // all mask elements are true:
                         let mask = $mask_ty::splat(true);
                         let def = Simd::<[i32; $elem_count]>::splat(42_i32);
                         let r: Simd<[i32; $elem_count]> = unsafe {
                             ptr.read(mask, def)
                         };
@@ -130,42 +130,18 @@ macro_rules! impl_ptr_write {
             #[inline]
             pub unsafe fn write<M>(
                 self, mask: Simd<[M; $elem_count]>,
                 value: Simd<[T; $elem_count]>,
             ) where
                 M: sealed::Mask,
                 [M; $elem_count]: sealed::SimdArray,
             {
-                // FIXME:
-                // https://github.com/rust-lang-nursery/packed_simd/issues/85
-                #[cfg(not(target_arch = "mips"))]
-                {
-                    use crate::llvm::simd_scatter;
-                    simd_scatter(value.0, self.0, mask.0)
-                }
-                #[cfg(target_arch = "mips")]
-                {
-                    let m_ptr =
-                        &mask as *const Simd<[M; $elem_count]> as *const M;
-                    for i in 0..$elem_count {
-                        let m = ptr::read(m_ptr.add(i));
-                        if m.test() {
-                            let t_ptr = &self
-                                as *const Simd<[*mut T; $elem_count]>
-                                as *mut *mut T;
-                            let v_ptr = &value as *const Simd<[T; $elem_count]>
-                                as *const T;
-                            ptr::write(
-                                ptr::read(t_ptr.add(i)),
-                                ptr::read(v_ptr.add(i)),
-                            );
-                        }
-                    }
-                }
+                use crate::llvm::simd_scatter;
+                simd_scatter(value.0, self.0, mask.0)
             }
         }
 
         test_if! {
             $test_tt:
             paste::item! {
                 mod [<$id _write>] {
                     use super::*;
@@ -180,17 +156,17 @@ macro_rules! impl_ptr_write {
                         for i in 0..$elem_count {
                             arr[i] = i as i32;
                         }
                         // arr = [0, 1, 2, ...]
 
                         let mut ptr = $id::<i32>::null();
                         for i in 0..$elem_count {
                             ptr = ptr.replace(i, unsafe {
-                                crate::mem::transmute(arr.as_ptr().add(i))
+                                arr.as_ptr().add(i) as *mut i32
                             });
                         }
                         // ptr = [&arr[0], &arr[1], ...]
 
                         // write `fourty_two` to all elements of `v`
                         {
                             let backup = arr;
                             unsafe {
diff --git a/third_party/rust/packed_simd/src/api/reductions/float_arithmetic.rs b/third_party/rust/packed_simd/src/api/reductions/float_arithmetic.rs
--- a/third_party/rust/packed_simd/src/api/reductions/float_arithmetic.rs
+++ b/third_party/rust/packed_simd/src/api/reductions/float_arithmetic.rs
@@ -88,16 +88,18 @@ macro_rules! impl_reduction_float_arithm
             fn product<I: Iterator<Item = &'a $id>>(iter: I) -> $id {
                 iter.fold($id::splat(1.), |a, b| crate::ops::Mul::mul(a, *b))
             }
         }
 
         test_if! {
             $test_tt:
             paste::item! {
+                // Comparisons use integer casts within mantissa^1 range.
+                #[allow(clippy::float_cmp)]
                 pub mod [<$id _reduction_float_arith>] {
                     use super::*;
                     fn alternating(x: usize) -> $id {
                         let mut v = $id::splat(1 as $elem_ty);
                         for i in 0..$id::lanes() {
                             if i % x == 0 {
                                 v = v.replace(i, 2 as $elem_ty);
                             }
@@ -220,17 +222,17 @@ macro_rules! impl_reduction_float_arithm
                         }
 
                         let mut start = crate::$elem_ty::EPSILON;
                         let mut scalar_reduction = 0. as $elem_ty;
 
                         let mut v = $id::splat(0. as $elem_ty);
                         for i in 0..$id::lanes() {
                             let c = if i % 2 == 0 { 1e3 } else { -1. };
-                            start *= 3.14 * c;
+                            start *= ::core::$elem_ty::consts::PI * c;
                             scalar_reduction += start;
                             v = v.replace(i, start);
                         }
                         let simd_reduction = v.sum();
 
                         let mut a = [0. as $elem_ty; $id::lanes()];
                         v.write_to_slice_unaligned(&mut a);
                         let tree_reduction = tree_reduce_sum(&a);
@@ -252,16 +254,17 @@ macro_rules! impl_reduction_float_arithm
                             scalar_reduction
                         );
                     }
 
                     #[cfg_attr(not(target_arch = "wasm32"), test)]
                     #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     #[allow(unused, dead_code)]
                     fn product_roundoff() {
+                        use ::core::convert::TryInto;
                         // Performs a tree-reduction
                         fn tree_reduce_product(a: &[$elem_ty]) -> $elem_ty {
                             assert!(!a.is_empty());
                             if a.len() == 1 {
                                 a[0]
                             } else if a.len() == 2 {
                                 a[0] * a[1]
                             } else {
@@ -273,35 +276,37 @@ macro_rules! impl_reduction_float_arithm
                         }
 
                         let mut start = crate::$elem_ty::EPSILON;
                         let mut scalar_reduction = 1. as $elem_ty;
 
                         let mut v = $id::splat(0. as $elem_ty);
                         for i in 0..$id::lanes() {
                             let c = if i % 2 == 0 { 1e3 } else { -1. };
-                            start *= 3.14 * c;
+                            start *= ::core::$elem_ty::consts::PI * c;
                             scalar_reduction *= start;
                             v = v.replace(i, start);
                         }
                         let simd_reduction = v.product();
 
                         let mut a = [0. as $elem_ty; $id::lanes()];
                         v.write_to_slice_unaligned(&mut a);
                         let tree_reduction = tree_reduce_product(&a);
 
-                        // tolerate 1 ULP difference:
+                        // FIXME: Too imprecise, even only for product(f32x8).
+                        // Figure out how to narrow this down.
+                        let ulp_limit = $id::lanes() / 2;
                         let red_bits = simd_reduction.to_bits();
                         let tree_bits = tree_reduction.to_bits();
                         assert!(
                             if red_bits > tree_bits {
                                 red_bits - tree_bits
                             } else {
                                 tree_bits - red_bits
-                            } < 2,
+                            } < ulp_limit.try_into().unwrap(),
                             "vector: {:?} | simd_reduction: {:?} | \
                              tree_reduction: {} | scalar_reduction: {}",
                             v,
                             simd_reduction,
                             tree_reduction,
                             scalar_reduction
                         );
                     }
diff --git a/third_party/rust/packed_simd/src/api/reductions/min_max.rs b/third_party/rust/packed_simd/src/api/reductions/min_max.rs
--- a/third_party/rust/packed_simd/src/api/reductions/min_max.rs
+++ b/third_party/rust/packed_simd/src/api/reductions/min_max.rs
@@ -71,16 +71,18 @@ macro_rules! impl_reduction_min_max {
                         x = x.min(self.extract(i));
                     }
                     x
                 }
             }
         }
         test_if! {$test_tt:
         paste::item! {
+            // Comparisons use integer casts within mantissa^1 range.
+            #[allow(clippy::float_cmp)]
             pub mod [<$id _reduction_min_max>] {
                 use super::*;
                 #[cfg_attr(not(target_arch = "wasm32"), test)]
                 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                 pub fn max_element() {
                     let v = $id::splat(0 as $elem_ty);
                     assert_eq!(v.max_element(), 0 as $elem_ty);
                     if $id::lanes() > 1 {
@@ -119,16 +121,18 @@ macro_rules! impl_reduction_min_max {
     };
 }
 
 macro_rules! test_reduction_float_min_max {
     ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt) => {
         test_if!{
             $test_tt:
             paste::item! {
+                // Comparisons use integer casts within mantissa^1 range.
+                #[allow(clippy::float_cmp)]
                 pub mod [<$id _reduction_min_max_nan>] {
                     use super::*;
                     #[cfg_attr(not(target_arch = "wasm32"), test)]
                     #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     fn min_element_test() {
                         let n = crate::$elem_ty::NAN;
 
                         assert_eq!(n.min(-3.), -3.);
diff --git a/third_party/rust/packed_simd/src/api/slice/from_slice.rs b/third_party/rust/packed_simd/src/api/slice/from_slice.rs
--- a/third_party/rust/packed_simd/src/api/slice/from_slice.rs
+++ b/third_party/rust/packed_simd/src/api/slice/from_slice.rs
@@ -33,17 +33,17 @@ macro_rules! impl_slice_from_slice {
                 unsafe {
                     assert!(slice.len() >= $elem_count);
                     Self::from_slice_unaligned_unchecked(slice)
                 }
             }
 
             /// Instantiates a new vector with the values of the `slice`.
             ///
-            /// # Precondition
+            /// # Safety
             ///
             /// If `slice.len() < Self::lanes()` or `&slice[0]` is not aligned
             /// to an `align_of::<Self>()` boundary, the behavior is undefined.
             #[inline]
             pub unsafe fn from_slice_aligned_unchecked(
                 slice: &[$elem_ty],
             ) -> Self {
                 debug_assert!(slice.len() >= $elem_count);
@@ -54,17 +54,17 @@ macro_rules! impl_slice_from_slice {
                 );
 
                 #[allow(clippy::cast_ptr_alignment)]
                 *(target_ptr as *const Self)
             }
 
             /// Instantiates a new vector with the values of the `slice`.
             ///
-            /// # Precondition
+            /// # Safety
             ///
             /// If `slice.len() < Self::lanes()` the behavior is undefined.
             #[inline]
             pub unsafe fn from_slice_unaligned_unchecked(
                 slice: &[$elem_ty],
             ) -> Self {
                 use crate::mem::size_of;
                 debug_assert!(slice.len() >= $elem_count);
@@ -79,16 +79,18 @@ macro_rules! impl_slice_from_slice {
                 );
                 x
             }
         }
 
         test_if! {
             $test_tt:
             paste::item! {
+                // Comparisons use integer casts within mantissa^1 range.
+                #[allow(clippy::float_cmp)]
                 pub mod [<$id _slice_from_slice>] {
                     use super::*;
                     use crate::iter::Iterator;
 
                     #[cfg_attr(not(target_arch = "wasm32"), test)]
                     #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     fn from_slice_unaligned() {
                         let mut unaligned = [42 as $elem_ty; $id::lanes() + 1];
diff --git a/third_party/rust/packed_simd/src/api/slice/write_to_slice.rs b/third_party/rust/packed_simd/src/api/slice/write_to_slice.rs
--- a/third_party/rust/packed_simd/src/api/slice/write_to_slice.rs
+++ b/third_party/rust/packed_simd/src/api/slice/write_to_slice.rs
@@ -34,17 +34,17 @@ macro_rules! impl_slice_write_to_slice {
                 unsafe {
                     assert!(slice.len() >= $elem_count);
                     self.write_to_slice_unaligned_unchecked(slice);
                 }
             }
 
             /// Writes the values of the vector to the `slice`.
             ///
-            /// # Precondition
+            /// # Safety
             ///
             /// If `slice.len() < Self::lanes()` or `&slice[0]` is not
             /// aligned to an `align_of::<Self>()` boundary, the behavior is
             /// undefined.
             #[inline]
             pub unsafe fn write_to_slice_aligned_unchecked(
                 self, slice: &mut [$elem_ty],
             ) {
@@ -59,17 +59,17 @@ macro_rules! impl_slice_write_to_slice {
                         #[allow(clippy::cast_ptr_alignment)]
                 #[allow(clippy::cast_ptr_alignment)]
                 #[allow(clippy::cast_ptr_alignment)]
                 *(target_ptr as *mut Self) = self;
             }
 
             /// Writes the values of the vector to the `slice`.
             ///
-            /// # Precondition
+            /// # Safety
             ///
             /// If `slice.len() < Self::lanes()` the behavior is undefined.
             #[inline]
             pub unsafe fn write_to_slice_unaligned_unchecked(
                 self, slice: &mut [$elem_ty],
             ) {
                 debug_assert!(slice.len() >= $elem_count);
                 let target_ptr =
@@ -81,16 +81,18 @@ macro_rules! impl_slice_write_to_slice {
                     crate::mem::size_of::<Self>(),
                 );
             }
         }
 
         test_if! {
             $test_tt:
             paste::item! {
+                // Comparisons use integer casts within mantissa^1 range.
+                #[allow(clippy::float_cmp)]
                 pub mod [<$id _slice_write_to_slice>] {
                     use super::*;
                     use crate::iter::Iterator;
 
                     #[cfg_attr(not(target_arch = "wasm32"), test)]
                     #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     fn write_to_slice_unaligned() {
                         let mut unaligned = [0 as $elem_ty; $id::lanes() + 1];
diff --git a/third_party/rust/packed_simd/src/codegen.rs b/third_party/rust/packed_simd/src/codegen.rs
--- a/third_party/rust/packed_simd/src/codegen.rs
+++ b/third_party/rust/packed_simd/src/codegen.rs
@@ -11,23 +11,26 @@ crate mod swap_bytes;
 macro_rules! impl_simd_array {
     ([$elem_ty:ident; $elem_count:expr]:
      $tuple_id:ident | $($elem_tys:ident),*) => {
         #[derive(Copy, Clone)]
         #[repr(simd)]
         pub struct $tuple_id($(crate $elem_tys),*);
         //^^^^^^^ leaked through SimdArray
 
+        impl crate::sealed::Seal for [$elem_ty; $elem_count] {}
+
         impl crate::sealed::SimdArray for [$elem_ty; $elem_count] {
             type Tuple = $tuple_id;
             type T = $elem_ty;
             const N: usize = $elem_count;
             type NT = [u32; $elem_count];
         }
 
+        impl crate::sealed::Seal for $tuple_id {}
         impl crate::sealed::Simd for $tuple_id {
             type Element = $elem_ty;
             const LANES: usize = $elem_count;
             type LanesType = [u32; $elem_count];
         }
 
     }
 }
diff --git a/third_party/rust/packed_simd/src/codegen/bit_manip.rs b/third_party/rust/packed_simd/src/codegen/bit_manip.rs
--- a/third_party/rust/packed_simd/src/codegen/bit_manip.rs
+++ b/third_party/rust/packed_simd/src/codegen/bit_manip.rs
@@ -1,10 +1,10 @@
 //! LLVM bit manipulation intrinsics.
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 use crate::*;
 
 #[allow(improper_ctypes, dead_code)]
 extern "C" {
     #[link_name = "llvm.ctlz.v2i8"]
     fn ctlz_u8x2(x: u8x2, is_zero_undef: bool) -> u8x2;
     #[link_name = "llvm.ctlz.v4i8"]
diff --git a/third_party/rust/packed_simd/src/codegen/llvm.rs b/third_party/rust/packed_simd/src/codegen/llvm.rs
--- a/third_party/rust/packed_simd/src/codegen/llvm.rs
+++ b/third_party/rust/packed_simd/src/codegen/llvm.rs
@@ -5,41 +5,47 @@ use crate::sealed::Shuffle;
 #[allow(unused_imports)] // FIXME: spurious warning?
 use crate::sealed::Simd;
 
 // Shuffle intrinsics: expanded in users' crates, therefore public.
 extern "platform-intrinsic" {
     // FIXME: Passing this intrinsics an `idx` array with an index that is
     // out-of-bounds will produce a monomorphization-time error.
     // https://github.com/rust-lang-nursery/packed_simd/issues/21
+    #[rustc_args_required_const(2)]
     pub fn simd_shuffle2<T, U>(x: T, y: T, idx: [u32; 2]) -> U
     where
         T: Simd,
         <T as Simd>::Element: Shuffle<[u32; 2], Output = U>;
 
+    #[rustc_args_required_const(2)]
     pub fn simd_shuffle4<T, U>(x: T, y: T, idx: [u32; 4]) -> U
     where
         T: Simd,
         <T as Simd>::Element: Shuffle<[u32; 4], Output = U>;
 
+    #[rustc_args_required_const(2)]
     pub fn simd_shuffle8<T, U>(x: T, y: T, idx: [u32; 8]) -> U
     where
         T: Simd,
         <T as Simd>::Element: Shuffle<[u32; 8], Output = U>;
 
+    #[rustc_args_required_const(2)]
     pub fn simd_shuffle16<T, U>(x: T, y: T, idx: [u32; 16]) -> U
     where
         T: Simd,
         <T as Simd>::Element: Shuffle<[u32; 16], Output = U>;
 
+    #[rustc_args_required_const(2)]
     pub fn simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U
     where
         T: Simd,
         <T as Simd>::Element: Shuffle<[u32; 32], Output = U>;
 
+    #[rustc_args_required_const(2)]
     pub fn simd_shuffle64<T, U>(x: T, y: T, idx: [u32; 64]) -> U
     where
         T: Simd,
         <T as Simd>::Element: Shuffle<[u32; 64], Output = U>;
 }
 
 pub use self::simd_shuffle16 as __shuffle_vector16;
 pub use self::simd_shuffle2 as __shuffle_vector2;
@@ -91,9 +97,11 @@ extern "platform-intrinsic" {
     crate fn simd_fmin<T>(a: T, b: T) -> T;
     crate fn simd_fmax<T>(a: T, b: T) -> T;
 
     crate fn simd_fsqrt<T>(a: T) -> T;
     crate fn simd_fma<T>(a: T, b: T, c: T) -> T;
 
     crate fn simd_gather<T, P, M>(value: T, pointers: P, mask: M) -> T;
     crate fn simd_scatter<T, P, M>(value: T, pointers: P, mask: M);
+
+    crate fn simd_bitmask<T, U>(value: T) -> U;
 }
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86.rs b/third_party/rust/packed_simd/src/codegen/reductions/mask/x86.rs
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86.rs
+++ b/third_party/rust/packed_simd/src/codegen/reductions/mask/x86.rs
@@ -14,23 +14,17 @@ mod avx;
 
 #[cfg(target_feature = "avx2")]
 #[macro_use]
 mod avx2;
 
 /// x86 64-bit m8x8 implementation
 macro_rules! x86_m8x8_impl {
     ($id:ident) => {
-        cfg_if! {
-            if #[cfg(all(target_arch = "x86_64", target_feature = "sse"))] {
-                x86_m8x8_sse_impl!($id);
-            } else {
-                fallback_impl!($id);
-            }
-        }
+        fallback_impl!($id);
     };
 }
 
 /// x86 128-bit m8x16 implementation
 macro_rules! x86_m8x16_impl {
     ($id:ident) => {
         cfg_if! {
             if #[cfg(target_feature = "sse2")] {
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse.rs b/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse.rs
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse.rs
+++ b/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse.rs
@@ -29,40 +29,8 @@ macro_rules! x86_m32x4_sse_impl {
                 #[cfg(target_arch = "x86_64")]
                 use crate::arch::x86_64::_mm_movemask_ps;
 
                 _mm_movemask_ps(crate::mem::transmute(self)) != 0
             }
         }
     };
 }
-
-macro_rules! x86_m8x8_sse_impl {
-    ($id:ident) => {
-        impl All for $id {
-            #[inline]
-            #[target_feature(enable = "sse")]
-            unsafe fn all(self) -> bool {
-                #[cfg(target_arch = "x86")]
-                use crate::arch::x86::_mm_movemask_pi8;
-                #[cfg(target_arch = "x86_64")]
-                use crate::arch::x86_64::_mm_movemask_pi8;
-                // _mm_movemask_pi8(a) creates an 8bit mask containing the most
-                // significant bit of each byte of `a`. If all bits are set,
-                // then all 8 lanes of the mask are true.
-                _mm_movemask_pi8(crate::mem::transmute(self))
-                    == u8::max_value() as i32
-            }
-        }
-        impl Any for $id {
-            #[inline]
-            #[target_feature(enable = "sse")]
-            unsafe fn any(self) -> bool {
-                #[cfg(target_arch = "x86")]
-                use crate::arch::x86::_mm_movemask_pi8;
-                #[cfg(target_arch = "x86_64")]
-                use crate::arch::x86_64::_mm_movemask_pi8;
-
-                _mm_movemask_pi8(crate::mem::transmute(self)) != 0
-            }
-        }
-    };
-}
diff --git a/third_party/rust/packed_simd/src/codegen/shuffle.rs b/third_party/rust/packed_simd/src/codegen/shuffle.rs
--- a/third_party/rust/packed_simd/src/codegen/shuffle.rs
+++ b/third_party/rust/packed_simd/src/codegen/shuffle.rs
@@ -1,302 +1,150 @@
 //! Implementations of the `ShuffleResult` trait for the different numbers of
 //! lanes and vector element types.
 
 use crate::masks::*;
-use crate::sealed::Shuffle;
-
-impl Shuffle<[u32; 2]> for i8 {
-    type Output = crate::codegen::i8x2;
-}
-impl Shuffle<[u32; 4]> for i8 {
-    type Output = crate::codegen::i8x4;
-}
-impl Shuffle<[u32; 8]> for i8 {
-    type Output = crate::codegen::i8x8;
-}
-impl Shuffle<[u32; 16]> for i8 {
-    type Output = crate::codegen::i8x16;
-}
-impl Shuffle<[u32; 32]> for i8 {
-    type Output = crate::codegen::i8x32;
-}
-impl Shuffle<[u32; 64]> for i8 {
-    type Output = crate::codegen::i8x64;
-}
-
-impl Shuffle<[u32; 2]> for u8 {
-    type Output = crate::codegen::u8x2;
-}
-impl Shuffle<[u32; 4]> for u8 {
-    type Output = crate::codegen::u8x4;
-}
-impl Shuffle<[u32; 8]> for u8 {
-    type Output = crate::codegen::u8x8;
-}
-impl Shuffle<[u32; 16]> for u8 {
-    type Output = crate::codegen::u8x16;
-}
-impl Shuffle<[u32; 32]> for u8 {
-    type Output = crate::codegen::u8x32;
-}
-impl Shuffle<[u32; 64]> for u8 {
-    type Output = crate::codegen::u8x64;
-}
-
-impl Shuffle<[u32; 2]> for m8 {
-    type Output = crate::codegen::m8x2;
-}
-impl Shuffle<[u32; 4]> for m8 {
-    type Output = crate::codegen::m8x4;
-}
-impl Shuffle<[u32; 8]> for m8 {
-    type Output = crate::codegen::m8x8;
-}
-impl Shuffle<[u32; 16]> for m8 {
-    type Output = crate::codegen::m8x16;
-}
-impl Shuffle<[u32; 32]> for m8 {
-    type Output = crate::codegen::m8x32;
-}
-impl Shuffle<[u32; 64]> for m8 {
-    type Output = crate::codegen::m8x64;
-}
+use crate::sealed::{Shuffle, Seal};
 
-impl Shuffle<[u32; 2]> for i16 {
-    type Output = crate::codegen::i16x2;
-}
-impl Shuffle<[u32; 4]> for i16 {
-    type Output = crate::codegen::i16x4;
-}
-impl Shuffle<[u32; 8]> for i16 {
-    type Output = crate::codegen::i16x8;
-}
-impl Shuffle<[u32; 16]> for i16 {
-    type Output = crate::codegen::i16x16;
-}
-impl Shuffle<[u32; 32]> for i16 {
-    type Output = crate::codegen::i16x32;
-}
-
-impl Shuffle<[u32; 2]> for u16 {
-    type Output = crate::codegen::u16x2;
-}
-impl Shuffle<[u32; 4]> for u16 {
-    type Output = crate::codegen::u16x4;
-}
-impl Shuffle<[u32; 8]> for u16 {
-    type Output = crate::codegen::u16x8;
-}
-impl Shuffle<[u32; 16]> for u16 {
-    type Output = crate::codegen::u16x16;
-}
-impl Shuffle<[u32; 32]> for u16 {
-    type Output = crate::codegen::u16x32;
-}
-
-impl Shuffle<[u32; 2]> for m16 {
-    type Output = crate::codegen::m16x2;
-}
-impl Shuffle<[u32; 4]> for m16 {
-    type Output = crate::codegen::m16x4;
-}
-impl Shuffle<[u32; 8]> for m16 {
-    type Output = crate::codegen::m16x8;
-}
-impl Shuffle<[u32; 16]> for m16 {
-    type Output = crate::codegen::m16x16;
-}
-impl Shuffle<[u32; 32]> for m16 {
-    type Output = crate::codegen::m16x32;
-}
-
-impl Shuffle<[u32; 2]> for i32 {
-    type Output = crate::codegen::i32x2;
-}
-impl Shuffle<[u32; 4]> for i32 {
-    type Output = crate::codegen::i32x4;
-}
-impl Shuffle<[u32; 8]> for i32 {
-    type Output = crate::codegen::i32x8;
-}
-impl Shuffle<[u32; 16]> for i32 {
-    type Output = crate::codegen::i32x16;
+macro_rules! impl_shuffle {
+    ($array:ty, $base:ty, $out:ty) => {
+        impl Seal<$array> for $base {}
+        impl Shuffle<$array> for $base {
+            type Output = $out;
+        }
+    }
 }
 
-impl Shuffle<[u32; 2]> for u32 {
-    type Output = crate::codegen::u32x2;
-}
-impl Shuffle<[u32; 4]> for u32 {
-    type Output = crate::codegen::u32x4;
-}
-impl Shuffle<[u32; 8]> for u32 {
-    type Output = crate::codegen::u32x8;
-}
-impl Shuffle<[u32; 16]> for u32 {
-    type Output = crate::codegen::u32x16;
-}
+impl_shuffle! { [u32; 2], i8, crate::codegen::i8x2 }
+impl_shuffle! { [u32; 4], i8, crate::codegen::i8x4 }
+impl_shuffle! { [u32; 8], i8, crate::codegen::i8x8 }
+impl_shuffle! { [u32; 16], i8, crate::codegen::i8x16 }
+impl_shuffle! { [u32; 32], i8, crate::codegen::i8x32 }
+impl_shuffle! { [u32; 64], i8, crate::codegen::i8x64 }
 
-impl Shuffle<[u32; 2]> for f32 {
-    type Output = crate::codegen::f32x2;
-}
-impl Shuffle<[u32; 4]> for f32 {
-    type Output = crate::codegen::f32x4;
-}
-impl Shuffle<[u32; 8]> for f32 {
-    type Output = crate::codegen::f32x8;
-}
-impl Shuffle<[u32; 16]> for f32 {
-    type Output = crate::codegen::f32x16;
-}
+impl_shuffle! { [u32; 2], u8, crate::codegen::u8x2 }
+impl_shuffle! { [u32; 4], u8, crate::codegen::u8x4 }
+impl_shuffle! { [u32; 8], u8, crate::codegen::u8x8 }
+impl_shuffle! { [u32; 16], u8, crate::codegen::u8x16 }
+impl_shuffle! { [u32; 32], u8, crate::codegen::u8x32 }
+impl_shuffle! { [u32; 64], u8, crate::codegen::u8x64 }
+
+impl_shuffle! { [u32; 2], m8, crate::codegen::m8x2 }
+impl_shuffle! { [u32; 4], m8, crate::codegen::m8x4 }
+impl_shuffle! { [u32; 8], m8, crate::codegen::m8x8 }
+impl_shuffle! { [u32; 16], m8, crate::codegen::m8x16 }
+impl_shuffle! { [u32; 32], m8, crate::codegen::m8x32 }
+impl_shuffle! { [u32; 64], m8, crate::codegen::m8x64 }
+
+impl_shuffle! { [u32; 2], i16, crate::codegen::i16x2 }
+impl_shuffle! { [u32; 4], i16, crate::codegen::i16x4 }
+impl_shuffle! { [u32; 8], i16, crate::codegen::i16x8 }
+impl_shuffle! { [u32; 16], i16, crate::codegen::i16x16 }
+impl_shuffle! { [u32; 32], i16, crate::codegen::i16x32 }
 
-impl Shuffle<[u32; 2]> for m32 {
-    type Output = crate::codegen::m32x2;
-}
-impl Shuffle<[u32; 4]> for m32 {
-    type Output = crate::codegen::m32x4;
-}
-impl Shuffle<[u32; 8]> for m32 {
-    type Output = crate::codegen::m32x8;
-}
-impl Shuffle<[u32; 16]> for m32 {
-    type Output = crate::codegen::m32x16;
-}
+impl_shuffle! { [u32; 2], u16, crate::codegen::u16x2 }
+impl_shuffle! { [u32; 4], u16, crate::codegen::u16x4 }
+impl_shuffle! { [u32; 8], u16, crate::codegen::u16x8 }
+impl_shuffle! { [u32; 16], u16, crate::codegen::u16x16 }
+impl_shuffle! { [u32; 32], u16, crate::codegen::u16x32 }
+
+impl_shuffle! { [u32; 2], m16, crate::codegen::m16x2 }
+impl_shuffle! { [u32; 4], m16, crate::codegen::m16x4 }
+impl_shuffle! { [u32; 8], m16, crate::codegen::m16x8 }
+impl_shuffle! { [u32; 16], m16, crate::codegen::m16x16 }
 
-/* FIXME: 64-bit single element vector
-impl Shuffle<[u32; 1]> for i64 {
-    type Output = crate::codegen::i64x1;
-}
-*/
-impl Shuffle<[u32; 2]> for i64 {
-    type Output = crate::codegen::i64x2;
-}
-impl Shuffle<[u32; 4]> for i64 {
-    type Output = crate::codegen::i64x4;
-}
-impl Shuffle<[u32; 8]> for i64 {
-    type Output = crate::codegen::i64x8;
-}
+impl_shuffle! { [u32; 2], i32, crate::codegen::i32x2 }
+impl_shuffle! { [u32; 4], i32, crate::codegen::i32x4 }
+impl_shuffle! { [u32; 8], i32, crate::codegen::i32x8 }
+impl_shuffle! { [u32; 16], i32, crate::codegen::i32x16 }
+
+impl_shuffle! { [u32; 2], u32, crate::codegen::u32x2 }
+impl_shuffle! { [u32; 4], u32, crate::codegen::u32x4 }
+impl_shuffle! { [u32; 8], u32, crate::codegen::u32x8 }
+impl_shuffle! { [u32; 16], u32, crate::codegen::u32x16 }
+
+impl_shuffle! { [u32; 2], f32, crate::codegen::f32x2 }
+impl_shuffle! { [u32; 4], f32, crate::codegen::f32x4 }
+impl_shuffle! { [u32; 8], f32, crate::codegen::f32x8 }
+impl_shuffle! { [u32; 16], f32, crate::codegen::f32x16 }
+
+impl_shuffle! { [u32; 2], m32, crate::codegen::m32x2 }
+impl_shuffle! { [u32; 4], m32, crate::codegen::m32x4 }
+impl_shuffle! { [u32; 8], m32, crate::codegen::m32x8 }
+impl_shuffle! { [u32; 16], m32, crate::codegen::m32x16 }
 
 /* FIXME: 64-bit single element vector
-impl Shuffle<[u32; 1]> for u64 {
-    type Output = crate::codegen::u64x1;
-}
+impl_shuffle! { [u32; 1], i64, crate::codegen::i64x1 }
 */
-impl Shuffle<[u32; 2]> for u64 {
-    type Output = crate::codegen::u64x2;
-}
-impl Shuffle<[u32; 4]> for u64 {
-    type Output = crate::codegen::u64x4;
-}
-impl Shuffle<[u32; 8]> for u64 {
-    type Output = crate::codegen::u64x8;
-}
+impl_shuffle! { [u32; 2], i64, crate::codegen::i64x2 }
+impl_shuffle! { [u32; 4], i64, crate::codegen::i64x4 }
+impl_shuffle! { [u32; 8], i64, crate::codegen::i64x8 }
 
 /* FIXME: 64-bit single element vector
-impl Shuffle<[u32; 1]> for f64 {
-    type Output = crate::codegen::f64x1;
-}
+impl_shuffle! { [u32; 1], i64, crate::codegen::i64x1 }
 */
-impl Shuffle<[u32; 2]> for f64 {
-    type Output = crate::codegen::f64x2;
-}
-impl Shuffle<[u32; 4]> for f64 {
-    type Output = crate::codegen::f64x4;
-}
-impl Shuffle<[u32; 8]> for f64 {
-    type Output = crate::codegen::f64x8;
-}
+impl_shuffle! { [u32; 2], u64, crate::codegen::u64x2 }
+impl_shuffle! { [u32; 4], u64, crate::codegen::u64x4 }
+impl_shuffle! { [u32; 8], u64, crate::codegen::u64x8 }
 
 /* FIXME: 64-bit single element vector
-impl Shuffle<[u32; 1]> for m64 {
-    type Output = crate::codegen::m64x1;
-}
+impl_shuffle! { [u32; 1], i64, crate::codegen::i64x1 }
 */
-impl Shuffle<[u32; 2]> for m64 {
-    type Output = crate::codegen::m64x2;
-}
-impl Shuffle<[u32; 4]> for m64 {
-    type Output = crate::codegen::m64x4;
-}
-impl Shuffle<[u32; 8]> for m64 {
-    type Output = crate::codegen::m64x8;
-}
+impl_shuffle! { [u32; 2], f64, crate::codegen::f64x2 }
+impl_shuffle! { [u32; 4], f64, crate::codegen::f64x4 }
+impl_shuffle! { [u32; 8], f64, crate::codegen::f64x8 }
+
+/* FIXME: 64-bit single element vector
+impl_shuffle! { [u32; 1], i64, crate::codegen::i64x1 }
+*/
+impl_shuffle! { [u32; 2], m64, crate::codegen::m64x2 }
+impl_shuffle! { [u32; 4], m64, crate::codegen::m64x4 }
+impl_shuffle! { [u32; 8], m64, crate::codegen::m64x8 }
 
-impl Shuffle<[u32; 2]> for isize {
-    type Output = crate::codegen::isizex2;
-}
-impl Shuffle<[u32; 4]> for isize {
-    type Output = crate::codegen::isizex4;
-}
-impl Shuffle<[u32; 8]> for isize {
-    type Output = crate::codegen::isizex8;
-}
+impl_shuffle! { [u32; 2], isize, crate::codegen::isizex2 }
+impl_shuffle! { [u32; 4], isize, crate::codegen::isizex4 }
+impl_shuffle! { [u32; 8], isize, crate::codegen::isizex8 }
 
-impl Shuffle<[u32; 2]> for usize {
-    type Output = crate::codegen::usizex2;
-}
-impl Shuffle<[u32; 4]> for usize {
-    type Output = crate::codegen::usizex4;
-}
-impl Shuffle<[u32; 8]> for usize {
-    type Output = crate::codegen::usizex8;
-}
+impl_shuffle! { [u32; 2], usize, crate::codegen::usizex2 }
+impl_shuffle! { [u32; 4], usize, crate::codegen::usizex4 }
+impl_shuffle! { [u32; 8], usize, crate::codegen::usizex8 }
 
+impl_shuffle! { [u32; 2], msize, crate::codegen::msizex2 }
+impl_shuffle! { [u32; 4], msize, crate::codegen::msizex4 }
+impl_shuffle! { [u32; 8], msize, crate::codegen::msizex8 }
+
+impl<T> Seal<[u32; 2]> for *const T {}
 impl<T> Shuffle<[u32; 2]> for *const T {
     type Output = crate::codegen::cptrx2<T>;
 }
+impl<T> Seal<[u32; 4]> for *const T {}
 impl<T> Shuffle<[u32; 4]> for *const T {
     type Output = crate::codegen::cptrx4<T>;
 }
+impl<T> Seal<[u32; 8]> for *const T {}
 impl<T> Shuffle<[u32; 8]> for *const T {
     type Output = crate::codegen::cptrx8<T>;
 }
 
+impl<T> Seal<[u32; 2]> for *mut T {}
 impl<T> Shuffle<[u32; 2]> for *mut T {
     type Output = crate::codegen::mptrx2<T>;
 }
+impl<T> Seal<[u32; 4]> for *mut T {}
 impl<T> Shuffle<[u32; 4]> for *mut T {
     type Output = crate::codegen::mptrx4<T>;
 }
+impl<T> Seal<[u32; 8]> for *mut T {}
 impl<T> Shuffle<[u32; 8]> for *mut T {
     type Output = crate::codegen::mptrx8<T>;
 }
 
-impl Shuffle<[u32; 2]> for msize {
-    type Output = crate::codegen::msizex2;
-}
-impl Shuffle<[u32; 4]> for msize {
-    type Output = crate::codegen::msizex4;
-}
-impl Shuffle<[u32; 8]> for msize {
-    type Output = crate::codegen::msizex8;
-}
-
-impl Shuffle<[u32; 1]> for i128 {
-    type Output = crate::codegen::i128x1;
-}
-impl Shuffle<[u32; 2]> for i128 {
-    type Output = crate::codegen::i128x2;
-}
-impl Shuffle<[u32; 4]> for i128 {
-    type Output = crate::codegen::i128x4;
-}
+impl_shuffle! { [u32; 1], i128, crate::codegen::i128x1 }
+impl_shuffle! { [u32; 2], i128, crate::codegen::i128x2 }
+impl_shuffle! { [u32; 4], i128, crate::codegen::i128x4 }
 
-impl Shuffle<[u32; 1]> for u128 {
-    type Output = crate::codegen::u128x1;
-}
-impl Shuffle<[u32; 2]> for u128 {
-    type Output = crate::codegen::u128x2;
-}
-impl Shuffle<[u32; 4]> for u128 {
-    type Output = crate::codegen::u128x4;
-}
+impl_shuffle! { [u32; 1], u128, crate::codegen::u128x1 }
+impl_shuffle! { [u32; 2], u128, crate::codegen::u128x2 }
+impl_shuffle! { [u32; 4], u128, crate::codegen::u128x4 }
 
-impl Shuffle<[u32; 1]> for m128 {
-    type Output = crate::codegen::m128x1;
-}
-impl Shuffle<[u32; 2]> for m128 {
-    type Output = crate::codegen::m128x2;
-}
-impl Shuffle<[u32; 4]> for m128 {
-    type Output = crate::codegen::m128x4;
-}
+impl_shuffle! { [u32; 1], m128, crate::codegen::m128x1 }
+impl_shuffle! { [u32; 2], m128, crate::codegen::m128x2 }
+impl_shuffle! { [u32; 4], m128, crate::codegen::m128x4 }
diff --git a/third_party/rust/packed_simd/src/codegen/shuffle1_dyn.rs b/third_party/rust/packed_simd/src/codegen/shuffle1_dyn.rs
--- a/third_party/rust/packed_simd/src/codegen/shuffle1_dyn.rs
+++ b/third_party/rust/packed_simd/src/codegen/shuffle1_dyn.rs
@@ -23,53 +23,32 @@ macro_rules! impl_fallback {
             }
         }
     };
 }
 
 macro_rules! impl_shuffle1_dyn {
     (u8x8) => {
         cfg_if! {
-            if #[cfg(all(any(target_arch = "x86", target_arch = "x86_64"),
-                         target_feature = "ssse3"))] {
-                impl Shuffle1Dyn for u8x8 {
-                    type Indices = Self;
-                    #[inline]
-                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {
-                        #[cfg(target_arch = "x86")]
-                        use crate::arch::x86::_mm_shuffle_pi8;
-                        #[cfg(target_arch = "x86_64")]
-                        use crate::arch::x86_64::_mm_shuffle_pi8;
-
-                        unsafe {
-                            crate::mem::transmute(
-                                _mm_shuffle_pi8(
-                                    crate::mem::transmute(self.0),
-                                    crate::mem::transmute(indices.0)
-                                )
-                            )
-                        }
-                    }
-                }
-            } else if #[cfg(all(
+            if #[cfg(all(
                 any(
-                    all(target_aarch = "aarch64", target_feature = "neon"),
-                    all(target_aarch = "arm", target_feature = "v7",
+                    all(target_arch = "aarch64", target_feature = "neon"),
+                    all(target_arch = "doesnotexist", target_feature = "v7",
                         target_feature = "neon")
                 ),
                 any(feature = "core_arch", libcore_neon)
             )
             )] {
                 impl Shuffle1Dyn for u8x8 {
                     type Indices = Self;
                     #[inline]
                     fn shuffle1_dyn(self, indices: Self::Indices) -> Self {
-                        #[cfg(targt_arch = "aarch64")]
+                        #[cfg(target_arch = "aarch64")]
                         use crate::arch::aarch64::vtbl1_u8;
-                        #[cfg(targt_arch = "arm")]
+                        #[cfg(target_arch = "doesnotexist")]
                         use crate::arch::arm::vtbl1_u8;
 
                         // This is safe because the binary is compiled with
                         // neon enabled at compile-time and can therefore only
                         // run on CPUs that have it enabled.
                         unsafe {
                             Simd(mem::transmute(
                                 vtbl1_u8(mem::transmute(self.0),
@@ -101,17 +80,17 @@ macro_rules! impl_shuffle1_dyn {
                         unsafe {
                             Simd(mem::transmute(
                                 _mm_shuffle_epi8(mem::transmute(self.0),
                                                 crate::mem::transmute(indices))
                             ))
                         }
                     }
                 }
-            } else if #[cfg(all(target_aarch = "aarch64", target_feature = "neon",
+            } else if #[cfg(all(target_arch = "aarch64", target_feature = "neon",
                                 any(feature = "core_arch", libcore_neon)))] {
                 impl Shuffle1Dyn for u8x16 {
                     type Indices = Self;
                     #[inline]
                     fn shuffle1_dyn(self, indices: Self::Indices) -> Self {
                         use crate::arch::aarch64::vqtbl1q_u8;
 
                         // This is safe because the binary is compiled with
@@ -120,17 +99,17 @@ macro_rules! impl_shuffle1_dyn {
                         unsafe {
                             Simd(mem::transmute(
                                 vqtbl1q_u8(mem::transmute(self.0),
                                           crate::mem::transmute(indices.0))
                             ))
                         }
                     }
                 }
-            } else if #[cfg(all(target_aarch = "arm", target_feature = "v7",
+            } else if #[cfg(all(target_arch = "doesnotexist", target_feature = "v7",
                                 target_feature = "neon",
                                 any(feature = "core_arch", libcore_neon)))] {
                 impl Shuffle1Dyn for u8x16 {
                     type Indices = Self;
                     #[inline]
                     fn shuffle1_dyn(self, indices: Self::Indices) -> Self {
                         use crate::arch::arm::vtbl2_u8;
 
diff --git a/third_party/rust/packed_simd/src/codegen/vPtr.rs b/third_party/rust/packed_simd/src/codegen/vPtr.rs
--- a/third_party/rust/packed_simd/src/codegen/vPtr.rs
+++ b/third_party/rust/packed_simd/src/codegen/vPtr.rs
@@ -3,23 +3,25 @@
 macro_rules! impl_simd_ptr {
     ([$ptr_ty:ty; $elem_count:expr]: $tuple_id:ident | $ty:ident
      | $($tys:ty),*) => {
         #[derive(Copy, Clone)]
         #[repr(simd)]
         pub struct $tuple_id<$ty>($(crate $tys),*);
         //^^^^^^^ leaked through SimdArray
 
+        impl<$ty> crate::sealed::Seal for [$ptr_ty; $elem_count] {}
         impl<$ty> crate::sealed::SimdArray for [$ptr_ty; $elem_count] {
             type Tuple = $tuple_id<$ptr_ty>;
             type T = $ptr_ty;
             const N: usize = $elem_count;
             type NT = [u32; $elem_count];
         }
 
+        impl<$ty> crate::sealed::Seal for $tuple_id<$ptr_ty> {}
         impl<$ty> crate::sealed::Simd for $tuple_id<$ptr_ty> {
             type Element = $ptr_ty;
             const LANES: usize = $elem_count;
             type LanesType = [u32; $elem_count];
         }
 
     }
 }
diff --git a/third_party/rust/packed_simd/src/lib.rs b/third_party/rust/packed_simd/src/lib.rs
--- a/third_party/rust/packed_simd/src/lib.rs
+++ b/third_party/rust/packed_simd/src/lib.rs
@@ -196,40 +196,45 @@
 //!
 //!   * casting from an `f64` to an `f32` **rounds to nearest, ties to even**.
 //!
 //!   Numeric casts are not very "precise": sometimes lossy, sometimes value
 //!   preserving, etc.
 
 #![feature(
     repr_simd,
+    rustc_attrs,
     const_fn,
     platform_intrinsics,
     stdsimd,
     aarch64_target_feature,
     arm_target_feature,
     link_llvm_intrinsics,
     core_intrinsics,
     stmt_expr_attributes,
-    align_offset,
-    mmx_target_feature,
     crate_visibility_modifier,
     custom_inner_attributes
 )]
 #![allow(non_camel_case_types, non_snake_case,
-         clippy::cast_possible_truncation,
-         clippy::cast_lossless,
-         clippy::cast_possible_wrap,
-         clippy::cast_precision_loss,
-         // This lint is currently broken for generic code
-         // See https://github.com/rust-lang/rust-clippy/issues/3410
-         clippy::use_self
+        // FIXME: these types are unsound in C FFI already
+        // See https://github.com/rust-lang/rust/issues/53346
+        improper_ctypes_definitions,
+        clippy::cast_possible_truncation,
+        clippy::cast_lossless,
+        clippy::cast_possible_wrap,
+        clippy::cast_precision_loss,
+        // TODO: manually add the `#[must_use]` attribute where appropriate
+        clippy::must_use_candidate,
+        // This lint is currently broken for generic code
+        // See https://github.com/rust-lang/rust-clippy/issues/3410
+        clippy::use_self,
+        clippy::wrong_self_convention,
 )]
 #![cfg_attr(test, feature(hashmap_internals))]
-#![deny(warnings, rust_2018_idioms, clippy::missing_inline_in_public_items)]
+#![deny(rust_2018_idioms, clippy::missing_inline_in_public_items)]
 #![no_std]
 
 use cfg_if::cfg_if;
 
 cfg_if! {
     if #[cfg(feature = "core_arch")] {
         #[allow(unused_imports)]
         use core_arch as arch;
@@ -251,16 +256,18 @@ use core::{
 
 #[macro_use]
 mod testing;
 #[macro_use]
 mod api;
 mod codegen;
 mod sealed;
 
+pub use crate::sealed::{Simd as SimdVector, Shuffle, SimdArray, Mask};
+
 /// Packed SIMD vector type.
 ///
 /// # Examples
 ///
 /// ```
 /// # use packed_simd::Simd;
 /// let v = Simd::<[i32; 4]>::new(0, 1, 2, 3);
 /// assert_eq!(v.extract(2), 2);
@@ -271,16 +278,18 @@ pub struct Simd<A: sealed::SimdArray>(
     // FIXME: this type should be private,
     // but it currently must be public for the
     // `shuffle!` macro to work: it needs to
     // access the internal `repr(simd)` type
     // to call the shuffle intrinsics.
     #[doc(hidden)] pub <A as sealed::SimdArray>::Tuple,
 );
 
+impl<A: sealed::SimdArray> sealed::Seal for Simd<A> {}
+
 /// Wrapper over `T` implementing a lexicoraphical order via the `PartialOrd`
 /// and/or `Ord` traits.
 #[repr(transparent)]
 #[derive(Copy, Clone, Debug)]
 #[allow(clippy::missing_inline_in_public_items)]
 pub struct LexicographicallyOrdered<T>(T);
 
 mod masks;
diff --git a/third_party/rust/packed_simd/src/masks.rs b/third_party/rust/packed_simd/src/masks.rs
--- a/third_party/rust/packed_simd/src/masks.rs
+++ b/third_party/rust/packed_simd/src/masks.rs
@@ -1,17 +1,19 @@
 //! Mask types
 
 macro_rules! impl_mask_ty {
     ($id:ident : $elem_ty:ident | #[$doc:meta]) => {
         #[$doc]
         #[derive(Copy, Clone)]
         pub struct $id($elem_ty);
 
+        impl crate::sealed::Seal for $id {}
         impl crate::sealed::Mask for $id {
+            #[inline]
             fn test(&self) -> bool {
                 $id::test(self)
             }
         }
 
         impl $id {
             /// Instantiate a mask with `value`
             #[inline]
diff --git a/third_party/rust/packed_simd/src/sealed.rs b/third_party/rust/packed_simd/src/sealed.rs
--- a/third_party/rust/packed_simd/src/sealed.rs
+++ b/third_party/rust/packed_simd/src/sealed.rs
@@ -1,41 +1,42 @@
 //! Sealed traits
 
+/// A sealed trait, this is logically private to the crate
+/// and will prevent implementations from outside the crate
+pub trait Seal<T = ()> {}
+
 /// Trait implemented by arrays that can be SIMD types.
-#[doc(hidden)]
-pub trait SimdArray {
+pub trait SimdArray: Seal {
     /// The type of the #[repr(simd)] type.
     type Tuple: Copy + Clone;
     /// The element type of the vector.
     type T;
     /// The number of elements in the array.
     const N: usize;
     /// The type: `[u32; Self::N]`.
     type NT;
 }
 
 /// This traits is used to constraint the arguments
 /// and result type of the portable shuffles.
 #[doc(hidden)]
-pub trait Shuffle<Lanes> {
+pub trait Shuffle<Lanes>: Seal<Lanes> {
     // Lanes is a `[u32; N]` where `N` is the number of vector lanes
 
     /// The result type of the shuffle.
     type Output;
 }
 
 /// This trait is implemented by all SIMD vector types.
-#[doc(hidden)]
-pub trait Simd {
+pub trait Simd: Seal {
     /// Element type of the SIMD vector
     type Element;
     /// The number of elements in the SIMD vector.
     const LANES: usize;
     /// The type: `[u32; Self::N]`.
     type LanesType;
 }
 
 /// This trait is implemented by all mask types
-#[doc(hidden)]
-pub trait Mask {
+pub trait Mask: Seal {
     fn test(&self) -> bool;
 }
diff --git a/third_party/rust/packed_simd/src/testing/utils.rs b/third_party/rust/packed_simd/src/testing/utils.rs
--- a/third_party/rust/packed_simd/src/testing/utils.rs
+++ b/third_party/rust/packed_simd/src/testing/utils.rs
@@ -1,11 +1,13 @@
 //! Testing utilities
 
 #![allow(dead_code)]
+// FIXME: Or don't. But it's true this is a problematic comparison.
+#![allow(clippy::neg_cmp_op_on_partial_ord)]
 
 use crate::{cmp::PartialOrd, fmt::Debug, LexicographicallyOrdered};
 
 /// Tests PartialOrd for `a` and `b` where `a < b` is true.
 pub fn test_lt<T>(
     a: LexicographicallyOrdered<T>, b: LexicographicallyOrdered<T>,
 ) where
     LexicographicallyOrdered<T>: Debug + PartialOrd,
@@ -14,37 +16,42 @@ pub fn test_lt<T>(
     assert!(b > a, "{:?}, {:?}", a, b);
 
     assert!(!(a == b), "{:?}, {:?}", a, b);
     assert!(a != b, "{:?}, {:?}", a, b);
 
     assert!(a <= b, "{:?}, {:?}", a, b);
     assert!(b >= a, "{:?}, {:?}", a, b);
 
-    // Irreflexivity
-    assert!(!(a < a), "{:?}, {:?}", a, b);
-    assert!(!(b < b), "{:?}, {:?}", a, b);
-    assert!(!(a > a), "{:?}, {:?}", a, b);
-    assert!(!(b > b), "{:?}, {:?}", a, b);
+    // The elegance of the mathematical expression of irreflexivity is more
+    // than clippy can handle.
+    #[allow(clippy::eq_op)]
+    {
+        // Irreflexivity
+        assert!(!(a < a), "{:?}, {:?}", a, b);
+        assert!(!(b < b), "{:?}, {:?}", a, b);
+        assert!(!(a > a), "{:?}, {:?}", a, b);
+        assert!(!(b > b), "{:?}, {:?}", a, b);
 
-    assert!(a <= a, "{:?}, {:?}", a, b);
-    assert!(b <= b, "{:?}, {:?}", a, b);
+        assert!(a <= a, "{:?}, {:?}", a, b);
+        assert!(b <= b, "{:?}, {:?}", a, b);
+    }
 }
 
 /// Tests PartialOrd for `a` and `b` where `a <= b` is true.
 pub fn test_le<T>(
     a: LexicographicallyOrdered<T>, b: LexicographicallyOrdered<T>,
 ) where
     LexicographicallyOrdered<T>: Debug + PartialOrd,
 {
     assert!(a <= b, "{:?}, {:?}", a, b);
     assert!(b >= a, "{:?}, {:?}", a, b);
 
-    assert!(a == b || a < b, "{:?}, {:?}", a, b);
-    assert!(a == b || b > a, "{:?}, {:?}", a, b);
+    assert!(a <= b, "{:?}, {:?}", a, b);
+    assert!(b >= a, "{:?}, {:?}", a, b);
 
     if a == b {
         assert!(!(a < b), "{:?}, {:?}", a, b);
         assert!(!(b > a), "{:?}, {:?}", a, b);
 
         assert!(!(a != b), "{:?}, {:?}", a, b);
     } else {
         assert!(a != b, "{:?}, {:?}", a, b);
diff --git a/third_party/rust/packed_simd/src/v128.rs b/third_party/rust/packed_simd/src/v128.rs
--- a/third_party/rust/packed_simd/src/v128.rs
+++ b/third_party/rust/packed_simd/src/v128.rs
@@ -1,80 +1,80 @@
 //! 128-bit wide vector types
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 use crate::*;
 
-impl_i!([i8; 16]: i8x16, m8x16 | i8 | test_v128 |
+impl_i!([i8; 16]: i8x16, m8x16 | i8, u16 | test_v128 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 |
         From: |
         /// A 128-bit vector with 16 `i8` lanes.
 );
-impl_u!([u8; 16]: u8x16, m8x16 | u8 | test_v128 |
+impl_u!([u8; 16]: u8x16, m8x16 | u8, u16 | test_v128 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 |
         From: |
         /// A 128-bit vector with 16 `u8` lanes.
 );
-impl_m!([m8; 16]: m8x16 | i8 | test_v128 |
+impl_m!([m8; 16]: m8x16 | i8, u16 | test_v128 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 |
         From: m16x16 |
         /// A 128-bit vector mask with 16 `m8` lanes.
 );
 
-impl_i!([i16; 8]: i16x8, m16x8 | i16 | test_v128 | x0, x1, x2, x3, x4, x5, x6, x7 |
+impl_i!([i16; 8]: i16x8, m16x8 | i16, u8 | test_v128 | x0, x1, x2, x3, x4, x5, x6, x7 |
         From: i8x8, u8x8 |
         /// A 128-bit vector with 8 `i16` lanes.
 );
-impl_u!([u16; 8]: u16x8, m16x8 | u16| test_v128 | x0, x1, x2, x3, x4, x5, x6, x7 |
+impl_u!([u16; 8]: u16x8, m16x8 | u16, u8 | test_v128 | x0, x1, x2, x3, x4, x5, x6, x7 |
         From: u8x8 |
         /// A 128-bit vector with 8 `u16` lanes.
 );
-impl_m!([m16; 8]: m16x8 | i16 | test_v128 | x0, x1, x2, x3, x4, x5, x6, x7 |
+impl_m!([m16; 8]: m16x8 | i16, u8 | test_v128 | x0, x1, x2, x3, x4, x5, x6, x7 |
         From: m8x8, m32x8 |
         /// A 128-bit vector mask with 8 `m16` lanes.
 );
 
-impl_i!([i32; 4]: i32x4, m32x4 | i32 | test_v128 | x0, x1, x2, x3 |
+impl_i!([i32; 4]: i32x4, m32x4 | i32, u8 | test_v128 | x0, x1, x2, x3 |
         From: i8x4, u8x4, i16x4, u16x4  |
         /// A 128-bit vector with 4 `i32` lanes.
 );
-impl_u!([u32; 4]: u32x4, m32x4 | u32| test_v128 | x0, x1, x2, x3 |
+impl_u!([u32; 4]: u32x4, m32x4 | u32, u8 | test_v128 | x0, x1, x2, x3 |
         From: u8x4, u16x4 |
         /// A 128-bit vector with 4 `u32` lanes.
 );
 impl_f!([f32; 4]: f32x4, m32x4 | f32 | test_v128 | x0, x1, x2, x3 |
         From: i8x4, u8x4, i16x4, u16x4 |
         /// A 128-bit vector with 4 `f32` lanes.
 );
-impl_m!([m32; 4]: m32x4 | i32 | test_v128 | x0, x1, x2, x3 |
+impl_m!([m32; 4]: m32x4 | i32, u8 | test_v128 | x0, x1, x2, x3 |
         From: m8x4, m16x4, m64x4 |
         /// A 128-bit vector mask with 4 `m32` lanes.
 );
 
-impl_i!([i64; 2]: i64x2, m64x2 | i64 | test_v128 | x0, x1 |
+impl_i!([i64; 2]: i64x2, m64x2 | i64, u8 | test_v128 | x0, x1 |
         From: i8x2, u8x2, i16x2, u16x2, i32x2, u32x2 |
         /// A 128-bit vector with 2 `i64` lanes.
 );
-impl_u!([u64; 2]: u64x2, m64x2 | u64 | test_v128 | x0, x1 |
+impl_u!([u64; 2]: u64x2, m64x2 | u64, u8 | test_v128 | x0, x1 |
         From: u8x2, u16x2, u32x2 |
         /// A 128-bit vector with 2 `u64` lanes.
 );
 impl_f!([f64; 2]: f64x2, m64x2 | f64 | test_v128 | x0, x1 |
         From: i8x2, u8x2, i16x2, u16x2, i32x2, u32x2, f32x2 |
         /// A 128-bit vector with 2 `f64` lanes.
 );
-impl_m!([m64; 2]: m64x2 | i64 | test_v128 | x0, x1 |
+impl_m!([m64; 2]: m64x2 | i64, u8 | test_v128 | x0, x1 |
         From: m8x2, m16x2, m32x2, m128x2 |
         /// A 128-bit vector mask with 2 `m64` lanes.
 );
 
-impl_i!([i128; 1]: i128x1, m128x1 | i128 | test_v128 | x0 |
+impl_i!([i128; 1]: i128x1, m128x1 | i128, u8 | test_v128 | x0 |
         From: /*i8x1, u8x1, i16x1, u16x1, i32x1, u32x1, i64x1, u64x1 */ | // FIXME: unary small vector types
         /// A 128-bit vector with 1 `i128` lane.
 );
-impl_u!([u128; 1]: u128x1, m128x1 | u128 | test_v128 | x0 |
+impl_u!([u128; 1]: u128x1, m128x1 | u128, u8 | test_v128 | x0 |
         From: /*u8x1, u16x1, u32x1, u64x1 */ | // FIXME: unary small vector types
         /// A 128-bit vector with 1 `u128` lane.
 );
-impl_m!([m128; 1]: m128x1 | i128 | test_v128 | x0 |
+impl_m!([m128; 1]: m128x1 | i128, u8 | test_v128 | x0 |
         From: /*m8x1, m16x1, m32x1, m64x1 */ | // FIXME: unary small vector types
         /// A 128-bit vector mask with 1 `m128` lane.
 );
diff --git a/third_party/rust/packed_simd/src/v16.rs b/third_party/rust/packed_simd/src/v16.rs
--- a/third_party/rust/packed_simd/src/v16.rs
+++ b/third_party/rust/packed_simd/src/v16.rs
@@ -1,16 +1,16 @@
 //! 16-bit wide vector types
 
 use crate::*;
 
-impl_i!([i8; 2]: i8x2, m8x2 | i8 | test_v16 | x0, x1 |
+impl_i!([i8; 2]: i8x2, m8x2 | i8, u8 | test_v16 | x0, x1 |
         From: |
         /// A 16-bit vector with 2 `i8` lanes.
 );
-impl_u!([u8; 2]: u8x2, m8x2 | u8 | test_v16 | x0, x1 |
+impl_u!([u8; 2]: u8x2, m8x2 | u8, u8 | test_v16 | x0, x1 |
         From: |
         /// A 16-bit vector with 2 `u8` lanes.
 );
-impl_m!([m8; 2]: m8x2 | i8 | test_v16 | x0, x1 |
+impl_m!([m8; 2]: m8x2 | i8, u8 | test_v16 | x0, x1 |
         From: m16x2, m32x2, m64x2, m128x2 |
         /// A 16-bit vector mask with 2 `m8` lanes.
 );
diff --git a/third_party/rust/packed_simd/src/v256.rs b/third_party/rust/packed_simd/src/v256.rs
--- a/third_party/rust/packed_simd/src/v256.rs
+++ b/third_party/rust/packed_simd/src/v256.rs
@@ -1,86 +1,86 @@
 //! 256-bit wide vector types
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 use crate::*;
 
-impl_i!([i8; 32]: i8x32, m8x32 | i8 | test_v256 |
+impl_i!([i8; 32]: i8x32, m8x32 | i8, u32 | test_v256 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15,
         x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31 |
         From: |
         /// A 256-bit vector with 32 `i8` lanes.
 );
-impl_u!([u8; 32]: u8x32, m8x32 | u8 | test_v256 |
+impl_u!([u8; 32]: u8x32, m8x32 | u8, u32 | test_v256 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15,
         x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31 |
         From: |
         /// A 256-bit vector with 32 `u8` lanes.
 );
-impl_m!([m8; 32]: m8x32 | i8 | test_v256 |
+impl_m!([m8; 32]: m8x32 | i8, u32 | test_v256 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15,
         x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31 |
         From:  |
         /// A 256-bit vector mask with 32 `m8` lanes.
 );
 
-impl_i!([i16; 16]: i16x16, m16x16 | i16 | test_v256 |
+impl_i!([i16; 16]: i16x16, m16x16 | i16, u16 | test_v256 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 |
         From: i8x16, u8x16 |
         /// A 256-bit vector with 16 `i16` lanes.
 );
-impl_u!([u16; 16]: u16x16, m16x16 | u16 | test_v256 |
+impl_u!([u16; 16]: u16x16, m16x16 | u16, u16 | test_v256 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 |
         From: u8x16 |
         /// A 256-bit vector with 16 `u16` lanes.
 );
-impl_m!([m16; 16]: m16x16 | i16 | test_v256 |
+impl_m!([m16; 16]: m16x16 | i16, u16 | test_v256 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 |
         From: m8x16 |
         /// A 256-bit vector mask with 16 `m16` lanes.
 );
 
-impl_i!([i32; 8]: i32x8, m32x8 | i32 | test_v256 | x0, x1, x2, x3, x4, x5, x6, x7  |
+impl_i!([i32; 8]: i32x8, m32x8 | i32, u8 | test_v256 | x0, x1, x2, x3, x4, x5, x6, x7  |
         From: i8x8, u8x8, i16x8, u16x8 |
         /// A 256-bit vector with 8 `i32` lanes.
 );
-impl_u!([u32; 8]: u32x8, m32x8 | u32 | test_v256 | x0, x1, x2, x3, x4, x5, x6, x7 |
+impl_u!([u32; 8]: u32x8, m32x8 | u32, u8 | test_v256 | x0, x1, x2, x3, x4, x5, x6, x7 |
         From: u8x8, u16x8 |
         /// A 256-bit vector with 8 `u32` lanes.
 );
 impl_f!([f32; 8]: f32x8, m32x8 | f32 | test_v256 | x0, x1, x2, x3, x4, x5, x6, x7 |
         From: i8x8, u8x8, i16x8, u16x8 |
         /// A 256-bit vector with 8 `f32` lanes.
 );
-impl_m!([m32; 8]: m32x8 | i32 | test_v256 | x0, x1, x2, x3, x4, x5, x6, x7 |
+impl_m!([m32; 8]: m32x8 | i32, u8 | test_v256 | x0, x1, x2, x3, x4, x5, x6, x7 |
         From: m8x8, m16x8 |
         /// A 256-bit vector mask with 8 `m32` lanes.
 );
 
-impl_i!([i64; 4]: i64x4, m64x4 | i64 | test_v256 | x0, x1, x2, x3 |
+impl_i!([i64; 4]: i64x4, m64x4 | i64, u8 | test_v256 | x0, x1, x2, x3 |
         From: i8x4, u8x4, i16x4, u16x4, i32x4, u32x4 |
         /// A 256-bit vector with 4 `i64` lanes.
 );
-impl_u!([u64; 4]: u64x4, m64x4 | u64 | test_v256 | x0, x1, x2, x3 |
+impl_u!([u64; 4]: u64x4, m64x4 | u64, u8 | test_v256 | x0, x1, x2, x3 |
         From: u8x4, u16x4, u32x4 |
         /// A 256-bit vector with 4 `u64` lanes.
 );
 impl_f!([f64; 4]: f64x4, m64x4 | f64 | test_v256 | x0, x1, x2, x3 |
         From: i8x4, u8x4, i16x4, u16x4, i32x4, u32x4, f32x4 |
         /// A 256-bit vector with 4 `f64` lanes.
 );
-impl_m!([m64; 4]: m64x4 | i64 | test_v256 | x0, x1, x2, x3 |
+impl_m!([m64; 4]: m64x4 | i64, u8 | test_v256 | x0, x1, x2, x3 |
         From: m8x4, m16x4, m32x4 |
         /// A 256-bit vector mask with 4 `m64` lanes.
 );
 
-impl_i!([i128; 2]: i128x2, m128x2 | i128 | test_v256 | x0, x1 |
+impl_i!([i128; 2]: i128x2, m128x2 | i128, u8 | test_v256 | x0, x1 |
         From: i8x2, u8x2, i16x2, u16x2, i32x2, u32x2, i64x2, u64x2 |
         /// A 256-bit vector with 2 `i128` lanes.
 );
-impl_u!([u128; 2]: u128x2, m128x2 | u128 | test_v256 | x0, x1 |
+impl_u!([u128; 2]: u128x2, m128x2 | u128, u8 | test_v256 | x0, x1 |
         From: u8x2, u16x2, u32x2, u64x2 |
         /// A 256-bit vector with 2 `u128` lanes.
 );
-impl_m!([m128; 2]: m128x2 | i128 | test_v256 | x0, x1 |
+impl_m!([m128; 2]: m128x2 | i128, u8 | test_v256 | x0, x1 |
         From: m8x2, m16x2, m32x2, m64x2 |
         /// A 256-bit vector mask with 2 `m128` lanes.
 );
diff --git a/third_party/rust/packed_simd/src/v32.rs b/third_party/rust/packed_simd/src/v32.rs
--- a/third_party/rust/packed_simd/src/v32.rs
+++ b/third_party/rust/packed_simd/src/v32.rs
@@ -1,29 +1,29 @@
 //! 32-bit wide vector types
 
 use crate::*;
 
-impl_i!([i8; 4]: i8x4, m8x4 | i8 | test_v32 | x0, x1, x2, x3 |
+impl_i!([i8; 4]: i8x4, m8x4 | i8, u8 | test_v32 | x0, x1, x2, x3 |
         From: |
         /// A 32-bit vector with 4 `i8` lanes.
 );
-impl_u!([u8; 4]: u8x4, m8x4 | u8 | test_v32 | x0, x1, x2, x3 |
+impl_u!([u8; 4]: u8x4, m8x4 | u8, u8 | test_v32 | x0, x1, x2, x3 |
         From: |
         /// A 32-bit vector with 4 `u8` lanes.
 );
-impl_m!([m8; 4]: m8x4 | i8 | test_v32 | x0, x1, x2, x3 |
+impl_m!([m8; 4]: m8x4 | i8, u8 | test_v32 | x0, x1, x2, x3 |
         From: m16x4, m32x4, m64x4 |
         /// A 32-bit vector mask with 4 `m8` lanes.
 );
 
-impl_i!([i16; 2]: i16x2, m16x2 | i16 | test_v32 | x0, x1 |
+impl_i!([i16; 2]: i16x2, m16x2 | i16, u8 | test_v32 | x0, x1 |
         From: i8x2, u8x2 |
         /// A 32-bit vector with 2 `i16` lanes.
 );
-impl_u!([u16; 2]: u16x2, m16x2 | u16 | test_v32 | x0, x1 |
+impl_u!([u16; 2]: u16x2, m16x2 | u16, u8 | test_v32 | x0, x1 |
         From: u8x2 |
         /// A 32-bit vector with 2 `u16` lanes.
 );
-impl_m!([m16; 2]: m16x2 | i16 | test_v32 | x0, x1 |
+impl_m!([m16; 2]: m16x2 | i16, u8 | test_v32 | x0, x1 |
         From: m8x2, m32x2, m64x2, m128x2 |
         /// A 32-bit vector mask with 2 `m16` lanes.
 );
diff --git a/third_party/rust/packed_simd/src/v512.rs b/third_party/rust/packed_simd/src/v512.rs
--- a/third_party/rust/packed_simd/src/v512.rs
+++ b/third_party/rust/packed_simd/src/v512.rs
@@ -1,99 +1,99 @@
 //! 512-bit wide vector types
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 use crate::*;
 
-impl_i!([i8; 64]: i8x64, m8x64 | i8 | test_v512 |
+impl_i!([i8; 64]: i8x64, m8x64 | i8, u64 | test_v512 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15,
         x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31,
         x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47,
         x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61, x62, x63 |
         From: |
         /// A 512-bit vector with 64 `i8` lanes.
 );
-impl_u!([u8; 64]: u8x64, m8x64 | u8 | test_v512 |
+impl_u!([u8; 64]: u8x64, m8x64 | u8, u64 | test_v512 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15,
         x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31,
         x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47,
         x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61, x62, x63 |
         From: |
         /// A 512-bit vector with 64 `u8` lanes.
 );
-impl_m!([m8; 64]: m8x64 | i8 | test_v512 |
+impl_m!([m8; 64]: m8x64 | i8, u64 | test_v512 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15,
         x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31,
         x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47,
         x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61, x62, x63 |
         From:  |
         /// A 512-bit vector mask with 64 `m8` lanes.
 );
 
-impl_i!([i16; 32]: i16x32, m16x32 | i16 | test_v512 |
+impl_i!([i16; 32]: i16x32, m16x32 | i16, u32 | test_v512 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15,
         x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31 |
         From: i8x32, u8x32 |
         /// A 512-bit vector with 32 `i16` lanes.
 );
-impl_u!([u16; 32]: u16x32, m16x32 | u16 | test_v512 |
+impl_u!([u16; 32]: u16x32, m16x32 | u16, u32 | test_v512 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15,
         x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31 |
         From: u8x32 |
         /// A 512-bit vector with 32 `u16` lanes.
 );
-impl_m!([m16; 32]: m16x32 | i16 | test_v512 |
+impl_m!([m16; 32]: m16x32 | i16, u32 | test_v512 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15,
         x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31 |
         From: m8x32 |
         /// A 512-bit vector mask with 32 `m16` lanes.
 );
 
-impl_i!([i32; 16]: i32x16, m32x16 | i32 | test_v512 |
+impl_i!([i32; 16]: i32x16, m32x16 | i32, u16 | test_v512 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 |
         From: i8x16, u8x16, i16x16, u16x16 |
         /// A 512-bit vector with 16 `i32` lanes.
 );
-impl_u!([u32; 16]: u32x16, m32x16 | u32 | test_v512 |
+impl_u!([u32; 16]: u32x16, m32x16 | u32, u16 | test_v512 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 |
         From: u8x16, u16x16 |
         /// A 512-bit vector with 16 `u32` lanes.
 );
 impl_f!([f32; 16]: f32x16, m32x16 | f32 | test_v512 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 |
         From: i8x16, u8x16, i16x16, u16x16 |
         /// A 512-bit vector with 16 `f32` lanes.
 );
-impl_m!([m32; 16]: m32x16 | i32 | test_v512 |
+impl_m!([m32; 16]: m32x16 | i32, u16 | test_v512 |
         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 |
         From: m8x16, m16x16 |
         /// A 512-bit vector mask with 16 `m32` lanes.
 );
 
-impl_i!([i64; 8]: i64x8, m64x8 | i64 | test_v512 | x0, x1, x2, x3, x4, x5, x6, x7 |
+impl_i!([i64; 8]: i64x8, m64x8 | i64, u8 | test_v512 | x0, x1, x2, x3, x4, x5, x6, x7 |
         From: i8x8, u8x8, i16x8, u16x8, i32x8, u32x8 |
         /// A 512-bit vector with 8 `i64` lanes.
 );
-impl_u!([u64; 8]: u64x8, m64x8 | u64 | test_v512 | x0, x1, x2, x3, x4, x5, x6, x7 |
+impl_u!([u64; 8]: u64x8, m64x8 | u64, u8 | test_v512 | x0, x1, x2, x3, x4, x5, x6, x7 |
         From: u8x8, u16x8, u32x8 |
         /// A 512-bit vector with 8 `u64` lanes.
 );
 impl_f!([f64; 8]: f64x8, m64x8 | f64 | test_v512 | x0, x1, x2, x3, x4, x5, x6, x7 |
         From: i8x8, u8x8, i16x8, u16x8, i32x8, u32x8, f32x8 |
         /// A 512-bit vector with 8 `f64` lanes.
 );
-impl_m!([m64; 8]: m64x8 | i64 | test_v512 | x0, x1, x2, x3, x4, x5, x6, x7 |
+impl_m!([m64; 8]: m64x8 | i64, u8 | test_v512 | x0, x1, x2, x3, x4, x5, x6, x7 |
         From: m8x8, m16x8, m32x8 |
         /// A 512-bit vector mask with 8 `m64` lanes.
 );
 
-impl_i!([i128; 4]: i128x4, m128x4 | i128 | test_v512 | x0, x1, x2, x3 |
+impl_i!([i128; 4]: i128x4, m128x4 | i128, u8 | test_v512 | x0, x1, x2, x3 |
         From: i8x4, u8x4, i16x4, u16x4, i32x4, u32x4, i64x4, u64x4 |
         /// A 512-bit vector with 4 `i128` lanes.
 );
-impl_u!([u128; 4]: u128x4, m128x4 | u128 | test_v512 | x0, x1, x2, x3 |
+impl_u!([u128; 4]: u128x4, m128x4 | u128, u8 | test_v512 | x0, x1, x2, x3 |
         From: u8x4, u16x4, u32x4, u64x4 |
         /// A 512-bit vector with 4 `u128` lanes.
 );
-impl_m!([m128; 4]: m128x4 | i128 | test_v512 | x0, x1, x2, x3 |
+impl_m!([m128; 4]: m128x4 | i128, u8 | test_v512 | x0, x1, x2, x3 |
         From: m8x4, m16x4, m32x4, m64x4 |
         /// A 512-bit vector mask with 4 `m128` lanes.
 );
diff --git a/third_party/rust/packed_simd/src/v64.rs b/third_party/rust/packed_simd/src/v64.rs
--- a/third_party/rust/packed_simd/src/v64.rs
+++ b/third_party/rust/packed_simd/src/v64.rs
@@ -1,66 +1,66 @@
 //! 64-bit wide vector types
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 use super::*;
 
-impl_i!([i8; 8]: i8x8, m8x8 | i8 | test_v64 | x0, x1, x2, x3, x4, x5, x6, x7 |
+impl_i!([i8; 8]: i8x8, m8x8 | i8, u8 | test_v64 | x0, x1, x2, x3, x4, x5, x6, x7 |
         From: |
         /// A 64-bit vector with 8 `i8` lanes.
 );
-impl_u!([u8; 8]: u8x8, m8x8 | u8 | test_v64 | x0, x1, x2, x3, x4, x5, x6, x7 |
+impl_u!([u8; 8]: u8x8, m8x8 | u8, u8 | test_v64 | x0, x1, x2, x3, x4, x5, x6, x7 |
         From: |
         /// A 64-bit vector with 8 `u8` lanes.
 );
-impl_m!([m8; 8]: m8x8 | i8 | test_v64 | x0, x1, x2, x3, x4, x5, x6, x7 |
+impl_m!([m8; 8]: m8x8 | i8, u8 | test_v64 | x0, x1, x2, x3, x4, x5, x6, x7 |
         From: m16x8, m32x8 |
         /// A 64-bit vector mask with 8 `m8` lanes.
 );
 
-impl_i!([i16; 4]: i16x4, m16x4 | i16 | test_v64 | x0, x1, x2, x3 |
+impl_i!([i16; 4]: i16x4, m16x4 | i16, u8 | test_v64 | x0, x1, x2, x3 |
         From: i8x4, u8x4 |
         /// A 64-bit vector with 4 `i16` lanes.
 );
-impl_u!([u16; 4]: u16x4, m16x4 | u16 | test_v64 | x0, x1, x2, x3 |
+impl_u!([u16; 4]: u16x4, m16x4 | u16, u8 | test_v64 | x0, x1, x2, x3 |
         From: u8x4 |
         /// A 64-bit vector with 4 `u16` lanes.
 );
-impl_m!([m16; 4]: m16x4 | i16 | test_v64 | x0, x1, x2, x3 |
+impl_m!([m16; 4]: m16x4 | i16, u8 | test_v64 | x0, x1, x2, x3 |
         From: m8x4, m32x4, m64x4 |
         /// A 64-bit vector mask with 4 `m16` lanes.
 );
 
-impl_i!([i32; 2]: i32x2, m32x2 | i32 | test_v64 | x0, x1 |
+impl_i!([i32; 2]: i32x2, m32x2 | i32, u8 | test_v64 | x0, x1 |
         From: i8x2, u8x2, i16x2, u16x2 |
         /// A 64-bit vector with 2 `i32` lanes.
 );
-impl_u!([u32; 2]: u32x2, m32x2 | u32 | test_v64 | x0, x1 |
+impl_u!([u32; 2]: u32x2, m32x2 | u32, u8 | test_v64 | x0, x1 |
         From: u8x2, u16x2 |
         /// A 64-bit vector with 2 `u32` lanes.
 );
-impl_m!([m32; 2]: m32x2 | i32 | test_v64 | x0, x1 |
+impl_m!([m32; 2]: m32x2 | i32, u8 | test_v64 | x0, x1 |
         From: m8x2, m16x2, m64x2, m128x2 |
         /// A 64-bit vector mask with 2 `m32` lanes.
 );
 impl_f!([f32; 2]: f32x2, m32x2 | f32 | test_v64 | x0, x1 |
         From: i8x2, u8x2, i16x2, u16x2 |
         /// A 64-bit vector with 2 `f32` lanes.
 );
 
 /*
-impl_i!([i64; 1]: i64x1, m64x1 | i64 | test_v64 | x0 |
+impl_i!([i64; 1]: i64x1, m64x1 | i64, u8 | test_v64 | x0 |
         From: /*i8x1, u8x1, i16x1, u16x1, i32x1, u32x1*/ |  // FIXME: primitive to vector conversion
         /// A 64-bit vector with 1 `i64` lanes.
 );
-impl_u!([u64; 1]: u64x1, m64x1 | u64 | test_v64 | x0 |
+impl_u!([u64; 1]: u64x1, m64x1 | u64, u8 | test_v64 | x0 |
         From: /*u8x1, u16x1, u32x1*/ | // FIXME: primitive to vector conversion
         /// A 64-bit vector with 1 `u64` lanes.
 );
-impl_m!([m64; 1]: m64x1 | i64 | test_v64 | x0 |
+impl_m!([m64; 1]: m64x1 | i64, u8 | test_v64 | x0 |
         From: /*m8x1, m16x1, m32x1, */ m128x1 | // FIXME: unary small vector types
         /// A 64-bit vector mask with 1 `m64` lanes.
 );
 impl_f!([f64; 1]: f64x1, m64x1 | f64 | test_v64 | x0 |
         From: /*i8x1, u8x1, i16x1, u16x1, i32x1, u32x1, f32x1*/ | // FIXME: unary small vector types
         /// A 64-bit vector with 1 `f64` lanes.
 );
 */
diff --git a/third_party/rust/packed_simd/src/vPtr.rs b/third_party/rust/packed_simd/src/vPtr.rs
--- a/third_party/rust/packed_simd/src/vPtr.rs
+++ b/third_party/rust/packed_simd/src/vPtr.rs
@@ -1,10 +1,10 @@
 //! Vectors of pointers
-#![rustfmt::skip]
+#[rustfmt::skip]
 
 use crate::*;
 
 impl_const_p!(
     [*const T; 2]: cptrx2, msizex2, usizex2, isizex2 | test_v128 | x0, x1 | From: |
     /// A vector with 2 `*const T` lanes
 );
 
diff --git a/third_party/rust/packed_simd/src/vSize.rs b/third_party/rust/packed_simd/src/vSize.rs
--- a/third_party/rust/packed_simd/src/vSize.rs
+++ b/third_party/rust/packed_simd/src/vSize.rs
@@ -1,53 +1,53 @@
 //! Vectors with pointer-sized elements
 
 use crate::codegen::pointer_sized_int::{isize_, usize_};
 use crate::*;
 
-impl_i!([isize; 2]: isizex2, msizex2 | isize_ | test_v128 |
+impl_i!([isize; 2]: isizex2, msizex2 | isize_, u8 | test_v128 |
         x0, x1|
         From: |
         /// A vector with 2 `isize` lanes.
 );
 
-impl_u!([usize; 2]: usizex2, msizex2 | usize_ | test_v128 |
+impl_u!([usize; 2]: usizex2, msizex2 | usize_, u8 | test_v128 |
         x0, x1|
         From: |
         /// A vector with 2 `usize` lanes.
 );
-impl_m!([msize; 2]: msizex2 | isize_ | test_v128 |
+impl_m!([msize; 2]: msizex2 | isize_, u8 | test_v128 |
         x0, x1 |
         From: |
         /// A vector mask with 2 `msize` lanes.
 );
 
-impl_i!([isize; 4]: isizex4, msizex4 | isize_ | test_v256 |
+impl_i!([isize; 4]: isizex4, msizex4 | isize_, u8 | test_v256 |
         x0, x1, x2, x3 |
         From: |
         /// A vector with 4 `isize` lanes.
 );
-impl_u!([usize; 4]: usizex4, msizex4 | usize_ | test_v256 |
+impl_u!([usize; 4]: usizex4, msizex4 | usize_, u8 | test_v256 |
         x0, x1, x2, x3|
         From: |
         /// A vector with 4 `usize` lanes.
 );
-impl_m!([msize; 4]: msizex4 | isize_ | test_v256 |
+impl_m!([msize; 4]: msizex4 | isize_, u8 | test_v256 |
         x0, x1, x2, x3 |
         From: |
         /// A vector mask with 4 `msize` lanes.
 );
 
-impl_i!([isize; 8]: isizex8, msizex8 | isize_ | test_v512 |
+impl_i!([isize; 8]: isizex8, msizex8 | isize_, u8 | test_v512 |
         x0, x1, x2, x3, x4, x5, x6, x7 |
         From: |
-        /// A vector with 4 `isize` lanes.
+        /// A vector with 8 `isize` lanes.
 );
-impl_u!([usize; 8]: usizex8, msizex8 | usize_ | test_v512 |
+impl_u!([usize; 8]: usizex8, msizex8 | usize_, u8 | test_v512 |
         x0, x1, x2, x3, x4, x5, x6, x7 |
         From: |
         /// A vector with 8 `usize` lanes.
 );
-impl_m!([msize; 8]: msizex8 | isize_ | test_v512 |
+impl_m!([msize; 8]: msizex8 | isize_, u8 | test_v512 |
         x0, x1, x2, x3, x4, x5, x6, x7 |
         From: |
         /// A vector mask with 8 `msize` lanes.
 );
diff --git a/third_party/rust/packed_simd/tests/endianness.rs b/third_party/rust/packed_simd/tests/endianness.rs
--- a/third_party/rust/packed_simd/tests/endianness.rs
+++ b/third_party/rust/packed_simd/tests/endianness.rs
@@ -12,51 +12,51 @@ fn endian_indexing() {
     assert_eq!(v.extract(1), 1);
     assert_eq!(v.extract(2), 2);
     assert_eq!(v.extract(3), 3);
 }
 
 #[cfg_attr(not(target_arch = "wasm32"), test)]
 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
 fn endian_bitcasts() {
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     let x = i8x16::new(
         0, 1, 2, 3, 4, 5, 6, 7,
         8, 9, 10, 11, 12, 13, 14, 15,
     );
     let t: i16x8 = unsafe { mem::transmute(x) };
     let e: i16x8 = if cfg!(target_endian = "little") {
         i16x8::new(256, 770, 1284, 1798, 2312, 2826, 3340, 3854)
     } else {
         i16x8::new(1, 515, 1029, 1543, 2057, 2571, 3085, 3599)
     };
     assert_eq!(t, e);
 }
 
 #[cfg_attr(not(target_arch = "wasm32"), test)]
 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
 fn endian_casts() {
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     let x = i8x16::new(
         0, 1, 2, 3, 4, 5, 6, 7,
         8, 9, 10, 11, 12, 13, 14, 15,
     );
     let t: i16x16 = x.into(); // simd_cast
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     let e = i16x16::new(
         0, 1, 2, 3, 4, 5, 6, 7,
         8, 9, 10, 11, 12, 13, 14, 15,
     );
     assert_eq!(t, e);
 }
 
 #[cfg_attr(not(target_arch = "wasm32"), test)]
 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
 fn endian_load_and_stores() {
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     let x = i8x16::new(
         0, 1, 2, 3, 4, 5, 6, 7,
         8, 9, 10, 11, 12, 13, 14, 15,
     );
     let mut y: [i16; 8] = [0; 8];
     x.write_to_slice_unaligned(unsafe {
         slice::from_raw_parts_mut(&mut y as *mut _ as *mut i8, 16)
     });
@@ -77,56 +77,61 @@ fn endian_load_and_stores() {
 #[cfg_attr(not(target_arch = "wasm32"), test)]
 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
 fn endian_array_union() {
     union A {
         data: [f32; 4],
         vec: f32x4,
     }
     let x: [f32; 4] = unsafe { A { vec: f32x4::new(0., 1., 2., 3.) }.data };
-    assert_eq!(x[0], 0_f32);
-    assert_eq!(x[1], 1_f32);
-    assert_eq!(x[2], 2_f32);
-    assert_eq!(x[3], 3_f32);
+    // As all of these are integer values within the mantissa^1 range, it
+    // would be very unusual for them to actually fail to compare.
+    #[allow(clippy::float_cmp)]
+    {
+        assert_eq!(x[0], 0_f32);
+        assert_eq!(x[1], 1_f32);
+        assert_eq!(x[2], 2_f32);
+        assert_eq!(x[3], 3_f32);
+    }
     let y: f32x4 = unsafe { A { data: [3., 2., 1., 0.] }.vec };
     assert_eq!(y, f32x4::new(3., 2., 1., 0.));
 
     union B {
         data: [i8; 16],
         vec: i8x16,
     }
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     let x = i8x16::new(
         0, 1, 2, 3, 4, 5, 6, 7,
         8, 9, 10, 11, 12, 13, 14, 15,
     );
     let x: [i8; 16] = unsafe { B { vec: x }.data };
 
-    for i in 0..16 {
-        assert_eq!(x[i], i as i8);
+    for (i, v) in x.iter().enumerate() {
+        assert_eq!(i as i8, *v);
     }
 
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     let y = [
         15, 14, 13, 12, 11, 19, 9, 8,
         7, 6, 5, 4, 3, 2, 1, 0
     ];
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     let e = i8x16::new(
         15, 14, 13, 12, 11, 19, 9, 8,
         7, 6, 5, 4, 3, 2, 1, 0
     );
     let z = unsafe { B { data: y }.vec };
     assert_eq!(z, e);
 
     union C {
         data: [i16; 8],
         vec: i8x16,
     }
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     let x = i8x16::new(
         0, 1, 2, 3, 4, 5, 6, 7,
         8, 9, 10, 11, 12, 13, 14, 15,
     );
     let x: [i16; 8] = unsafe { C { vec: x }.data };
 
     let e: [i16; 8] = if cfg!(target_endian = "little") {
         [256, 770, 1284, 1798, 2312, 2826, 3340, 3854]
@@ -140,31 +145,36 @@ fn endian_array_union() {
 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
 fn endian_tuple_access() {
     type F32x4T = (f32, f32, f32, f32);
     union A {
         data: F32x4T,
         vec: f32x4,
     }
     let x: F32x4T = unsafe { A { vec: f32x4::new(0., 1., 2., 3.) }.data };
-    assert_eq!(x.0, 0_f32);
-    assert_eq!(x.1, 1_f32);
-    assert_eq!(x.2, 2_f32);
-    assert_eq!(x.3, 3_f32);
+    // As all of these are integer values within the mantissa^1 range, it
+    // would be very unusual for them to actually fail to compare.
+    #[allow(clippy::float_cmp)]
+    {
+        assert_eq!(x.0, 0_f32);
+        assert_eq!(x.1, 1_f32);
+        assert_eq!(x.2, 2_f32);
+        assert_eq!(x.3, 3_f32);
+    }
     let y: f32x4 = unsafe { A { data: (3., 2., 1., 0.) }.vec };
     assert_eq!(y, f32x4::new(3., 2., 1., 0.));
 
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     type I8x16T = (i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8);
     union B {
         data: I8x16T,
         vec: i8x16,
     }
 
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     let x = i8x16::new(
         0, 1, 2, 3, 4, 5, 6, 7,
         8, 9, 10, 11, 12, 13, 14, 15,
     );
     let x: I8x16T = unsafe { B { vec: x }.data };
 
     assert_eq!(x.0, 0);
     assert_eq!(x.1, 1);
@@ -178,37 +188,37 @@ fn endian_tuple_access() {
     assert_eq!(x.9, 9);
     assert_eq!(x.10, 10);
     assert_eq!(x.11, 11);
     assert_eq!(x.12, 12);
     assert_eq!(x.13, 13);
     assert_eq!(x.14, 14);
     assert_eq!(x.15, 15);
 
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     let y = (
         15, 14, 13, 12, 11, 10, 9, 8,
         7, 6, 5, 4, 3, 2, 1, 0
     );
     let z: i8x16 = unsafe { B { data: y }.vec };
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     let e = i8x16::new(
         15, 14, 13, 12, 11, 10, 9, 8,
         7, 6, 5, 4, 3, 2, 1, 0
     );
     assert_eq!(e, z);
 
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     type I16x8T = (i16, i16, i16, i16, i16, i16, i16, i16);
     union C {
         data: I16x8T,
         vec: i8x16,
     }
 
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     let x = i8x16::new(
         0, 1, 2, 3, 4, 5, 6, 7,
         8, 9, 10, 11, 12, 13, 14, 15,
     );
     let x: I16x8T = unsafe { C { vec: x }.data };
 
     let e: [i16; 8] = if cfg!(target_endian = "little") {
         [256, 770, 1284, 1798, 2312, 2826, 3340, 3854]
@@ -219,28 +229,28 @@ fn endian_tuple_access() {
     assert_eq!(x.1, e[1]);
     assert_eq!(x.2, e[2]);
     assert_eq!(x.3, e[3]);
     assert_eq!(x.4, e[4]);
     assert_eq!(x.5, e[5]);
     assert_eq!(x.6, e[6]);
     assert_eq!(x.7, e[7]);
 
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     #[repr(C)]
     #[derive(Copy ,Clone)]
     pub struct Tup(pub i8, pub i8, pub i16, pub i8, pub i8, pub i16,
                    pub i8, pub i8, pub i16, pub i8, pub i8, pub i16);
 
     union D {
         data: Tup,
         vec: i8x16,
     }
 
-    #[cfg_attr(rustfmt, rustfmt_skip)]
+    #[rustfmt::skip]
     let x = i8x16::new(
         0, 1, 2, 3, 4, 5, 6, 7,
         8, 9, 10, 11, 12, 13, 14, 15,
     );
     let x: Tup = unsafe { D { vec: x }.data };
 
     let e: [i16; 12] = if cfg!(target_endian = "little") {
         [0, 1, 770, 4, 5, 1798, 8, 9, 2826, 12, 13, 3854]

