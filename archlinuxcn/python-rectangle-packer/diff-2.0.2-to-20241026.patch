diff --git a/Makefile b/Makefile
index eb82db9..e0f629f 100644
--- a/Makefile
+++ b/Makefile
@@ -36,11 +36,11 @@ benchmark:
 	$(PYTHON) -u -O misc/crunch.py --output-dir artifacts/$(VERSION)/data
 	$(PYTHON) -u misc/recstat.py --input-dir artifacts/$(VERSION)/data --output-dir artifacts/$(VERSION)/img
 
-# Build sphinx documentation: HTML + PDF
+# Build sphinx documentation: HTML
 # Not very nice, but use sed to update all versions in image urls
 doc: doc/*.rst doc/conf.py build
 	sed -i -E "s@$(IMG_HOST)/rpack/(.*)/img/@$(IMG_HOST)/rpack/$(VERSION)/img/@g" doc/*.rst rpack/__init__.py
-	cd doc && make html latexpdf
+	cd doc && make html
 
 # Remove non-VCS files
 clean:
diff --git a/README.rst b/README.rst
index b7a412b..dc373ae 100644
--- a/README.rst
+++ b/README.rst
@@ -64,7 +64,7 @@ area as small as possible (best effort).
     * The module name is **rpack** which is an abbreviation of the package
       name at PyPI (rectangle-packer).
 
-    * The computational time required by :py:func:`rpack.pack` increases by
+    * The computational time required by ``rpack.pack`` increases by
       the number *and* size of input rectangles.  If this becomes a problem,
       you might need to implement your own `divide-and-conquer algorithm`_.
 
@@ -74,13 +74,13 @@ Examples
 
 **Example A:**
 
-.. image:: https://penlect.com/rpack/2.0.1/img/packing_best_10.png
+.. figure:: https://penlect.com/rpack/2.0.2/img/packing_best_10.png
    :alt: pack10
    :align: center
 
 **Example B:**
 
-.. image:: https://penlect.com/rpack/2.0.1/img/packing_phi.png
+.. figure:: https://penlect.com/rpack/2.0.2/img/packing_phi.png
    :alt: packphi
    :align: center
 
@@ -88,7 +88,7 @@ Examples
 **Example C:** Sometimes the input rectangles simply cannot be packed in
 a good way. Here is an example of low packing density:
 
-.. image:: https://penlect.com/rpack/2.0.1/img/packing_worst_10.png
+.. figure:: https://penlect.com/rpack/2.0.2/img/packing_worst_10.png
    :alt: pack10bad
    :align: center
 
@@ -126,4 +126,4 @@ illustrates a solution to a problem discussed at stackoverflow_.
    :target: https://raw.githubusercontent.com/Penlect/rectangle-packer/travis/LICENSE.md
 
 .. |PyPI-Downloads| image:: https://img.shields.io/pypi/dm/rectangle-packer.svg
-   :target: https://pypi.org/project/rectangle-packer
+   :target: https://pypi.org/project/rectangle-packer
\ No newline at end of file
diff --git a/doc/algorithm.rst b/doc/algorithm.rst
index ee5e382..1f65597 100644
--- a/doc/algorithm.rst
+++ b/doc/algorithm.rst
@@ -1,4 +1,3 @@
-
 =============
 The Algorithm
 =============
@@ -26,17 +25,9 @@ by :py:func:`rpack.pack`.
 Extra grid lines have been added to the image below to demonstrate how
 these cells are created.
 
-.. only:: latex
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/example_grid.pdf
-     :alt: compute time
-     :align: center
-
-.. only:: html
-
-  .. figure:: https://penlect.com/rpack/2.0.1/img/example_grid.gif
-     :alt: compute time
-     :align: center
+.. figure:: https://penlect.com/rpack/2.0.2/img/example_grid.gif
+   :alt: compute time
+   :align: center
 
 The algorithm is not documented more than this yet. Until it is, you
 will have to study the files ``src/rpackcore.c`` and
diff --git a/doc/benchmarks.rst b/doc/benchmarks.rst
index 8b74009..9ceb2b8 100644
--- a/doc/benchmarks.rst
+++ b/doc/benchmarks.rst
@@ -1,4 +1,3 @@
-
 ==========
 Benchmarks
 ==========
@@ -23,32 +22,16 @@ generated by picking side lengths uniformly distributed in the
 interval [1, 1000].  If you are not familiar with boxplots, have a
 look at the `boxplot`_ article at Wikipedia for an introduction.
 
-.. only:: latex
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/packing_density_by_n.pdf
-     :alt: packing density
-     :align: center
-
-.. only:: html
-
-  .. figure:: https://penlect.com/rpack/2.0.1/img/packing_density_by_n.svg
-     :alt: packing density
-     :align: center
+.. figure:: https://penlect.com/rpack/2.0.2/img/packing_density_by_n.svg
+   :alt: packing density
+   :align: center
 
 The boxplot below shows how the packing density varies by rectangle side
 lengths.
 
-.. only:: latex
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/packing_density_by_m.pdf
-     :alt: packing density
-     :align: center
-
-.. only:: html
-
-  .. figure:: https://penlect.com/rpack/2.0.1/img/packing_density_by_m.svg
-     :alt: packing density
-     :align: center
+.. figure:: https://penlect.com/rpack/2.0.2/img/packing_density_by_m.svg
+   :alt: packing density
+   :align: center
 
 The scatter plot below shows how the minimal bounding box shape is
 distributed based on how many rectangles were packed. In all runs,
@@ -57,46 +40,21 @@ distributed in the interval [1, 1000]. It is interesting to note, that
 the minimal bounding box tends to be more extreme (very wide or very
 tall) when the number of rectangles increases.
 
-.. only:: latex
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/enclosing.pdf
-     :alt: enclosing
-     :align: center
-
-.. only:: html
-
-  .. figure:: https://penlect.com/rpack/2.0.1/img/enclosing.svg
-     :alt: enclosing
-     :align: center
+.. figure:: https://penlect.com/rpack/2.0.2/img/enclosing.svg
+   :alt: enclosing
+   :align: center
 
 Example of 100 rectangles, high packing density:
 
-
-.. only:: latex
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/packing_best_100.pdf
-     :alt: compute time
-     :align: center
-
-.. only:: html
-
-  .. figure:: https://penlect.com/rpack/2.0.1/img/packing_best_100.svg
-     :alt: compute time
-     :align: center
+.. figure:: https://penlect.com/rpack/2.0.2/img/packing_best_100.svg
+   :alt: compute time
+   :align: center
 
 Example of 100 rectangles, lower packing density:
 
-.. only:: latex
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/packing_worst_100.pdf
-     :alt: compute time
-     :align: center
-
-.. only:: html
-
-  .. figure:: https://penlect.com/rpack/2.0.1/img/packing_worst_100.svg
-     :alt: compute time
-     :align: center
+.. figure:: https://penlect.com/rpack/2.0.2/img/packing_worst_100.svg
+   :alt: compute time
+   :align: center
 
 
 Squares test
@@ -110,18 +68,9 @@ See this PDF, `squares.pdf`_, for packed squares 1x1, ..., NxN, for N =
 See Richard E. Korf's paper `Optimal Rectangle Packing: Initial
 Results`_ for the optimal solutions for all squares up to n=22.
 
-.. only:: latex
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/squares_summary.pdf
-     :alt: compute time
-     :align: center
-
-.. only:: html
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/squares_summary.svg
-     :alt: compute time
-     :align: center
-
+.. image:: https://penlect.com/rpack/2.0.2/img/squares_summary.svg
+   :alt: compute time
+   :align: center
 
 Circumference test
 ------------------
@@ -133,17 +82,9 @@ the same circumference. For exampe, N = 4, implies the rectangles 4x1,
 See this PDF, `circum.pdf`_, for packed rectangles Nx1, ..., 1xN, for
 N = 1, ..., 100. A summary is shown in the plot below.
 
-.. only:: latex
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/circum_summary.pdf
-     :alt: compute time
-     :align: center
-
-.. only:: html
-
-  .. figure:: https://penlect.com/rpack/2.0.1/img/circum_summary.svg
-     :alt: compute time
-     :align: center
+.. figure:: https://penlect.com/rpack/2.0.2/img/circum_summary.svg
+   :alt: compute time
+   :align: center
 
 Time complexity
 ===============
@@ -162,17 +103,9 @@ distributed side lengths in the interval [1, 1000]. The procedure was
 repeated several times and the vertical lines indicates the standard
 deviation.
 
-.. only:: latex
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/computation_time_by_m.pdf
-     :alt: compute time
-     :align: center
-
-.. only:: html
-
-  .. figure:: https://penlect.com/rpack/2.0.1/img/computation_time_by_m.svg
-     :alt: compute time
-     :align: center
+.. figure:: https://penlect.com/rpack/2.0.2/img/computation_time_by_m.svg
+   :alt: compute time
+   :align: center
 
 The figure below shows the increased computational cost when the
 number of rectangles are increased.  For each measurement point, a set
@@ -182,21 +115,13 @@ points, a qubic polynomial fits the data well (a quadratic does not).
 However, this is not a proof that the average complexety actually is
 O(n^3).
 
-.. only:: latex
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/computation_time_by_n.pdf
-     :alt: compute time
-     :align: center
-
-.. only:: html
-
-  .. figure:: https://penlect.com/rpack/2.0.1/img/computation_time_by_n.svg
-     :alt: compute time
-     :align: center
+.. figure:: https://penlect.com/rpack/2.0.2/img/computation_time_by_n.svg
+   :alt: compute time
+   :align: center
 
 
 .. _`Optimal Rectangle Packing: Initial Results`: https://www.aaai.org/Papers/ICAPS/2003/ICAPS03-029.pdf
 .. _`Optimal Rectangle Packing: An Absolute Placement Approach`: https://arxiv.org/pdf/1402.0557.pdf
 .. _boxplot: https://en.wikipedia.org/wiki/Box_plot
-.. _squares.pdf: https://penlect.com/rpack/2.0.1/img/squares.pdf
-.. _circum.pdf: https://penlect.com/rpack/2.0.1/img/circum.pdf
+.. _squares.pdf: https://penlect.com/rpack/2.0.2/img/squares.pdf
+.. _circum.pdf: https://penlect.com/rpack/2.0.2/img/circum.pdf
diff --git a/doc/conf.py b/doc/conf.py
index 599ecd7..bfc8e20 100644
--- a/doc/conf.py
+++ b/doc/conf.py
@@ -15,18 +15,18 @@
 import os
 import sys
 
-if 'RTD' not in os.environ:
+if "RTD" not in os.environ:
     # On Read the Docs the package will get "setup.py installed" and
     # then we don't want to mess with the Python path.
     # Make sure the RTD environment variable is set on Read the Docs.
-    sys.path.insert(0, os.path.abspath('..'))
+    sys.path.insert(0, os.path.abspath(".."))
 
 import rpack
 
 # -- Project information -----------------------------------------------------
 
-project = 'rectangle-packer'
-copyright = '2017, ' + rpack.__author__
+project = "rectangle-packer"
+copyright = "2017, " + rpack.__author__
 author = rpack.__author__
 
 # The full version, including alpha/beta/rc tags
@@ -37,7 +37,7 @@ version = release
 
 
 def module_docstr(app, what, name, obj, options, lines):
-    if what != 'module' or name != 'rpack':
+    if what != "module" or name != "rpack":
         return
     del lines[:2]
     del lines[3:7]  # Remove badges, svg doesn't work with latex
@@ -45,7 +45,8 @@ def module_docstr(app, what, name, obj, options, lines):
 
 def setup(app):
     from sphinx.ext.autodoc import cut_lines
-    app.connect('autodoc-process-docstring', module_docstr)
+
+    app.connect("autodoc-process-docstring", module_docstr)
 
 
 # -- General configuration ---------------------------------------------------
@@ -58,38 +59,43 @@ def setup(app):
 # extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
 # ones.
 extensions = [
-    'sphinx.ext.autodoc',
-    'sphinx.ext.doctest',
-    'sphinx.ext.imgmath',
-    'sphinx.ext.viewcode',
-    'sphinx.ext.imgmath',
-    'sphinx_rtd_theme'
-    # 'sphinx.ext.extlinks',
+    "sphinx.ext.autodoc",
+    "sphinx.ext.doctest",
+    "sphinx.ext.imgmath",
+    "sphinx.ext.viewcode",
+    "sphinx.ext.napoleon",  # Support for Google/NumPy style docstrings
+    "sphinx.ext.intersphinx",  # Link to other project's documentation
+    "sphinx_rtd_theme",
 ]
 
+# Intersphinx configuration
+intersphinx_mapping = {
+    "python": ("https://docs.python.org/3", None),
+}
+
 # Add any paths that contain templates here, relative to this directory.
-templates_path = ['_templates']
+templates_path = ["_templates"]
 
 # The suffix(es) of source filenames.
 # You can specify multiple suffix as a list of string:
 #
 # source_suffix = ['.rst', '.md']
-source_suffix = '.rst'
+source_suffix = ".rst"
 
 # The master toctree document.
-master_doc = 'index'
+master_doc = "index"
 
 # The language for content autogenerated by Sphinx. Refer to documentation
 # for a list of supported languages.
 #
 # This is also used if you do content translation via gettext catalogs.
 # Usually you set "language" from the command line for these cases.
-language = None
+language = "en"
 
 # List of patterns, relative to source directory, that match files and
 # directories to ignore when looking for source files.
 # This pattern also affects html_static_path and html_extra_path.
-exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']
+exclude_patterns = ["_build", "Thumbs.db", ".DS_Store"]
 
 
 # -- Options for HTML output -------------------------------------------------
@@ -97,45 +103,14 @@ exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']
 # The theme to use for HTML and HTML Help pages.  See the documentation for
 # a list of builtin themes.
 #
-html_theme = 'sphinx_rtd_theme'
+html_theme = "sphinx_rtd_theme"
 
 # Add any paths that contain custom static files (such as style sheets) here,
 # relative to this directory. They are copied after the builtin static files,
 # so a file named "default.css" will overwrite the builtin "default.css".
-html_static_path = ['_static']
-
-html_logo = '_static/pack.gif'
-
-
-# -- Options for LaTeX output ------------------------------------------------
-
-latex_elements = {
-    # The paper size ('letterpaper' or 'a4paper').
-    #
-    'papersize': 'a4paper',
+html_static_path = ["_static"]
 
-    # The font size ('10pt', '11pt' or '12pt').
-    #
-    # 'pointsize': '10pt',
+html_logo = "_static/pack.gif"
 
-    # Additional stuff for the LaTeX preamble.
-    #
-    # 'preamble': '',
-
-    # Latex figure (float) alignment
-    #
-    # 'figure_align': 'htbp',
-
-    'extraclassoptions': 'openany,oneside'
-}
-
-# latex_logo = '_static/packing_best_100.pdf'
-latex_show_urls = 'footnote'
-
-# Grouping the document tree into LaTeX files. List of tuples
-# (source start file, target name, title,
-#  author, documentclass [howto, manual, or own class]).
-latex_documents = [
-    (master_doc, 'rpack.tex', 'rectangle-packer documentation',
-     rpack.__author__, 'manual'),
-]
+# Output file base name for HTML help builder.
+htmlhelp_basename = "rectangle-packerdoc"
diff --git a/doc/index.rst b/doc/index.rst
index 91af4ee..21a013c 100644
--- a/doc/index.rst
+++ b/doc/index.rst
@@ -1,10 +1,4 @@
 
-.. only:: latex
-
-   ===========================
-   Welcome to rectangle-packer
-   ===========================
-
 .. automodule:: rpack
 
 .. toctree::
diff --git a/requirements_docs.txt b/doc/requirements.txt
similarity index 100%
rename from requirements_docs.txt
rename to doc/requirements.txt
diff --git a/doc/rpack.rst b/doc/rpack.rst
index f7f11b2..5ad406d 100644
--- a/doc/rpack.rst
+++ b/doc/rpack.rst
@@ -1,7 +1,7 @@
 
 ================
 Module Reference
-================	  
+================
 
 
 Functions
@@ -14,7 +14,7 @@ Exceptions
 ==========
 
 .. autoclass:: rpack.PackingImpossibleError
-		  
+
 
 Helper functions
 ================
@@ -26,10 +26,7 @@ Helper functions
 .. autofunction:: rpack.overlapping
 
 
-.. only:: html
-	  
-  Index
-  =====	
-
-  View :ref:`genindex`.
+Index
+=====
 
+View :ref:`genindex`.
diff --git a/misc/crunch.py b/misc/crunch.py
index af4764a..2e5a498 100644
--- a/misc/crunch.py
+++ b/misc/crunch.py
@@ -46,10 +46,12 @@ CIRCUM_MAX = 100
 # Rectangle sources
 # =================
 
+
 def rectangles_square(n: int):
     """Return `n` square rectangles from (1, 1) to (n, n)"""
     return [(i, i) for i in reversed(range(1, n + 1))]
 
+
 def rectangles_circum(n: int):
     """Return `n` fixed circumference rectangles, w + h = n"""
     output = list()
@@ -58,10 +60,11 @@ def rectangles_circum(n: int):
     output.sort(key=lambda x: x[1], reverse=True)
     return output
 
+
 def rectangles_unif_side(n: int, m: int):
     """Return list of `n` rec. with random side lengths `unif{0, m}`"""
-    return [(random.randint(1, m), random.randint(1, m))
-            for _ in range(n)]
+    return [(random.randint(1, m), random.randint(1, m)) for _ in range(n)]
+
 
 def rectangles_unif_area(n: int, m: int):
     """Return list of `n` rec. with random area `unif{0, m}`"""
@@ -69,16 +72,18 @@ def rectangles_unif_area(n: int, m: int):
     for _ in range(n):
         area = random.randint(1, m)
         width = random.randint(1, area)
-        height = area//width
+        height = area // width
         # Randomly transpose rectangle
         if random.choice([True, False]):
             output.append((height, width))
         output.append((width, height))
     return output
 
+
 # Executor tasks
 # ==============
 
+
 async def run_rectangles_square(exe, output_dir: str):
     futures = dict()
     loop = asyncio.get_running_loop()
@@ -86,12 +91,12 @@ async def run_rectangles_square(exe, output_dir: str):
         rec = rectangles_square(n)
         f = loop.run_in_executor(exe, rpack.pack, rec)
         futures[f] = rec
-    output_file = os.path.join(output_dir, f'square{SQUARE_MAX}.pickle')
-    with open(output_file, 'wb') as out_f:
+    output_file = os.path.join(output_dir, f"square{SQUARE_MAX}.pickle")
+    with open(output_file, "wb") as out_f:
         for f, rec in futures.items():
             pos = await f
             pickle.dump((rec, pos), out_f)
-    print('Done:', output_file)
+    print("Done:", output_file)
 
 
 async def run_rectangles_circum(exe, output_dir: str):
@@ -101,18 +106,18 @@ async def run_rectangles_circum(exe, output_dir: str):
         rec = rectangles_circum(n)
         f = loop.run_in_executor(exe, rpack.pack, rec)
         futures[f] = rec
-    output_file = os.path.join(output_dir, f'circum{CIRCUM_MAX}.pickle')
-    with open(output_file, 'wb') as out_f:
+    output_file = os.path.join(output_dir, f"circum{CIRCUM_MAX}.pickle")
+    with open(output_file, "wb") as out_f:
         for f, rec in futures.items():
             pos = await f
             pickle.dump((rec, pos), out_f)
-    print('Done:', output_file)
+    print("Done:", output_file)
 
 
 def no_samples(n: int):
-    b = math.log(100)/90
-    a = 100*math.exp(b*100)
-    return int(a*math.exp(-b*n))
+    b = math.log(100) / 90
+    a = 100 * math.exp(b * 100)
+    return int(a * math.exp(-b * n))
 
 
 def task(rec):
@@ -130,8 +135,8 @@ async def run_rectangles_random(exe, output_dir: str, rec_func):
     progress = dict()
     for n in range(N_STEP, N_MAX + 1, N_STEP):
         for m in range(M_STEP, M_MAX + 1, M_STEP):
-            prefix = rec_func.__name__.replace('rectangles_', '')
-            name = f'{prefix}{n:03}n{m:04}m.pickle'
+            prefix = rec_func.__name__.replace("rectangles_", "")
+            name = f"{prefix}{n:03}n{m:04}m.pickle"
             output_file = os.path.join(output_dir, name)
             if m == M_MAX:
                 s = no_samples(n)
@@ -150,14 +155,14 @@ async def run_rectangles_random(exe, output_dir: str, rec_func):
         for f, (output_file, rec) in futures.items():
             pos, dt = await f
             if output_file not in files:
-                files[output_file] = open(output_file, 'wb')
+                files[output_file] = open(output_file, "wb")
             out_f = files[output_file]
             pickle.dump((rec, pos, dt), out_f)
             progress[output_file] -= 1
             if progress[output_file] == 0:
                 del progress[output_file]
-                print('Done:', output_file, end='. ')
-                print('Files remaining:', len(progress))
+                print("Done:", output_file, end=". ")
+                print("Files remaining:", len(progress))
     finally:
         for f in files.values():
             f.close()
@@ -171,24 +176,30 @@ async def main(args):
         await asyncio.gather(
             asyncio.create_task(run_rectangles_square(exe, args.output_dir)),
             asyncio.create_task(run_rectangles_circum(exe, args.output_dir)),
-            asyncio.create_task(run_rectangles_random(exe, args.output_dir, rectangles_unif_side)),
+            asyncio.create_task(
+                run_rectangles_random(exe, args.output_dir, rectangles_unif_side)
+            ),
             # asyncio.create_task(run_rectangles_random(exe, args.output_dir, rectangles_unif_area)),
         )
 
 
 PARSER = argparse.ArgumentParser()
 PARSER.add_argument(
-    '--max-workers', '-j',
+    "--max-workers",
+    "-j",
     type=int,
     default=min(30, multiprocessing.cpu_count() - 2),
-    help='Max cpu count for workers.')
+    help="Max cpu count for workers.",
+)
 PARSER.add_argument(
-    '--output-dir', '-o',
+    "--output-dir",
+    "-o",
     # Example output_dir: /tmp/rpack/1.1.0-13-g18920b5-dirty/data
     type=str,
-    default='/tmp/rpack/data',
-    help='Measurements output directory.')
+    default="/tmp/rpack/data",
+    help="Measurements output directory.",
+)
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     args = PARSER.parse_args()
     asyncio.run(main(args))
diff --git a/misc/logo.py b/misc/logo.py
index bacb3ac..a655e32 100644
--- a/misc/logo.py
+++ b/misc/logo.py
@@ -11,7 +11,7 @@ import matplotlib.pyplot as plt
 import matplotlib.patches as patches
 import matplotlib.gridspec as gridspec
 import matplotlib.ticker as mtick
-import  matplotlib.animation as mani
+import matplotlib.animation as mani
 from matplotlib.backends.backend_pdf import PdfPages
 from mpl_toolkits.axes_grid1 import make_axes_locatable
 import numpy as np
@@ -32,13 +32,15 @@ def candidates():
         while True:
             i += 1
             random.seed(i)
-            sizes = [(random.randint(50, 1000), random.randint(50, 1000))
-                     for _ in range(random.randint(30, 40))]
+            sizes = [
+                (random.randint(50, 1000), random.randint(50, 1000))
+                for _ in range(random.randint(30, 40))
+            ]
             pos = rpack.pack(sizes)
             rho = rpack.packing_density(sizes, pos)
             w, h = rpack.bbox_size(sizes, pos)
-            if abs(w/h - 1.61803398875) < 0.01:
-                print('Found candidate:', rho, 'seed', i)
+            if abs(w / h - 1.61803398875) < 0.01:
+                print("Found candidate:", rho, "seed", i)
                 cands.append((rho, sizes, pos, i))
     except KeyboardInterrupt:
         pass
@@ -49,7 +51,7 @@ def candidates():
 def searcher(output_dir):
     for i, (rho, sizes, pos, seed) in enumerate(candidates()):
         print(i, rho, seed)
-        file = os.path.join(output_dir, f'{i:02}_logo_{seed}')
+        file = os.path.join(output_dir, f"{i:02}_logo_{seed}")
         p = PlotPacking(sizes, pos, trim=True)
         for spine in p.ax.spines.values():
             spine.set_linewidth(2)
@@ -62,11 +64,13 @@ def searcher(output_dir):
         p.save(file)
 
 
-def logo(output_dir='.'):
+def logo(output_dir="."):
     """Create GIF logo used in sphinx documentation"""
     random.seed(232460)
-    sizes = [(random.randint(50, 1000), random.randint(50, 1000))
-             for _ in range(random.randint(30, 40))]
+    sizes = [
+        (random.randint(50, 1000), random.randint(50, 1000))
+        for _ in range(random.randint(30, 40))
+    ]
     pos = rpack.pack(sizes)
     # Sort the rectangles so the animation will plot them from left to
     # right.
@@ -76,16 +80,16 @@ def logo(output_dir='.'):
     p = PlotPacking(sizes, pos, trim=True)
     for spine in p.ax.spines.values():
         spine.set_linewidth(0)
-    p.animation(os.path.join(output_dir, f'logo'), 1, 0, dpi=40)
+    p.animation(os.path.join(output_dir, f"logo"), 1, 0, dpi=40)
     p = PlotPacking(sizes, pos, trim=True)
     for spine in p.ax.spines.values():
         spine.set_linewidth(0)
     while p.feed():
         pass
-    p.save(os.path.join(output_dir, f'logo'))
+    p.save(os.path.join(output_dir, f"logo"))
     # Post process gif to only loop animation one time.
-    subprocess.run('convert -loop 1 logo.gif logo.gif', shell=True, check=True)
+    subprocess.run("convert -loop 1 logo.gif logo.gif", shell=True, check=True)
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     logo()
diff --git a/misc/recstat.py b/misc/recstat.py
index 1c088c6..094ccf1 100644
--- a/misc/recstat.py
+++ b/misc/recstat.py
@@ -21,7 +21,7 @@ import matplotlib.pyplot as plt
 import matplotlib.patches as patches
 import matplotlib.gridspec as gridspec
 import matplotlib.ticker as mtick
-import  matplotlib.animation as mani
+import matplotlib.animation as mani
 from matplotlib.backends.backend_pdf import PdfPages
 from mpl_toolkits.axes_grid1 import make_axes_locatable
 import numpy as np
@@ -33,8 +33,8 @@ import rpack
 matplotlib.use("Agg")
 
 # Filename pattern of measurement files
-REGEX_FILE = re.compile(r'unif_side(\d+)n(\d+)m.pickle')
-IMG_EXT = frozenset({'png', 'svg', 'pdf'})
+REGEX_FILE = re.compile(r"unif_side(\d+)n(\d+)m.pickle")
+IMG_EXT = frozenset({"png", "svg", "pdf"})
 
 
 def load(directory):
@@ -45,7 +45,7 @@ def load(directory):
         if match:
             n, m = match.groups()
             n, m = int(n), int(m)
-            with open(f, 'rb') as h:
+            with open(f, "rb") as h:
                 data[n, m] = list()
                 while True:
                     try:
@@ -59,7 +59,7 @@ def load_simple(directory, prefix):
     data = list()
     for f in Path(directory).iterdir():
         if f.name.startswith(prefix):
-            with open(f, 'rb') as h:
+            with open(f, "rb") as h:
                 while True:
                     try:
                         rec, pos = pickle.load(h)
@@ -78,45 +78,41 @@ def plot_time(ax, mean_t):
     mean_f = list()
     for key in sorted(data):
         t, a, p = data[key]
-        mean_t.append(sum(t)/len(t)/1e9)
-        f = [aa/pp for aa, pp in zip(a, p)]
-        mean_f.append(sum(f)/len(f))
+        mean_t.append(sum(t) / len(t) / 1e9)
+        f = [aa / pp for aa, pp in zip(a, p)]
+        mean_f.append(sum(f) / len(f))
     mean_t = np.array(mean_t).reshape((10, 10))
     mean_f = np.array(mean_f).reshape((10, 10))
 
-    im = ax.imshow(
-        mean_t, origin='lower', interpolation='none')
-    ct = ax.contour(
-        mean_t, levels=[1], origin='lower', colors=['red'])
-    ax.clabel(ct, ct.levels, inline=True, fmt='%r sec')
-    ax.set_xticklabels([100*i for i in range(1, 11)])
-    ax.set_yticklabels([10*i for i in range(1, 11)])
+    im = ax.imshow(mean_t, origin="lower", interpolation="none")
+    ct = ax.contour(mean_t, levels=[1], origin="lower", colors=["red"])
+    ax.clabel(ct, ct.levels, inline=True, fmt="%r sec")
+    ax.set_xticklabels([100 * i for i in range(1, 11)])
+    ax.set_yticklabels([10 * i for i in range(1, 11)])
     ax.set_xticks([i for i in range(0, 10)])
     ax.set_yticks([i for i in range(0, 10)])
     divider = make_axes_locatable(ax)
     cax = divider.append_axes("right", size="5%", pad=0.05)
     cb = plt.colorbar(im, cax=cax)
-    ax.set_title('Computation time (sec)')
-    ax.set_xlabel('size')
-    ax.set_ylabel('rectangles')
+    ax.set_title("Computation time (sec)")
+    ax.set_xlabel("size")
+    ax.set_ylabel("rectangles")
 
 
 def asdf_plot_packing_density(ax, mean_f):
     # Computation time
-    im = ax.imshow(
-        mean_f, origin='lower', interpolation='none')
-    ct = ax.contour(
-        mean_f, levels=[np.mean(mean_f)], origin='lower', colors=['red'])
-    ax.clabel(ct, ct.levels, inline=True, fmt='%.1f %%')
-    ax.set_xticklabels([100*i for i in range(1, 11)])
-    ax.set_yticklabels([10*i for i in range(1, 11)])
+    im = ax.imshow(mean_f, origin="lower", interpolation="none")
+    ct = ax.contour(mean_f, levels=[np.mean(mean_f)], origin="lower", colors=["red"])
+    ax.clabel(ct, ct.levels, inline=True, fmt="%.1f %%")
+    ax.set_xticklabels([100 * i for i in range(1, 11)])
+    ax.set_yticklabels([10 * i for i in range(1, 11)])
     ax.set_xticks([i for i in range(0, 10)])
     ax.set_yticks([i for i in range(0, 10)])
     divider = make_axes_locatable(ax)
     cax = divider.append_axes("right", size="5%", pad=0.05)
     cb = plt.colorbar(im, cax=cax)
-    ax.set_title('Packing density (%)')
-    ax.set_xlabel('size')
+    ax.set_title("Packing density (%)")
+    ax.set_xlabel("size")
 
 
 def plot_packing_density_by_n(data):
@@ -126,34 +122,34 @@ def plot_packing_density_by_n(data):
         f = list()
         for rec, pos, _ in data[n, m]:
             w, h = rpack.enclosing_size(rec, pos)
-            a = sum(x*y for x, y in rec)
-            f.append(a/(w*h))
+            a = sum(x * y for x, y in rec)
+            f.append(a / (w * h))
         x.append(f)
 
     fig, ax = plt.subplots(tight_layout=True)
     bplot = ax.boxplot(
         x,
-        sym='.',
+        sym=".",
         vert=True,
         patch_artist=True,
         showfliers=True,
         labels=list(range(10, 101, 10)),
         showmeans=True,
-        medianprops=dict(color='black')
+        medianprops=dict(color="black"),
     )
     # fill with colors
-    for patch in bplot['boxes']:
-        patch.set_facecolor('lightblue')
+    for patch in bplot["boxes"]:
+        patch.set_facecolor("lightblue")
     # ax.set_ylim([0.7, None])
     ax.yaxis.grid(True)
     ax.yaxis.set_major_formatter(mtick.PercentFormatter(xmax=1, decimals=0))
     ax.yaxis.set_major_locator(mtick.MultipleLocator(0.05))
     ax.yaxis.set_minor_locator(mtick.MultipleLocator(0.01))
-    ax.set_title(rf'Packing density, rectangle side lengths ~ $Unif\{{1, {m}\}}$')
-    ax.set_xlabel('Number of rectangles')
+    ax.set_title(rf"Packing density, rectangle side lengths ~ $Unif\{{1, {m}\}}$")
+    ax.set_xlabel("Number of rectangles")
 
     for ext in IMG_EXT:
-        plt.savefig(os.path.join(args.output_dir, f'packing_density_by_n.{ext}'))
+        plt.savefig(os.path.join(args.output_dir, f"packing_density_by_n.{ext}"))
     fig.clf()
     plt.close()
 
@@ -167,8 +163,8 @@ def plot_packing_density_by_m(data):
         f = list()
         for rec, pos, _ in data[100, m]:
             w, h = rpack.enclosing_size(rec, pos)
-            a = sum(x*y for x, y in rec)
-            f.append(a/(w*h))
+            a = sum(x * y for x, y in rec)
+            f.append(a / (w * h))
         x.append(f)
         total.extend(f)
     x.append(total)
@@ -176,35 +172,35 @@ def plot_packing_density_by_m(data):
     fig, ax = plt.subplots(tight_layout=True)
     ax.axhline(
         np.array(total).mean(),
-        color=matplotlib.rcParams['boxplot.meanprops.markerfacecolor'],
+        color=matplotlib.rcParams["boxplot.meanprops.markerfacecolor"],
         linewidth=1,
-        linestyle=':'
+        linestyle=":",
     )
     bplot = ax.boxplot(
         x,
-        sym='.',
+        sym=".",
         vert=True,
         patch_artist=True,
-        labels=list(range(100, 1001, 100)) + ['total'],
+        labels=list(range(100, 1001, 100)) + ["total"],
         # positions=list(range(1, 11)) + [11.25],
         # widths=[0.5]*10 + [1],
         showmeans=True,
-        medianprops=dict(color='black')
+        medianprops=dict(color="black"),
     )
     # fill with colors
-    colors = ['lightblue']*10 + ['lightgreen']
-    for patch, color in zip(bplot['boxes'], colors):
+    colors = ["lightblue"] * 10 + ["lightgreen"]
+    for patch, color in zip(bplot["boxes"], colors):
         patch.set_facecolor(color)
     # ax.set_xlim([None, 13])
     ax.yaxis.grid(True)
     ax.yaxis.set_major_formatter(mtick.PercentFormatter(xmax=1, decimals=0))
     ax.yaxis.set_major_locator(mtick.MultipleLocator(0.01))
     ax.yaxis.set_minor_locator(mtick.MultipleLocator(0.001))
-    ax.set_title('Packing density')
-    ax.set_xlabel(rf'rectangle side lengths ~ $Unif\{{1, m\}}$, ${n} \leq m \leq {m}$')
+    ax.set_title("Packing density")
+    ax.set_xlabel(rf"rectangle side lengths ~ $Unif\{{1, m\}}$, ${n} \leq m \leq {m}$")
 
     for ext in IMG_EXT:
-        plt.savefig(os.path.join(args.output_dir, f'packing_density_by_m.{ext}'))
+        plt.savefig(os.path.join(args.output_dir, f"packing_density_by_m.{ext}"))
     fig.clf()
     plt.close()
 
@@ -224,23 +220,24 @@ def plot_enclosing(data):
             w, h = rpack.enclosing_size(rec, pos)
             ew.append(w)
             eh.append(h)
-        ew = np.array(ew)/math.sqrt(n)
-        eh = np.array(eh)/math.sqrt(n)
+        ew = np.array(ew) / math.sqrt(n)
+        eh = np.array(eh) / math.sqrt(n)
         # f = [aa/(w*h) for aa, (w, h) in zip(a, zip(ew, eh))]
-        color = 'black' if n == 100 else None
-        ax.scatter(ew, eh, c=color, s=0.2, label=f'$n = {n}$')
+        color = "black" if n == 100 else None
+        ax.scatter(ew, eh, c=color, s=0.2, label=f"$n = {n}$")
 
     ax.legend(markerscale=5)
-    ax.set_aspect('equal')
+    ax.set_aspect("equal")
     ax.set_xlim([0, None])
     ax.set_ylim([0, None])
     ax.set_title(
-        'Resulting enclosings,\n'
-        rf'$n$ = No. rectangles, side lengths ~ $Unif\{{1, {m}\}}$')
-    ax.set_ylabel(r'Enclosing height / $\sqrt{n}$')
-    ax.set_xlabel(r'Enclosing width / $\sqrt{n}$')
+        "Resulting enclosings,\n"
+        rf"$n$ = No. rectangles, side lengths ~ $Unif\{{1, {m}\}}$"
+    )
+    ax.set_ylabel(r"Enclosing height / $\sqrt{n}$")
+    ax.set_xlabel(r"Enclosing width / $\sqrt{n}$")
     for ext in IMG_EXT:
-        plt.savefig(os.path.join(args.output_dir, f'enclosing.{ext}'))
+        plt.savefig(os.path.join(args.output_dir, f"enclosing.{ext}"))
     fig.clf()
     plt.close()
 
@@ -251,7 +248,7 @@ def plot_computation_time_by_n(data):
     s = list()
     m = 1_000
     for n in x:
-        t = np.array([(ns/1e9) for rec, pos, ns in data[n, m]])
+        t = np.array([(ns / 1e9) for rec, pos, ns in data[n, m]])
         t_mean = t.mean()
         t_std = t.std()
         y.append(t_mean)
@@ -264,18 +261,22 @@ def plot_computation_time_by_n(data):
     yy = [p(xx) for xx in x]
 
     fig, ax = plt.subplots(tight_layout=True)
-    ax.errorbar(x, y, s, fmt='--o', label='Measurement')
-    ax.plot(x, yy, label='Polyfit $t = αn^3 + βn^2 + γn + δ$'
-                         '\nα={:.2g}, β={:.2g} γ={:.2g} δ={:.2g}'.format(*pol))
+    ax.errorbar(x, y, s, fmt="--o", label="Measurement")
+    ax.plot(
+        x,
+        yy,
+        label="Polyfit $t = αn^3 + βn^2 + γn + δ$"
+        "\nα={:.2g}, β={:.2g} γ={:.2g} δ={:.2g}".format(*pol),
+    )
     ax.grid(True)
     ax.xaxis.set_major_locator(mtick.MultipleLocator(10))
-    ax.set_title(rf'Computation time, rectangle side lengths ~ $Unif\{{1, {m}\}}$')
-    ax.set_xlabel('Number of rectangles')
-    ax.set_ylabel('Seconds')
-    ax.legend(loc='upper left')
+    ax.set_title(rf"Computation time, rectangle side lengths ~ $Unif\{{1, {m}\}}$")
+    ax.set_xlabel("Number of rectangles")
+    ax.set_ylabel("Seconds")
+    ax.legend(loc="upper left")
 
     for ext in IMG_EXT:
-        plt.savefig(os.path.join(args.output_dir, f'computation_time_by_n.{ext}'))
+        plt.savefig(os.path.join(args.output_dir, f"computation_time_by_n.{ext}"))
     fig.clf()
     plt.close()
 
@@ -286,7 +287,7 @@ def plot_computation_time_by_m(data):
     y = list()
     s = list()
     for m in x:
-        t = np.array([(ns/1e9) for rec, pos, ns in data[n, m]])
+        t = np.array([(ns / 1e9) for rec, pos, ns in data[n, m]])
         t_mean = t.mean()
         t_std = t.std()
         y.append(t_mean)
@@ -299,46 +300,44 @@ def plot_computation_time_by_m(data):
     yy = [p(xx) for xx in x]
 
     fig, ax = plt.subplots(tight_layout=True)
-    ax.errorbar(x, y, s, fmt='--o', label='Measurement')
-    ax.plot(x, yy, label='Polyfit $t = αn + β$'
-                         '\nα={:.2g}, β={:.2g}'.format(*pol))
+    ax.errorbar(x, y, s, fmt="--o", label="Measurement")
+    ax.plot(x, yy, label="Polyfit $t = αn + β$" "\nα={:.2g}, β={:.2g}".format(*pol))
     ax.grid(True)
     ax.xaxis.set_major_locator(mtick.MultipleLocator(n))
-    ax.set_title(f'Computation time, {n} rectangles')
-    ax.set_xlabel(rf'rectangle side lengths ~ $Unif\{{1, m\}}$, ${n} \leq m \leq {m}$')
-    ax.set_ylabel('Seconds')
-    ax.legend(loc='upper left')
+    ax.set_title(f"Computation time, {n} rectangles")
+    ax.set_xlabel(rf"rectangle side lengths ~ $Unif\{{1, m\}}$, ${n} \leq m \leq {m}$")
+    ax.set_ylabel("Seconds")
+    ax.legend(loc="upper left")
 
     for ext in IMG_EXT:
-        plt.savefig(os.path.join(args.output_dir, f'computation_time_by_m.{ext}'))
+        plt.savefig(os.path.join(args.output_dir, f"computation_time_by_m.{ext}"))
     fig.clf()
     plt.close()
 
 
 def rectangle_color(w, h):
-    r = min(w, h)/max(w, h)/2
+    r = min(w, h) / max(w, h) / 2
     if h < w:
         r = 1 - r
-    r = r/2 + 0.3
-    return plt.get_cmap('viridis')(r)
+    r = r / 2 + 0.3
+    return plt.get_cmap("viridis")(r)
 
 
 class PlotPacking:
-
-    def __init__(self, rec, pos, gridlines=False, title='', trim=False):
+    def __init__(self, rec, pos, gridlines=False, title="", trim=False):
         """Initialization of PlotPacking"""
         self.rec = rec
         self.pos = pos
         self.gridlines = gridlines
         self.index = None
         self.encl_w, self.encl_h = rpack.enclosing_size(rec, pos)
-        self.density = sum(w*h for w, h in rec)/(self.encl_w*self.encl_h)
+        self.density = sum(w * h for w, h in rec) / (self.encl_w * self.encl_h)
         if trim:
-            self.fig = plt.figure(figsize=(6, 6*self.encl_h/self.encl_w))
+            self.fig = plt.figure(figsize=(6, 6 * self.encl_h / self.encl_w))
             self.ax = self.fig.add_axes([0.01, 0.01, 0.98, 0.98])
         else:
             self.fig, self.ax = plt.subplots(tight_layout=True)
-            self.ax.set_aspect('equal')
+            self.ax.set_aspect("equal")
         self.ax.invert_yaxis()
         self.ax.set_xlim([0, self.encl_w])
         self.ax.set_ylim([self.encl_h, 0])
@@ -346,8 +345,9 @@ class PlotPacking:
         self.ax.yaxis.set_visible(False)
         if title and not trim:
             self.ax.set_title(
-                f'Packing density {100*self.density:.2f}% '
-                f'({self.encl_w} x {self.encl_h})' + title)
+                f"Packing density {100*self.density:.2f}% "
+                f"({self.encl_w} x {self.encl_h})" + title
+            )
 
     def feed(self, *args):
         artists = list()
@@ -361,15 +361,13 @@ class PlotPacking:
             return []
         else:
             p = patches.Rectangle(
-                (x, y), w, h,
-                edgecolor='k',
-                facecolor=rectangle_color(w, h)
+                (x, y), w, h, edgecolor="k", facecolor=rectangle_color(w, h)
             )
             self.ax.add_patch(p)
             artists.append(p)
             if self.gridlines:
-                hline = self.ax.axhline(y+h, color='k', linestyle='-', linewidth=0.5)
-                vline = self.ax.axvline(x+w, color='k', linestyle='-', linewidth=0.5)
+                hline = self.ax.axhline(y + h, color="k", linestyle="-", linewidth=0.5)
+                vline = self.ax.axvline(x + w, color="k", linestyle="-", linewidth=0.5)
                 artists.append(hline)
                 artists.append(vline)
             self.index += 1
@@ -377,25 +375,26 @@ class PlotPacking:
 
     def save(self, output_file):
         for ext in IMG_EXT:
-            plt.savefig(f'{output_file}.{ext}', bbox_inches='tight')
+            plt.savefig(f"{output_file}.{ext}", bbox_inches="tight")
         self.fig.clf()
         plt.close()
 
     def animation(self, output_file, pack_duration=3, duration=10, **kwargs):
         frames = list(range(len(self.rec)))
-        interval = int(1_000*pack_duration/len(frames))
-        frames.extend([None] * int(len(frames)*(duration/pack_duration)))
+        interval = int(1_000 * pack_duration / len(frames))
+        frames.extend([None] * int(len(frames) * (duration / pack_duration)))
         anim = mani.FuncAnimation(self.fig, self.feed, frames=frames, interval=interval)
-        if 'dpi' not in kwargs:
-            kwargs['dpi'] = 80
-        anim.save(f'{output_file}.gif', writer='imagemagick', **kwargs)
+        if "dpi" not in kwargs:
+            kwargs["dpi"] = 80
+        anim.save(f"{output_file}.gif", writer="imagemagick", **kwargs)
         self.fig.clf()
         plt.close()
 
 
 def packing_density(rec, pos):
     w, h = rpack.enclosing_size(rec, pos)
-    return sum(x*y for x, y in rec)/(w*h)
+    return sum(x * y for x, y in rec) / (w * h)
+
 
 def best_first(samples):
     x = list()
@@ -410,13 +409,12 @@ def plot_packing_extremes(data):
     for n in [10, 100]:
         m = 1000
         toplist = best_first(data[n, m])
-        for case in [('best', toplist[0]), ('worst', toplist[-1])]:
+        for case in [("best", toplist[0]), ("worst", toplist[-1])]:
             name, (_, rec, pos) = case
-            p = PlotPacking(
-                rec, pos, title=f', {n} rectangles.')
+            p = PlotPacking(rec, pos, title=f", {n} rectangles.")
             while p.feed():
                 pass
-            p.save(os.path.join(args.output_dir, f'packing_{name}_{n}'))
+            p.save(os.path.join(args.output_dir, f"packing_{name}_{n}"))
 
 
 def plot_packing_golden_ratio(data):
@@ -426,14 +424,15 @@ def plot_packing_golden_ratio(data):
             for rec, pos, _ in data[n, m]:
                 w, h = rpack.bbox_size(rec, pos)
                 rho = rpack.packing_density(rec, pos)
-                candidates.append((round(abs(w/h - 1.61803398875), 2), -rho, rec, pos))
+                candidates.append(
+                    (round(abs(w / h - 1.61803398875), 2), -rho, rec, pos)
+                )
     candidates.sort()
     _, _, rec, pos = candidates[0]
-    p = PlotPacking(
-        rec, pos, title=f', {len(rec)} rectangles.')
+    p = PlotPacking(rec, pos, title=f", {len(rec)} rectangles.")
     while p.feed():
         pass
-    p.save(os.path.join(args.output_dir, f'packing_phi'))
+    p.save(os.path.join(args.output_dir, f"packing_phi"))
 
 
 def plot_animations(data):
@@ -443,7 +442,9 @@ def plot_animations(data):
             for rec, pos, _ in data[n, m]:
                 w, h = rpack.bbox_size(rec, pos)
                 rho = rpack.packing_density(rec, pos)
-                candidates.append((round(abs(w/h - 0.61803398875), 2), -rho, rec, pos))
+                candidates.append(
+                    (round(abs(w / h - 0.61803398875), 2), -rho, rec, pos)
+                )
     candidates.sort()
     _, _, sizes, pos = candidates[0]
     # Sort the rectangles so the animation will plot them from left to
@@ -451,45 +452,43 @@ def plot_animations(data):
     sizes = [s for s, _ in sorted(zip(sizes, pos), key=lambda x: x[1])]
     pos.sort()
     p = PlotPacking(sizes, pos, gridlines=True, trim=True)
-    p.animation(os.path.join(args.output_dir, f'example_grid'), 60, 20)
+    p.animation(os.path.join(args.output_dir, f"example_grid"), 60, 20)
     p = PlotPacking(sizes, pos, gridlines=True, trim=True)
     while p.feed():
         pass
-    p.save(os.path.join(args.output_dir, f'example_grid'))
+    p.save(os.path.join(args.output_dir, f"example_grid"))
 
 
 def plot_squares(directory):
-
-    data = load_simple(directory, 'square')
+    data = load_simple(directory, "square")
 
     f = list()
-    for (rec, pos) in data:
+    for rec, pos in data:
         w, h = rpack.enclosing_size(rec, pos)
-        a = sum(x*y for x, y in rec)
-        f.append(a/(w*h))
-
-    with PdfPages(os.path.join(args.output_dir, 'squares.pdf')) as pdf:
+        a = sum(x * y for x, y in rec)
+        f.append(a / (w * h))
 
+    with PdfPages(os.path.join(args.output_dir, "squares.pdf")) as pdf:
         fig, ax = plt.subplots(tight_layout=True)
         ax.plot(list(range(1, len(f) + 1)), f)
         ax.grid(True)
         ax.yaxis.set_major_formatter(mtick.PercentFormatter(xmax=1))
         ax.xaxis.set_major_locator(mtick.MultipleLocator(10))
-        ax.set_title('Packing density, squares')
-        ax.set_xlabel('Rectangle max side length (n)')
+        ax.set_title("Packing density, squares")
+        ax.set_xlabel("Rectangle max side length (n)")
         pdf.savefig(figure=fig)
         for ext in IMG_EXT:
-            plt.savefig(os.path.join(args.output_dir, f'squares_summary.{ext}'))
+            plt.savefig(os.path.join(args.output_dir, f"squares_summary.{ext}"))
         fig.clf()
         plt.close()
 
         for n, (rec, pos) in enumerate(data, start=1):
             if n == 1:
-                title = ', square 1x1'
+                title = ", square 1x1"
             elif n == 2:
-                title = ', squares 1x1 + 2x2'
+                title = ", squares 1x1 + 2x2"
             else:
-                title = f', squares 1x1 ... {n}x{n}'
+                title = f", squares 1x1 ... {n}x{n}"
             p = PlotPacking(rec, pos, title=title)
             while p.feed():
                 pass
@@ -499,33 +498,30 @@ def plot_squares(directory):
 
 
 def plot_circums(directory):
-
-    data = load_simple(directory, 'circum')
+    data = load_simple(directory, "circum")
 
     f = list()
-    for (rec, pos) in data:
+    for rec, pos in data:
         w, h = rpack.enclosing_size(rec, pos)
-        a = sum(x*y for x, y in rec)
-        f.append(a/(w*h))
-
-    with PdfPages(os.path.join(args.output_dir, 'circum.pdf')) as pdf:
+        a = sum(x * y for x, y in rec)
+        f.append(a / (w * h))
 
+    with PdfPages(os.path.join(args.output_dir, "circum.pdf")) as pdf:
         fig, ax = plt.subplots(tight_layout=True)
         ax.plot(list(range(1, len(f) + 1)), f)
         ax.grid(True)
         ax.yaxis.set_major_formatter(mtick.PercentFormatter(xmax=1))
         ax.xaxis.set_major_locator(mtick.MultipleLocator(10))
-        ax.set_title('Packing density, fixed circumference rectangles')
-        ax.set_xlabel('Rectangle width + height (n)')
+        ax.set_title("Packing density, fixed circumference rectangles")
+        ax.set_xlabel("Rectangle width + height (n)")
         pdf.savefig(figure=fig)
         for ext in IMG_EXT:
-            plt.savefig(os.path.join(args.output_dir, f'circum_summary.{ext}'))
+            plt.savefig(os.path.join(args.output_dir, f"circum_summary.{ext}"))
         fig.clf()
         plt.close()
 
         for n, (rec, pos) in enumerate(data, start=1):
-            p = PlotPacking(
-                rec, pos, title=f', nx1 ... 1xn, n={n}.')
+            p = PlotPacking(rec, pos, title=f", nx1 ... 1xn, n={n}.")
             while p.feed():
                 pass
             pdf.savefig(figure=p.fig)
@@ -551,18 +547,22 @@ def main(args):
 
 PARSER = argparse.ArgumentParser()
 PARSER.add_argument(
-    '--input-dir', '-i',
+    "--input-dir",
+    "-i",
     # Example output_dir: /tmp/rpack/1.1.0-13-g18920b5-dirty/data
     type=str,
-    default='/tmp/rpack/data',
-    help='Data input directory.')
+    default="/tmp/rpack/data",
+    help="Data input directory.",
+)
 PARSER.add_argument(
-    '--output-dir', '-o',
+    "--output-dir",
+    "-o",
     # Example output_dir: /tmp/rpack/1.1.0-13-g18920b5-dirty/img
     type=str,
-    default='/tmp/rpack/img',
-    help='Images output directory.')
+    default="/tmp/rpack/img",
+    help="Images output directory.",
+)
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     args = PARSER.parse_args()
     main(args)
diff --git a/rpack/__init__.py b/rpack/__init__.py
index 6285336..a7d661b 100644
--- a/rpack/__init__.py
+++ b/rpack/__init__.py
@@ -76,47 +76,23 @@ Examples
 
 **Example A:**
 
-.. only:: latex
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/packing_best_10.pdf
-     :alt: pack10
-     :align: center
-
-.. only:: html
-
-  .. figure:: https://penlect.com/rpack/2.0.1/img/packing_best_10.svg
-     :alt: pack10
-     :align: center
+.. figure:: https://penlect.com/rpack/2.0.2/img/packing_best_10.svg
+   :alt: pack10
+   :align: center
 
 **Example B:**
 
-.. only:: latex
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/packing_phi.pdf
-     :alt: packphi
-     :align: center
-
-.. only:: html
-
-  .. figure:: https://penlect.com/rpack/2.0.1/img/packing_phi.svg
-     :alt: packphi
-     :align: center
+.. figure:: https://penlect.com/rpack/2.0.2/img/packing_phi.svg
+   :alt: packphi
+   :align: center
 
 
 **Example C:** Sometimes the input rectangles simply cannot be packed in
 a good way. Here is an example of low packing density:
 
-.. only:: latex
-
-  .. image:: https://penlect.com/rpack/2.0.1/img/packing_worst_10.pdf
-     :alt: pack10bad
-     :align: center
-
-.. only:: html
-
-  .. figure:: https://penlect.com/rpack/2.0.1/img/packing_worst_10.svg
-     :alt: pack10bad
-     :align: center
+.. figure:: https://penlect.com/rpack/2.0.2/img/packing_worst_10.svg
+   :alt: pack10bad
+   :align: center
 
 
 **Example D:** The image below is contributed by Paul Brodersen, and
@@ -156,14 +132,14 @@ illustrates a solution to a problem discussed at stackoverflow_.
 """
 
 # Module metadata
-__author__ = 'Daniel Andersson'
+__author__ = "Daniel Andersson"
 __maintainer__ = __author__
-__email__ = 'daniel.4ndersson@gmail.com'
+__email__ = "daniel.4ndersson@gmail.com"
 __contact__ = __email__
-__copyright__ = 'Copyright (c) 2017 Daniel Andersson'
-__license__ = 'MIT'
-__url__ = 'https://github.com/Penlect/rectangle-packer'
-__version__ = '2.0.2'
+__copyright__ = "Copyright (c) 2017 Daniel Andersson"
+__license__ = "MIT"
+__url__ = "https://github.com/Penlect/rectangle-packer"
+__version__ = "2.0.2"
 
 # Built-in
 from typing import Iterable, Tuple, List
@@ -174,14 +150,15 @@ from rpack._core import (
     PackingImpossibleError,
     bbox_size,
     packing_density,
-    overlapping
+    overlapping,
 )
 
 enclosing_size = bbox_size
 
 
-def pack(sizes: Iterable[Tuple[int, int]],
-         max_width=None, max_height=None) -> List[Tuple[int, int]]:
+def pack(
+    sizes: Iterable[Tuple[int, int]], max_width=None, max_height=None
+) -> List[Tuple[int, int]]:
     """Pack rectangles into a bounding box with minimal area.
 
     The result is returned as a list of coordinates "(x, y)", which
diff --git a/setup.py b/setup.py
index ccb7b7d..b37749b 100644
--- a/setup.py
+++ b/setup.py
@@ -6,81 +6,88 @@ from setuptools import setup, Extension, find_packages
 # The package can't be imported at this point since the extension
 # module rpack._core does not exist yet. Therefore, we import
 # __init__.py partially.
-with open('rpack/__init__.py') as init:
+with open("rpack/__init__.py") as init:
     lines = list()
     for line in init.readlines():
-        if line.startswith(('from ', 'import ')):
+        if line.startswith(("from ", "import ")):
             break
         lines.append(line)
-spec = importlib.util.spec_from_loader('init', loader=None)
+spec = importlib.util.spec_from_loader("init", loader=None)
 init = importlib.util.module_from_spec(spec)
-exec(''.join(lines), init.__dict__)
+exec("".join(lines), init.__dict__)
+
+
+def adjust_for_pypi(text: str) -> str:
+    # PyPI don't like this syntax:
+    lines = list()
+    for line in text.splitlines():
+        if line.startswith(".. figure::"):
+            line = line.replace(".svg", ".png")
+        lines.append(line)
+    text = "\n".join(lines)
+    text = text.replace(":py:func:`rpack.pack`", "``rpack.pack``")
+    return text.strip()
+
 
 # Generate the readme file from the doc string.
-with open('README.rst', 'w') as readme_file:
-    lines = init.__doc__.splitlines()[1:]
-    content = '\n'.join(lines).lstrip()
-    # Github/gitlab does not like pdf
-    content = content.replace('.pdf', '.png')
+with open("README.rst", "w") as readme_file:
+    content = adjust_for_pypi("\n".join(init.__doc__.splitlines()[1:]))
     readme_file.write(content)
 
 ext_modules = [
     Extension(
-        'rpack._core',
-        sources=['rpack/_core.pyx', 'src/rpackcore.c'],
-        include_dirs=['include']),
+        "rpack._core",
+        sources=["rpack/_core.pyx", "src/rpackcore.c"],
+        include_dirs=["include"],
+    ),
     Extension(
         # The rpack._rpack extension module is deprecated. It will be
         # removed in a future version. This was the implementation
         # used in versions 1.0.0 and 1.1.0.
-        'rpack._rpack',
-        sources=['src/rpack.c', 'src/areapack.c', 'src/taskpack.c'],
-        include_dirs=['include'])
+        "rpack._rpack",
+        sources=["src/rpack.c", "src/areapack.c", "src/taskpack.c"],
+        include_dirs=["include"],
+    ),
 ]
 for e in ext_modules:
-    e.cython_directives = {
-        'language_level': '3',
-        'embedsignature': True
-    }
+    e.cython_directives = {"language_level": "3", "embedsignature": True}
 
 setup(
-    name='rectangle-packer',
+    name="rectangle-packer",
     version=init.__version__,
     author=init.__author__,
     author_email=init.__email__,
     description=init.__doc__.splitlines()[0].strip(),
-    long_description=init.__doc__,
-    long_description_content_type='text/x-rst',
+    long_description=adjust_for_pypi(init.__doc__),
+    long_description_content_type="text/x-rst",
     license=init.__license__,
-    keywords='pack rectangle packing rectangles enclosing 2D',
+    keywords="pack rectangle packing rectangles enclosing 2D",
     url=init.__url__,
     ext_modules=ext_modules,
     packages=find_packages(exclude=("test",)),
     include_package_data=True,
-    setup_requires=[
-        'setuptools>=18.0',
-        'Cython<3.0.0'
-    ],
+    setup_requires=["setuptools>=18.0", "Cython"],
     test_suite="test",
     classifiers=[
-        'Development Status :: 5 - Production/Stable',
-        'Environment :: Console',
-        'Intended Audience :: Developers',
-        'Intended Audience :: Education',
-        'Intended Audience :: Science/Research',
-        'License :: OSI Approved :: MIT License',
-        'Natural Language :: English',
-        'Operating System :: POSIX :: Linux',
-        'Operating System :: MacOS',
-        'Operating System :: Microsoft :: Windows :: Windows 10',
-        'Programming Language :: C',
-        'Programming Language :: Python :: 3.6',
-        'Programming Language :: Python :: 3.7',
-        'Programming Language :: Python :: 3.8',
-        'Programming Language :: Python :: 3.9',
-        'Programming Language :: Python :: 3.10',
-        'Programming Language :: Python :: 3.11',
-        'Programming Language :: Python :: 3.12',
-        'Programming Language :: Python :: Implementation :: CPython'
-    ]
+        "Development Status :: 5 - Production/Stable",
+        "Environment :: Console",
+        "Intended Audience :: Developers",
+        "Intended Audience :: Education",
+        "Intended Audience :: Science/Research",
+        "License :: OSI Approved :: MIT License",
+        "Natural Language :: English",
+        "Operating System :: POSIX :: Linux",
+        "Operating System :: MacOS",
+        "Operating System :: Microsoft :: Windows :: Windows 10",
+        "Programming Language :: C",
+        "Programming Language :: Python :: 3.6",
+        "Programming Language :: Python :: 3.7",
+        "Programming Language :: Python :: 3.8",
+        "Programming Language :: Python :: 3.9",
+        "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
+        "Programming Language :: Python :: 3.12",
+        "Programming Language :: Python :: 3.13",
+        "Programming Language :: Python :: Implementation :: CPython",
+    ],
 )
diff --git a/src/taskpack.c b/src/taskpack.c
index 4b8cc56..b74fdf8 100644
--- a/src/taskpack.c
+++ b/src/taskpack.c
@@ -219,22 +219,18 @@ group index.
         stack_add(stack, &tasks[i], tmp);
     }
     /* Step 2 */
-    unsigned long move_count = 0;
     for(;;){
         if (! move_from_max_to_min(stack, tasks, nr_tasks)){
             break;
         }
-        move_count++;
     }
 
     /* Step 3 */
-    unsigned long swap_count = 0;
     for(i = 0; i < nr_tasks; i++){
         if (! swap_from_max(stack, tasks, nr_tasks)){
             break;
         }
-        swap_count++;
     }
     free_stack(stack);
     return result;
-}
\ No newline at end of file
+}
diff --git a/test/test.py b/test/test.py
index 3c710e1..ac53ca2 100644
--- a/test/test.py
+++ b/test/test.py
@@ -1,4 +1,3 @@
-
 # Built-in
 import doctest
 import random
@@ -23,12 +22,11 @@ def test(n):
     assert not rpack._core.overlapping(sizes, pos)
     w, h = rpack._core.bbox_size(sizes, pos)
     p = rpack._core.packing_density(sizes, pos)
-    print(f'encl (w={w} x h={h}), area={w*h}, rho={p}')
+    print(f"encl (w={w} x h={h}), area={w*h}, rho={p}")
 
 
 class TestTimeComplexity(unittest.TestCase):
-
     def test(self):
         for i in range(10, 101, 10):
-            r = timeit.repeat(stmt=f'test({i})', number=1, repeat=1, globals=globals())
+            r = timeit.repeat(stmt=f"test({i})", number=1, repeat=1, globals=globals())
             print(i, r)
diff --git a/test/test_group.py b/test/test_group.py
index 10246bc..c70df39 100644
--- a/test/test_group.py
+++ b/test/test_group.py
@@ -7,14 +7,13 @@ import unittest
 # Local
 import rpack._rpack as rpack
 
-class TestGroup(unittest.TestCase):
 
+class TestGroup(unittest.TestCase):
     def test_flat(self):
         data = [3, 2, 1]
         # Todo: the order should not matter
         self.assertEqual(rpack.group(data, 3), [[3], [2], [1]])
 
-
     def test_nr_groups(self):
         with self.assertRaises(ValueError):
             rpack.group([1], -1)
@@ -24,11 +23,9 @@ class TestGroup(unittest.TestCase):
         for nr_groups in range(1, 100):
             assert len(rpack.group(data, nr_groups)) == nr_groups
 
-
     def test_empty_list(self):
         self.assertEqual(rpack.group([], 3), [[], [], []])
 
-
     def test_input_error(self):
         with self.assertRaises(TypeError):
             rpack.group(None, 3)
@@ -37,12 +34,10 @@ class TestGroup(unittest.TestCase):
         with self.assertRaises(TypeError):
             rpack.group(None, None)
 
-
     def test_performance(self):
         groups = rpack.group(list(range(1000)), 5)
         self.assertEqual(max(sum(g) for g in groups), 99900)
 
-
     def test_swap_complete(self):
         """Test that no further "swapping" will improve the result"""
         # Get random data
diff --git a/test/test_memory.py b/test/test_memory.py
index 6305676..51b57ff 100644
--- a/test/test_memory.py
+++ b/test/test_memory.py
@@ -34,7 +34,7 @@ def randneg():
 
 def randtype():
     length = randint(1, 100)
-    return [(None, 'string') for _ in range(length)]
+    return [(None, "string") for _ in range(length)]
 
 
 def randrest():
@@ -59,8 +59,8 @@ def main(args):
 
 
 parser = argparse.ArgumentParser()
-parser.add_argument('duration', type=int, help='Seconds to run')
+parser.add_argument("duration", type=int, help="Seconds to run")
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     args = parser.parse_args()
     main(args)
diff --git a/test/test_pack.py b/test/test_pack.py
index 50e4e56..9939e99 100644
--- a/test/test_pack.py
+++ b/test/test_pack.py
@@ -13,14 +13,14 @@ import rpack._core
 # TEST CORE UTILS
 # ===============
 
-class TestPackingDensity(unittest.TestCase):
 
+class TestPackingDensity(unittest.TestCase):
     def test_max_density(self):
         p = rpack._core.packing_density([(10, 10)], [(0, 0)])
         self.assertEqual(p, 1)
 
-class TestOverlapping(unittest.TestCase):
 
+class TestOverlapping(unittest.TestCase):
     def test_overlapping_true(self):
         sizes = [(10, 10), (10, 10)]
         pos = [(0, 0), (9, 9)]
@@ -33,8 +33,8 @@ class TestOverlapping(unittest.TestCase):
         index = rpack._core.overlapping(sizes, pos)
         self.assertFalse(index)
 
-class TestBboxSize(unittest.TestCase):
 
+class TestBboxSize(unittest.TestCase):
     def test_enclosing_size(self):
         """Test enclosing size helper function"""
         sizes = [(3, 5), (1, 1), (1, 1)]
@@ -43,9 +43,11 @@ class TestBboxSize(unittest.TestCase):
         self.assertEqual(width, 4)
         self.assertEqual(height, 6)
 
+
 # TEST INPUT
 # ==========
 
+
 class TestPackInput(unittest.TestCase):
     """Test how rpack.pack handles bad input"""
 
@@ -80,9 +82,9 @@ class TestPackInput(unittest.TestCase):
     def test_not_integers(self):
         """Non-number should raise TypeError"""
         with self.assertRaises(TypeError):
-            rpack.pack([('garnet', 9)])
+            rpack.pack([("garnet", 9)])
         with self.assertRaises(TypeError):
-            rpack.pack([(9, 'alexandros')])
+            rpack.pack([(9, "alexandros")])
 
     def test_floats(self):
         with self.assertRaises(TypeError):
@@ -96,22 +98,22 @@ class TestPackInputBoundingBoxRestrictions(unittest.TestCase):
         self.assertListEqual(rpack.pack([(10, 10)], None), [(0, 0)])
 
     def test_max_width(self):
-        pos = rpack.pack([(2, 2)]*4, max_width=3)
-        self.assertSetEqual(set(pos), {(0, 2*i) for i in range(4)})
+        pos = rpack.pack([(2, 2)] * 4, max_width=3)
+        self.assertSetEqual(set(pos), {(0, 2 * i) for i in range(4)})
 
     def test_max_width_bad(self):
-        with self.assertRaisesRegex(rpack.PackingImpossibleError, 'max_width'):
+        with self.assertRaisesRegex(rpack.PackingImpossibleError, "max_width"):
             rpack.pack([(2, 2)], max_width=1)
 
     def test_max_width_ok(self):
         rpack.pack([(2, 2)], max_width=2)
 
     def test_max_height(self):
-        pos = rpack.pack([(2, 2)]*4, max_height=3)
-        self.assertSetEqual(set(pos), {(2*i, 0) for i in range(4)})
+        pos = rpack.pack([(2, 2)] * 4, max_height=3)
+        self.assertSetEqual(set(pos), {(2 * i, 0) for i in range(4)})
 
     def test_max_height_bad(self):
-        with self.assertRaisesRegex(rpack.PackingImpossibleError, 'max_height'):
+        with self.assertRaisesRegex(rpack.PackingImpossibleError, "max_height"):
             rpack.pack([(2, 2)], max_height=1)
 
     def test_max_height_ok(self):
@@ -119,27 +121,31 @@ class TestPackInputBoundingBoxRestrictions(unittest.TestCase):
 
     def test_partial_result(self):
         with self.assertRaises(rpack.PackingImpossibleError) as error:
-            rpack.pack([(2, 2)]*4, max_width=3, max_height=3)
-        self.assertEqual(error.exception.args[0], 'Partial result')
+            rpack.pack([(2, 2)] * 4, max_width=3, max_height=3)
+        self.assertEqual(error.exception.args[0], "Partial result")
         self.assertEqual(error.exception.args[1], [(0, 0)])
 
     def test_partial_result_simple(self):
         sizes = [(14, 17), (10, 16)]
         max_width, max_height = (22, 25)
-        with self.assertRaisesRegex(rpack.PackingImpossibleError, 'Partial'):
+        with self.assertRaisesRegex(rpack.PackingImpossibleError, "Partial"):
             rpack.pack(sizes, max_width=max_width, max_height=max_height)
 
     def test_partial_result_width(self):
-        sizes = [(10, 1)]*10
-        with self.assertRaisesRegex(rpack.PackingImpossibleError, 'Partial') as err:
+        sizes = [(10, 1)] * 10
+        with self.assertRaisesRegex(rpack.PackingImpossibleError, "Partial") as err:
             rpack.pack(sizes, max_width=50, max_height=1)
-        self.assertCountEqual(err.exception.args[1], [(0, 0), (10, 0), (20, 0), (30, 0), (40, 0)])
+        self.assertCountEqual(
+            err.exception.args[1], [(0, 0), (10, 0), (20, 0), (30, 0), (40, 0)]
+        )
 
     def test_partial_result_height(self):
-        sizes = [(1, 10)]*10
-        with self.assertRaisesRegex(rpack.PackingImpossibleError, 'Partial') as err:
+        sizes = [(1, 10)] * 10
+        with self.assertRaisesRegex(rpack.PackingImpossibleError, "Partial") as err:
             rpack.pack(sizes, max_width=1, max_height=50)
-        self.assertCountEqual(err.exception.args[1], [(0, 0), (0, 10), (0, 20), (0, 30), (0, 40)])
+        self.assertCountEqual(
+            err.exception.args[1], [(0, 0), (0, 10), (0, 20), (0, 30), (0, 40)]
+        )
 
     def test_max_width_height_square(self):
         for i in range(1, 101):
@@ -197,7 +203,7 @@ class TestPackInputBoundingBoxRestrictions(unittest.TestCase):
     def test_max_width_height_minimal_no_overlap(self):
         sizes = [(11, 17), (11, 6)]
         max_width, max_height = (21, 22)
-        with self.assertRaisesRegex(rpack.PackingImpossibleError, 'Partial'):
+        with self.assertRaisesRegex(rpack.PackingImpossibleError, "Partial"):
             rpack.pack(sizes, max_width=max_width, max_height=max_height)
 
     @unittest.skip("long running")
@@ -208,8 +214,8 @@ class TestPackInputBoundingBoxRestrictions(unittest.TestCase):
                 n = random.randint(1, 20)
                 m = 20
                 sizes = [(random.randint(1, m), random.randint(1, m)) for _ in range(n)]
-                max_width = random.randint(1, m*n + 10)
-                max_height = random.randint(1, m*n + 10)
+                max_width = random.randint(1, m * n + 10)
+                max_height = random.randint(1, m * n + 10)
                 try:
                     pos = rpack.pack(sizes, max_width=max_width, max_height=max_height)
                 except rpack.PackingImpossibleError:
@@ -226,6 +232,7 @@ class TestPackInputBoundingBoxRestrictions(unittest.TestCase):
 # TEST OUTPUT
 # ===========
 
+
 class TestPackOutput(unittest.TestCase):
     """Test/compare output of rpack.pack"""
 
@@ -253,21 +260,22 @@ class TestPackOutput(unittest.TestCase):
         sizes = [(2, 2), (2, 2), (2, 2), (3, 3)]
         pos = rpack.pack(sizes)
         width, height = rpack.enclosing_size(sizes, pos)
-        self.assertEqual(width*height, 25)
+        self.assertEqual(width * height, 25)
 
     def test_medium_pack(self):
         sizes = [(i, i) for i in range(20, 1, -1)]
         pos = rpack.pack(sizes)
         width, height = rpack.enclosing_size(sizes, pos)
-        self.assertLessEqual(width*height, 3045)
+        self.assertLessEqual(width * height, 3045)
 
     def test_no_overlap(self):
         """Make sure no rectangles overlap"""
         for i in range(10, 101, 10):
             with self.subTest(seed=i):
                 random.seed(i)
-                sizes = [(random.randint(1, i), random.randint(1, i))
-                         for _ in range(110 - i)]
+                sizes = [
+                    (random.randint(1, i), random.randint(1, i)) for _ in range(110 - i)
+                ]
                 pos = rpack.pack(sizes)
                 self.assertFalse(rpack._core.overlapping(sizes, pos))
 
@@ -281,4 +289,5 @@ class TestPackOutput(unittest.TestCase):
             self.assertFalse(rpack._core.overlapping(sizes, pos2))
             self.assertLessEqual(
                 rpack._core.packing_density(sizes, pos1),
-                rpack._core.packing_density(sizes, pos2))
+                rpack._core.packing_density(sizes, pos2),
+            )
