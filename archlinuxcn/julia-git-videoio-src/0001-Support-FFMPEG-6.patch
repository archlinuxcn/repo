From 583c26f4146dbfcbc4ad8546638c6d299681ec1d Mon Sep 17 00:00:00 2001
From: theogf <theo.galyfajou@gmail.com>
Date: Sat, 17 Feb 2024 13:25:55 +0100
Subject: [PATCH] Support FFMPEG 6

---
 .github/workflows/CI.yml |     6 +
 Project.toml             |     4 +-
 gen/Project.toml         |     5 +-
 gen/generate.jl          |     5 +-
 gen/generate.toml        |     3 +-
 lib/libffmpeg.jl         | 12746 ++++++++++++++++++++-----------------
 src/VideoIO.jl           |     1 -
 src/avio.jl              |     8 +-
 8 files changed, 6868 insertions(+), 5910 deletions(-)

diff --git a/.github/workflows/CI.yml b/.github/workflows/CI.yml
index 1646219..ca1cbb0 100644
--- a/.github/workflows/CI.yml
+++ b/.github/workflows/CI.yml
@@ -52,6 +52,12 @@ jobs:
         with:
           version: ${{ matrix.julia-version }}
       - uses: julia-actions/cache@v1
+      - name: Configure new FFMPEG version environment
+        shell: julia --project="." --color=yes {0}
+        run: |
+          using Pkg
+          Pkg.add(PackageSpec(url="https://github.com/theogf/FFMPEG.jl", rev="tgf/update-FFMPEG"))
+          Pkg.instantiate()
       - uses: julia-actions/julia-runtest@v1
       - uses: julia-actions/julia-processcoverage@v1
       - uses: codecov/codecov-action@v4
diff --git a/Project.toml b/Project.toml
index 618e033..8ab29d7 100644
--- a/Project.toml
+++ b/Project.toml
@@ -17,8 +17,8 @@ Scratch = "6c6a2e73-6563-6170-7368-637461726353"
 [compat]
 ColorTypes = "0.9, 0.10, 0.11"
 Downloads = "1.3"
-FFMPEG = "0.3, 0.4"
-FFMPEG_jll = "4.1"
+FFMPEG = "0.3, 0.4, 1"
+FFMPEG_jll = "6.1"
 FileIO = "1.6"
 Glob = "1.2"
 ImageCore = "0.8, 0.9, 0.10"
diff --git a/gen/Project.toml b/gen/Project.toml
index c913423..8fa3ef8 100644
--- a/gen/Project.toml
+++ b/gen/Project.toml
@@ -1,8 +1,9 @@
 [deps]
 Clang = "40e3b903-d033-50b4-a0cc-940c62c95e31"
-FFMPEG = "c87230d0-a227-11e9-1b43-d7ebe4e7570a"
+FFMPEG_jll = "b22a6f82-2f65-5046-a5b2-351ab43fb4e5"
 Match = "7eb4fadd-790c-5f42-8a69-bfa0b872bfbf"
 Vulkan_Headers_jll = "8d446b21-f3ad-5576-a034-752265b9b6f9"
 
 [compat]
-Clang = "0.14.0"
+Clang = "0.14, 0.15, 0.16, 0.17"
+FFMPEG_jll = "0.6.1"
diff --git a/gen/generate.jl b/gen/generate.jl
index 71a84b2..543de66 100644
--- a/gen/generate.jl
+++ b/gen/generate.jl
@@ -1,6 +1,5 @@
 using Clang.Generators
-using FFMPEG
-using FFMPEG.FFMPEG_jll
+using FFMPEG_jll
 using Vulkan_Headers_jll
 using LibGit2
 include("rewriter.jl")
@@ -9,7 +8,7 @@ cd(@__DIR__)
 
 # Ideally I could have loaded all headers, but it turns out to be too hard
 
-include_dir = joinpath(FFMPEG.FFMPEG_jll.artifact_dir, "include") |> normpath
+include_dir = joinpath(FFMPEG_jll.artifact_dir, "include") |> normpath
 
 vulkan_dir = joinpath(Vulkan_Headers_jll.artifact_dir, "include") |> normpath
 
diff --git a/gen/generate.toml b/gen/generate.toml
index 5fabd0b..05a1df0 100644
--- a/gen/generate.toml
+++ b/gen/generate.toml
@@ -23,7 +23,8 @@ printer_blacklist = [
     "AVPROBE_SCORE_MAX",
     "Picture",
     "AV_BPRINT_SIZE_UNLIMITED",
-    "FF_CEIL_RSHIFT"
+    "FF_CEIL_RSHIFT",
+    "AV_CHANNEL_LAYOUT_.*"
 ]
 extract_c_comment_style = "doxygen"
 [codegen]
diff --git a/lib/libffmpeg.jl b/lib/libffmpeg.jl
index e3007ce..30a5a8e 100644
--- a/lib/libffmpeg.jl
+++ b/lib/libffmpeg.jl
@@ -8,12 +8,12 @@ const time_t = Int
 
 const AV_NOPTS_VALUE = 0x8000000000000000 % Int64
 AV_VERSION_INT(a, b, c) = (a << 16 | b << 8) | c
-AV_VERSION(a,b,c) = nothing
+AV_VERSION(a, b, c) = nothing
 const AVPROBE_SCORE_MAX = 100
-MKTAG(a,b,c,d) = (UInt32(a) | (UInt32(b) << 8) | (UInt32(c) << 16) | UInt32(d) << 24)
-FFERRTAG(a,b,c,d) = -MKTAG(a,b,c,d)
+MKTAG(a, b, c, d) = (UInt32(a) | (UInt32(b) << 8) | (UInt32(c) << 16) | UInt32(d) << 24)
+FFERRTAG(a, b, c, d) = -MKTAG(a, b, c, d)
 macro AV_PIX_FMT_NE(be, le)
-    Symbol("AV_PIX_FMT_"*string(le))
+    return Symbol("AV_PIX_FMT_" * string(le))
 end
 
 
@@ -21,12 +21,18 @@ const VdpChromaType = UInt32
 
 const VdpDevice = UInt32
 
-const VdpDecoderProfile = UInt32
-
 const VdpDecoder = UInt32
 
+# typedef VdpStatus VdpDecoderRender ( VdpDecoder decoder , VdpVideoSurface target , VdpPictureInfo const * picture_info , uint32_t bitstream_buffer_count , VdpBitstreamBuffer const * bitstream_buffers )
+const VdpDecoderRender = Cvoid
+
+# typedef VdpStatus VdpGetProcAddress ( VdpDevice device , VdpFuncId function_id , /* output parameters follow */ void * * function_pointer )
+const VdpGetProcAddress = Cvoid
+
 const VkBool32 = UInt32
 
+const VkFlags = UInt32
+
 mutable struct VkImage_T end
 
 const VkImage = Ptr{VkImage_T}
@@ -216,6 +222,58 @@ const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001 % UInt32
 const VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002 % UInt32
 const VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003 % UInt32
 const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES = 53 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES = 54 % UInt32
+const VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000 % UInt32
+const VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001 % UInt32
+const VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000 % UInt32
+const VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 = 1000314000 % UInt32
+const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 1000314001 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 1000314002 % UInt32
+const VK_STRUCTURE_TYPE_DEPENDENCY_INFO = 1000314003 % UInt32
+const VK_STRUCTURE_TYPE_SUBMIT_INFO_2 = 1000314004 % UInt32
+const VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 1000314005 % UInt32
+const VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 1000314006 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000 % UInt32
+const VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 1000337000 % UInt32
+const VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 1000337001 % UInt32
+const VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002 % UInt32
+const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003 % UInt32
+const VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 1000337004 % UInt32
+const VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 1000337005 % UInt32
+const VK_STRUCTURE_TYPE_BUFFER_COPY_2 = 1000337006 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_COPY_2 = 1000337007 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_BLIT_2 = 1000337008 % UInt32
+const VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 1000337009 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 1000337010 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000 % UInt32
+const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001 % UInt32
+const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002 % UInt32
+const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000 % UInt32
+const VK_STRUCTURE_TYPE_RENDERING_INFO = 1000044000 % UInt32
+const VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 1000044001 % UInt32
+const VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 1000044002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003 % UInt32
+const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001 % UInt32
+const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 1000360000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001 % UInt32
+const VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002 % UInt32
+const VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003 % UInt32
 const VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000 % UInt32
 const VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001 % UInt32
 const VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007 % UInt32
@@ -237,15 +295,48 @@ const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1
 const VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000 % UInt32
 const VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001 % UInt32
 const VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR = 1000023000 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR = 1000023002 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR = 1000023003 % UInt32
+const VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR = 1000023004 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR = 1000023011 % UInt32
+const VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR = 1000023012 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR = 1000023013 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015 % UInt32
+const VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR = 1000023016 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR = 1000024001 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR = 1000024002 % UInt32
 const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000 % UInt32
 const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001 % UInt32
 const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001 % UInt32
 const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002 % UInt32
+const VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000 % UInt32
+const VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001 % UInt32
+const VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002 % UInt32
 const VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000 % UInt32
 const VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR = 1000040000 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR = 1000040001 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR = 1000040003 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000040004 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000040005 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR = 1000040006 % UInt32
 const VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000 % UInt32
+const VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006 % UInt32
+const VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007 % UInt32
+const VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008 % UInt32
+const VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009 % UInt32
 const VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000 % UInt32
 const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000 % UInt32
@@ -255,9 +346,11 @@ const VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001 % UInt32
 const VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000 % UInt32
 const VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000 % UInt32
 const VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = 1000066000 % UInt32
 const VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001 % UInt32
+const VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT = 1000068000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT = 1000068001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT = 1000068002 % UInt32
 const VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000 % UInt32
 const VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001 % UInt32
 const VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002 % UInt32
@@ -327,10 +420,7 @@ const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000
 const VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003 % UInt32
 const VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004 % UInt32
 const VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001 % UInt32
-const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002 % UInt32
-const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003 % UInt32
+const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006 % UInt32
 const VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000 % UInt32
 const VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001 % UInt32
 const VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002 % UInt32
@@ -369,6 +459,7 @@ const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 100
 const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003 % UInt32
 const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004 % UInt32
 const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005 % UInt32
+const VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006 % UInt32
 const VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000 % UInt32
 const VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001 % UInt32
 const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000 % UInt32
@@ -390,7 +481,6 @@ const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV
 const VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000 % UInt32
 const VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001 % UInt32
-const VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000 % UInt32
 const VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000 % UInt32
 const VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002 % UInt32
@@ -398,16 +488,23 @@ const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000 %
 const VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000 % UInt32
 const VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR = 1000187000 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000187001 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000187002 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR = 1000187003 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR = 1000187004 % UInt32
+const VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR = 1000187005 % UInt32
+const VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR = 1000174000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR = 1000388000 % UInt32
+const VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR = 1000388001 % UInt32
 const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000 % UInt32
 const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002 % UInt32
 const VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000 % UInt32
-const VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000 % UInt32
 const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002 % UInt32
@@ -424,14 +521,10 @@ const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000
 const VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000 % UInt32
 const VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001 % UInt32
 const VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR = 1000215000 % UInt32
 const VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001 % UInt32
 const VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = 1000225000 % UInt32
-const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = 1000225001 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = 1000225002 % UInt32
 const VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000 % UInt32
 const VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002 % UInt32
@@ -447,8 +540,8 @@ const VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000 % UInt32
 const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = 1000245000 % UInt32
 const VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000 % UInt32
 const VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002 % UInt32
@@ -476,7 +569,16 @@ const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002 % UInt32
 const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003 % UInt32
 const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004 % UInt32
 const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 1000276000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000 % UInt32
+const VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT = 1000274000 % UInt32
+const VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT = 1000274001 % UInt32
+const VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT = 1000274002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT = 1000275000 % UInt32
+const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT = 1000275001 % UInt32
+const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT = 1000275002 % UInt32
+const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT = 1000275003 % UInt32
+const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT = 1000275004 % UInt32
+const VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT = 1000275005 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000 % UInt32
 const VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001 % UInt32
 const VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002 % UInt32
@@ -488,7 +590,6 @@ const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV =
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000 % UInt32
 const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = 1000281001 % UInt32
 const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000 % UInt32
 const VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000 % UInt32
@@ -500,62 +601,199 @@ const VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002 % UInt32
 const VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT = 1000295000 % UInt32
-const VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT = 1000295001 % UInt32
-const VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT = 1000295002 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT = 1000297000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 1000292000 % UInt32
+const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 1000292001 % UInt32
+const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 1000292002 % UInt32
+const VK_STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000 % UInt32
 const VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001 % UInt32
-const VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR = 1000314000 % UInt32
-const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR = 1000314001 % UInt32
-const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR = 1000314002 % UInt32
-const VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR = 1000314003 % UInt32
-const VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR = 1000314004 % UInt32
-const VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR = 1000314005 % UInt32
-const VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR = 1000314006 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR = 1000314007 % UInt32
+const VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV = 1000310000 % UInt32
+const VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 1000311000 % UInt32
+const VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT = 1000311001 % UInt32
+const VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT = 1000311002 % UInt32
+const VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 1000311003 % UInt32
+const VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT = 1000311004 % UInt32
+const VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT = 1000311005 % UInt32
+const VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT = 1000311006 % UInt32
+const VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT = 1000311007 % UInt32
+const VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT = 1000311008 % UInt32
+const VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009 % UInt32
+const VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010 % UInt32
+const VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011 % UInt32
 const VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008 % UInt32
 const VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR = 1000325000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002 % UInt32
+const VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT = 1000316003 % UInt32
+const VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT = 1000316004 % UInt32
+const VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316005 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316006 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316007 % UInt32
+const VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316008 % UInt32
+const VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT = 1000316010 % UInt32
+const VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT = 1000316011 % UInt32
+const VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT = 1000316012 % UInt32
+const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316009 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 1000320000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 1000320001 % UInt32
+const VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 1000320002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 1000321000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 1000203000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 1000322000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001 % UInt32
 const VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002 % UInt32
+const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001 % UInt32
+const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 1000328000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 1000328001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001 % UInt32
 const VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT = 1000335000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000 % UInt32
-const VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR = 1000337000 % UInt32
-const VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR = 1000337001 % UInt32
-const VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR = 1000337002 % UInt32
-const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR = 1000337003 % UInt32
-const VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR = 1000337004 % UInt32
-const VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR = 1000337005 % UInt32
-const VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR = 1000337006 % UInt32
-const VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR = 1000337007 % UInt32
-const VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR = 1000337008 % UInt32
-const VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR = 1000337009 % UInt32
-const VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR = 1000337010 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 1000338000 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT = 1000338001 % UInt32
+const VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT = 1000338002 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT = 1000338003 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT = 1000338004 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 1000339000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 1000341000 % UInt32
+const VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT = 1000341001 % UInt32
+const VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT = 1000341002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000 % UInt32
 const VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000 % UInt32
-const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE = 1000351000 % UInt32
-const VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE = 1000351002 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000 % UInt32
 const VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001 % UInt32
 const VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 1000354000 % UInt32
+const VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 1000354001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000 % UInt32
+const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000 % UInt32
 const VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000 % UInt32
 const VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001 % UInt32
 const VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002 % UInt32
 const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000 % UInt32
 const VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001 % UInt32
+const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000 % UInt32
+const VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001 % UInt32
+const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002 % UInt32
+const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003 % UInt32
+const VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004 % UInt32
+const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007 % UInt32
+const VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008 % UInt32
+const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009 % UInt32
+const VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000 % UInt32
+const VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001 % UInt32
+const VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT = 1000372000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 1000372001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 1000376000 % UInt32
+const VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 1000376001 % UInt32
+const VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 1000376002 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000 % UInt32
 const VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000 % UInt32
 const VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 1000382000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 1000386000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 1000393000 % UInt32
+const VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT = 1000396000 % UInt32
+const VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT = 1000396001 % UInt32
+const VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT = 1000396002 % UInt32
+const VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT = 1000396003 % UInt32
+const VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT = 1000396004 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 1000396005 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 1000396006 % UInt32
+const VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 1000396007 % UInt32
+const VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008 % UInt32
+const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI = 1000404000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI = 1000404001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000 % UInt32
+const VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM = 1000415000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT = 1000418000 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT = 1000418001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000 % UInt32
+const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001 % UInt32
+const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT = 1000421000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 1000422000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM = 1000425000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM = 1000425001 % UInt32
+const VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM = 1000425002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV = 1000426000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV = 1000426001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV = 1000427000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV = 1000427001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 1000437000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 1000440000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 1000440001 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 1000440002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 1000455000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 1000455001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 1000458000 % UInt32
+const VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT = 1000458001 % UInt32
+const VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000458002 % UInt32
+const VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 1000458003 % UInt32
+const VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG = 1000459000 % UInt32
+const VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG = 1000459001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 1000462000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 1000462001 % UInt32
+const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 1000462002 % UInt32
+const VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT = 1000462003 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 1000342000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 1000464000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 1000464001 % UInt32
+const VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 1000464002 % UInt32
+const VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 1000464003 % UInt32
+const VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 1000464004 % UInt32
+const VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005 % UInt32
+const VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT = 1000466000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 1000484000 % UInt32
+const VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM = 1000484001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 1000485000 % UInt32
+const VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC = 1000485001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM = 1000488000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV = 1000490000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV = 1000490001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 1000351000 % UInt32
+const VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 1000351002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 1000497000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT = 1000498000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM = 1000510000 % UInt32
+const VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM = 1000510001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = 1000120000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = 1000063000 % UInt32
 const VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = 1000011000 % UInt32
+const VK_STRUCTURE_TYPE_RENDERING_INFO_KHR = 1000044000 % UInt32
+const VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR = 1000044001 % UInt32
+const VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR = 1000044002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR = 1000044003 % UInt32
+const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR = 1000044004 % UInt32
+const VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV = 1000044008 % UInt32
 const VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = 1000053000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = 1000053001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = 1000053002 % UInt32
@@ -575,6 +813,7 @@ const VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = 1000060005 % UInt32
 const VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = 1000060006 % UInt32
 const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060013 % UInt32
 const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060014 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = 1000066000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = 1000070000 % UInt32
 const VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = 1000070001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = 1000071000 % UInt32
@@ -617,6 +856,10 @@ const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = 1000127000 % UInt32
 const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = 1000127001 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000 % UInt32
 const VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001 % UInt32
+const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002 % UInt32
+const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003 % UInt32
 const VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146000 % UInt32
 const VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146001 % UInt32
 const VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146002 % UInt32
@@ -638,13 +881,16 @@ const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_E
 const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = 1000161004 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = 1000168000 % UInt32
 const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = 1000168001 % UInt32
+const VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = 1000175000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = 1000177000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = 1000180000 % UInt32
+const VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = 1000196000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = 1000197000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = 1000199000 % UInt32
 const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = 1000199001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR = 1000207000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR = 1000207001 % UInt32
 const VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR = 1000207002 % UInt32
@@ -653,12 +899,17 @@ const VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR = 1000207004 % UInt32
 const VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR = 1000207005 % UInt32
 const VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL = 1000210000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = 1000211000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR = 1000215000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = 1000221000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = 1000225000 % UInt32
+const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = 1000225001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = 1000225002 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = 1000241000 % UInt32
 const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = 1000241001 % UInt32
 const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = 1000241002 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = 1000244000 % UInt32
 const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = 1000244001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = 1000245000 % UInt32
 const VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = 1000246000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = 1000253000 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR = 1000257000 % UInt32
@@ -667,6 +918,46 @@ const VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = 10002570
 const VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = 1000257003 % UInt32
 const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = 1000257004 % UInt32
 const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = 1000261000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 1000276000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR = 1000280000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR = 1000280001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = 1000281001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT = 1000295000 % UInt32
+const VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT = 1000295001 % UInt32
+const VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT = 1000295002 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT = 1000297000 % UInt32
+const VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR = 1000314000 % UInt32
+const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR = 1000314001 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR = 1000314002 % UInt32
+const VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR = 1000314003 % UInt32
+const VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR = 1000314004 % UInt32
+const VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR = 1000314005 % UInt32
+const VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR = 1000314006 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR = 1000314007 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR = 1000325000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT = 1000335000 % UInt32
+const VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR = 1000337000 % UInt32
+const VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR = 1000337001 % UInt32
+const VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR = 1000337002 % UInt32
+const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR = 1000337003 % UInt32
+const VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR = 1000337004 % UInt32
+const VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR = 1000337005 % UInt32
+const VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR = 1000337006 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR = 1000337007 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR = 1000337008 % UInt32
+const VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR = 1000337009 % UInt32
+const VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR = 1000337010 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM = 1000342000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE = 1000351000 % UInt32
+const VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE = 1000351002 % UInt32
+const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR = 1000360000 % UInt32
+const VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT = 1000269001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT = 1000388000 % UInt32
+const VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT = 1000388001 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR = 1000413000 % UInt32
+const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR = 1000413001 % UInt32
+const VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR = 1000413002 % UInt32
+const VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR = 1000413003 % UInt32
 const VK_STRUCTURE_TYPE_MAX_ENUM = 2147483647 % UInt32
 
 const VkImageLayout = UInt32
@@ -685,19 +976,25 @@ const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000 % UInt32
 const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001 % UInt32
 const VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002 % UInt32
 const VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003 % UInt32
+const VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000 % UInt32
+const VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001 % UInt32
 const VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002 % UInt32
+const VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000 % UInt32
+const VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001 % UInt32
+const VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002 % UInt32
 const VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000 % UInt32
-const VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = 1000164003 % UInt32
 const VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000 % UInt32
-const VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = 1000314000 % UInt32
-const VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = 1000314001 % UInt32
+const VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003 % UInt32
+const VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000 % UInt32
 const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000117000 % UInt32
 const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000117001 % UInt32
-const VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003 % UInt32
+const VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = 1000164003 % UInt32
 const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = 1000241000 % UInt32
 const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = 1000241001 % UInt32
 const VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000241002 % UInt32
 const VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000241003 % UInt32
+const VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = 1000314000 % UInt32
+const VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = 1000314001 % UInt32
 const VK_IMAGE_LAYOUT_MAX_ENUM = 2147483647 % UInt32
 
 const VkFormat = UInt32
@@ -920,6 +1217,26 @@ const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030 % UInt32
 const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031 % UInt32
 const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032 % UInt32
 const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033 % UInt32
+const VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000 % UInt32
+const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001 % UInt32
+const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002 % UInt32
+const VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003 % UInt32
+const VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000 % UInt32
+const VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001 % UInt32
+const VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000 % UInt32
+const VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001 % UInt32
+const VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002 % UInt32
+const VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003 % UInt32
+const VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004 % UInt32
+const VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005 % UInt32
+const VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006 % UInt32
+const VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007 % UInt32
+const VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008 % UInt32
+const VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009 % UInt32
+const VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010 % UInt32
+const VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011 % UInt32
+const VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012 % UInt32
+const VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013 % UInt32
 const VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000 % UInt32
 const VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001 % UInt32
 const VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002 % UInt32
@@ -928,6 +1245,7 @@ const VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004 % UInt32
 const VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005 % UInt32
 const VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006 % UInt32
 const VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007 % UInt32
+const VK_FORMAT_R16G16_S10_5_NV = 1000464000 % UInt32
 const VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000 % UInt32
 const VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001 % UInt32
 const VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002 % UInt32
@@ -942,12 +1260,6 @@ const VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010 % UInt32
 const VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011 % UInt32
 const VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012 % UInt32
 const VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013 % UInt32
-const VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT = 1000330000 % UInt32
-const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = 1000330001 % UInt32
-const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = 1000330002 % UInt32
-const VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT = 1000330003 % UInt32
-const VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = 1000340000 % UInt32
-const VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = 1000340001 % UInt32
 const VK_FORMAT_G8B8G8R8_422_UNORM_KHR = 1000156000 % UInt32
 const VK_FORMAT_B8G8R8G8_422_UNORM_KHR = 1000156001 % UInt32
 const VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = 1000156002 % UInt32
@@ -982,6 +1294,12 @@ const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = 1000156030 % UInt32
 const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = 1000156031 % UInt32
 const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = 1000156032 % UInt32
 const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = 1000156033 % UInt32
+const VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT = 1000330000 % UInt32
+const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = 1000330001 % UInt32
+const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = 1000330002 % UInt32
+const VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT = 1000330003 % UInt32
+const VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = 1000340000 % UInt32
+const VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = 1000340001 % UInt32
 const VK_FORMAT_MAX_ENUM = 2147483647 % UInt32
 
 const VkImageTiling = UInt32
@@ -1008,6 +1326,7 @@ const VK_ACCESS_HOST_READ_BIT = 8192 % UInt32
 const VK_ACCESS_HOST_WRITE_BIT = 16384 % UInt32
 const VK_ACCESS_MEMORY_READ_BIT = 32768 % UInt32
 const VK_ACCESS_MEMORY_WRITE_BIT = 65536 % UInt32
+const VK_ACCESS_NONE = 0 % UInt32
 const VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 33554432 % UInt32
 const VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 67108864 % UInt32
 const VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 134217728 % UInt32
@@ -1015,16 +1334,18 @@ const VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 1048576 % UInt32
 const VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 524288 % UInt32
 const VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 2097152 % UInt32
 const VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 4194304 % UInt32
-const VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = 8388608 % UInt32
 const VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 16777216 % UInt32
+const VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 8388608 % UInt32
 const VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = 131072 % UInt32
 const VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = 262144 % UInt32
-const VK_ACCESS_NONE_KHR = 0 % UInt32
+const VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = 8388608 % UInt32
 const VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = 2097152 % UInt32
 const VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 4194304 % UInt32
-const VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 8388608 % UInt32
+const VK_ACCESS_NONE_KHR = 0 % UInt32
 const VK_ACCESS_FLAG_BITS_MAX_ENUM = 2147483647 % UInt32
 
+const VkImageCreateFlags = VkFlags
+
 const VkImageUsageFlagBits = UInt32
 const VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 1 % UInt32
 const VK_IMAGE_USAGE_TRANSFER_DST_BIT = 2 % UInt32
@@ -1034,9 +1355,16 @@ const VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16 % UInt32
 const VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32 % UInt32
 const VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64 % UInt32
 const VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128 % UInt32
-const VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = 256 % UInt32
+const VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 1024 % UInt32
+const VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 2048 % UInt32
+const VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 4096 % UInt32
 const VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 512 % UInt32
 const VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 256 % UInt32
+const VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 524288 % UInt32
+const VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 262144 % UInt32
+const VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM = 1048576 % UInt32
+const VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM = 2097152 % UInt32
+const VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = 256 % UInt32
 const VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 2147483647 % UInt32
 
 const VkMemoryPropertyFlagBits = UInt32
@@ -1048,6 +1376,7 @@ const VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 16 % UInt32
 const VK_MEMORY_PROPERTY_PROTECTED_BIT = 32 % UInt32
 const VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 64 % UInt32
 const VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 128 % UInt32
+const VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 256 % UInt32
 const VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 2147483647 % UInt32
 
 # typedef void * ( VKAPI_PTR * PFN_vkAllocationFunction ) ( void * pUserData , size_t size , size_t alignment , VkSystemAllocationScope allocationScope )
@@ -1132,6 +1461,9 @@ struct VkPhysicalDeviceFeatures
     inheritedQueries::VkBool32
 end
 
+# typedef PFN_vkVoidFunction ( VKAPI_PTR * PFN_vkGetInstanceProcAddr ) ( VkInstance instance , const char * pName )
+const PFN_vkGetInstanceProcAddr = Ptr{Cvoid}
+
 struct VkPhysicalDeviceFeatures2
     sType::VkStructureType
     pNext::Ptr{Cvoid}
@@ -1150,15 +1482,12 @@ end
 """
     av_adts_header_parse(buf, samples, frames)
 
-Extract the number of samples and frames from AAC data. 
+Extract the number of samples and frames from AAC data.
 
 ### Parameters
-* `buf`:\\[in\\] pointer to AAC data buffer 
-
-* `samples`:\\[out\\] Pointer to where number of samples is written 
-
-* `frames`:\\[out\\] Pointer to where number of frames is written 
-
+* `buf`:\\[in\\] pointer to AAC data buffer
+* `samples`:\\[out\\] Pointer to where number of samples is written
+* `frames`:\\[out\\] Pointer to where number of frames is written
 ### Returns
 Returns 0 on success, error code on failure.
 """
@@ -1166,32 +1495,6 @@ function av_adts_header_parse(buf, samples, frames)
     ccall((:av_adts_header_parse, libavcodec), Cint, (Ptr{UInt8}, Ptr{UInt32}, Ptr{UInt8}), buf, samples, frames)
 end
 
-"""
-    AVDiscard
-
-` lavc_decoding`
-"""
-const AVDiscard = Int32
-const AVDISCARD_NONE = -16 % Int32
-const AVDISCARD_DEFAULT = 0 % Int32
-const AVDISCARD_NONREF = 8 % Int32
-const AVDISCARD_BIDIR = 16 % Int32
-const AVDISCARD_NONINTRA = 24 % Int32
-const AVDISCARD_NONKEY = 32 % Int32
-const AVDISCARD_ALL = 48 % Int32
-
-const AVAudioServiceType = UInt32
-const AV_AUDIO_SERVICE_TYPE_MAIN = 0 % UInt32
-const AV_AUDIO_SERVICE_TYPE_EFFECTS = 1 % UInt32
-const AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2 % UInt32
-const AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3 % UInt32
-const AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4 % UInt32
-const AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5 % UInt32
-const AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6 % UInt32
-const AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7 % UInt32
-const AV_AUDIO_SERVICE_TYPE_KARAOKE = 8 % UInt32
-const AV_AUDIO_SERVICE_TYPE_NB = 9 % UInt32
-
 """
     RcOverride
 
@@ -1204,41 +1507,6 @@ struct RcOverride
     quality_factor::Cfloat
 end
 
-"""
-    AVPanScan
-
-Pan Scan area. This specifies the area which should be displayed. Note there may be multiple such areas for one frame.
-"""
-struct AVPanScan
-    id::Cint
-    width::Cint
-    height::Cint
-    position::NTuple{3, NTuple{2, Int16}}
-end
-
-"""
-    AVCPBProperties
-
-This structure describes the bitrate properties of an encoded bitstream. It roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD parameters for H.264/HEVC.
-"""
-struct AVCPBProperties
-    max_bitrate::Cint
-    min_bitrate::Cint
-    avg_bitrate::Cint
-    buffer_size::Cint
-    vbv_delay::UInt64
-end
-
-"""
-    AVProducerReferenceTime
-
-This structure supplies correlation between a packet timestamp and a wall clock production time. The definition follows the Producer Reference Time ('prft') as defined in ISO/IEC 14496-12
-"""
-struct AVProducerReferenceTime
-    wallclock::Int64
-    flags::Cint
-end
-
 """
     AVOptionType
 
@@ -1254,7 +1522,7 @@ This section describes how to add AVOptions capabilities to a struct.
 
 All AVOptions-related information is stored in an [`AVClass`](@ref). Therefore the first member of the struct should be a pointer to an [`AVClass`](@ref) describing it. The option field of the [`AVClass`](@ref) must be set to a NULL-terminated static array of AVOptions. Each [`AVOption`](@ref) must have a non-empty name, a type, a default value and for number-type AVOptions also a range of allowed values. It must also declare an offset in bytes from the start of the struct, where the field associated with this [`AVOption`](@ref) is located. Other fields in the [`AVOption`](@ref) struct should also be set when applicable, but are not required.
 
-The following example illustrates an AVOptions-enabled struct: 
+The following example illustrates an AVOptions-enabled struct:
 
 ```c++
  typedef struct test_struct {
@@ -1343,7 +1611,7 @@ From the above example it might not be clear why both child\\_next() and child\\
 
 ` avoptions_implement_named_constants Named constants`
 
-It is possible to create named constants for options. Simply set the unit field of the option the constants should apply to a string and create the constants themselves as options of type AV\\_OPT\\_TYPE\\_CONST with their unit field set to the same string. Their default\\_val field should contain the value of the named constant. For example, to add some named constants for the test\\_flags option above, put the following into the child\\_opts array: 
+It is possible to create named constants for options. Simply set the unit field of the option the constants should apply to a string and create the constants themselves as options of type AV\\_OPT\\_TYPE\\_CONST with their unit field set to the same string. Their default\\_val field should contain the value of the named constant. For example, to add some named constants for the test\\_flags option above, put the following into the child\\_opts array:
 
 ```c++
       { "test_flags", "This is a test option of flags type.",
@@ -1391,17 +1659,18 @@ const AV_OPT_TYPE_DURATION = 15 % UInt32
 const AV_OPT_TYPE_COLOR = 16 % UInt32
 const AV_OPT_TYPE_CHANNEL_LAYOUT = 17 % UInt32
 const AV_OPT_TYPE_BOOL = 18 % UInt32
+const AV_OPT_TYPE_CHLAYOUT = 19 % UInt32
 
 """
-    __JL_Ctag_1122
+    __JL_Ctag_978
 
 the default value for scalar options
 """
-struct __JL_Ctag_1122
+struct __JL_Ctag_978
     data::NTuple{8, UInt8}
 end
 
-function Base.getproperty(x::Ptr{__JL_Ctag_1122}, f::Symbol)
+function Base.getproperty(x::Ptr{__JL_Ctag_978}, f::Symbol)
     f === :i64 && return Ptr{Int64}(x + 0)
     f === :dbl && return Ptr{Cdouble}(x + 0)
     f === :str && return Ptr{Cstring}(x + 0)
@@ -1409,14 +1678,14 @@ function Base.getproperty(x::Ptr{__JL_Ctag_1122}, f::Symbol)
     return getfield(x, f)
 end
 
-function Base.getproperty(x::__JL_Ctag_1122, f::Symbol)
-    r = Ref{__JL_Ctag_1122}(x)
-    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_1122}, r)
+function Base.getproperty(x::__JL_Ctag_978, f::Symbol)
+    r = Ref{__JL_Ctag_978}(x)
+    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_978}, r)
     fptr = getproperty(ptr, f)
     GC.@preserve r unsafe_load(fptr)
 end
 
-function Base.setproperty!(x::Ptr{__JL_Ctag_1122}, f::Symbol, v)
+function Base.setproperty!(x::Ptr{__JL_Ctag_978}, f::Symbol, v)
     unsafe_store!(getproperty(x, f), v)
 end
 
@@ -1434,7 +1703,7 @@ function Base.getproperty(x::Ptr{AVOption}, f::Symbol)
     f === :help && return Ptr{Cstring}(x + 8)
     f === :offset && return Ptr{Cint}(x + 16)
     f === :type && return Ptr{AVOptionType}(x + 20)
-    f === :default_val && return Ptr{__JL_Ctag_1122}(x + 24)
+    f === :default_val && return Ptr{__JL_Ctag_978}(x + 24)
     f === :min && return Ptr{Cdouble}(x + 32)
     f === :max && return Ptr{Cdouble}(x + 40)
     f === :flags && return Ptr{Cint}(x + 48)
@@ -1479,34 +1748,17 @@ const AV_CLASS_CATEGORY_NB = 46 % UInt32
 Describe the class of an [`AVClass`](@ref) context structure. That is an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct (e.g. [`AVCodecContext`](@ref), [`AVFormatContext`](@ref) etc.).
 """
 struct AVClass
-    data::NTuple{88, UInt8}
-end
-
-function Base.getproperty(x::Ptr{AVClass}, f::Symbol)
-    f === :class_name && return Ptr{Cstring}(x + 0)
-    f === :item_name && return Ptr{Ptr{Cvoid}}(x + 8)
-    f === :option && return Ptr{Ptr{AVOption}}(x + 16)
-    f === :version && return Ptr{Cint}(x + 24)
-    f === :log_level_offset_offset && return Ptr{Cint}(x + 28)
-    f === :parent_log_context_offset && return Ptr{Cint}(x + 32)
-    f === :child_next && return Ptr{Ptr{Cvoid}}(x + 40)
-    f === :child_class_next && return Ptr{Ptr{Cvoid}}(x + 48)
-    f === :category && return Ptr{AVClassCategory}(x + 56)
-    f === :get_category && return Ptr{Ptr{Cvoid}}(x + 64)
-    f === :query_ranges && return Ptr{Ptr{Cvoid}}(x + 72)
-    f === :child_class_iterate && return Ptr{Ptr{Cvoid}}(x + 80)
-    return getfield(x, f)
-end
-
-function Base.getproperty(x::AVClass, f::Symbol)
-    r = Ref{AVClass}(x)
-    ptr = Base.unsafe_convert(Ptr{AVClass}, r)
-    fptr = getproperty(ptr, f)
-    GC.@preserve r unsafe_load(fptr)
-end
-
-function Base.setproperty!(x::Ptr{AVClass}, f::Symbol, v)
-    unsafe_store!(getproperty(x, f), v)
+    class_name::Cstring
+    item_name::Ptr{Cvoid}
+    option::Ptr{AVOption}
+    version::Cint
+    log_level_offset_offset::Cint
+    parent_log_context_offset::Cint
+    category::AVClassCategory
+    get_category::Ptr{Cvoid}
+    query_ranges::Ptr{Cvoid}
+    child_next::Ptr{Cvoid}
+    child_class_iterate::Ptr{Cvoid}
 end
 
 """
@@ -1732,66 +1984,79 @@ const AV_CODEC_ID_PGX = 193 % UInt32
 const AV_CODEC_ID_AVS3 = 194 % UInt32
 const AV_CODEC_ID_MSP2 = 195 % UInt32
 const AV_CODEC_ID_VVC = 196 % UInt32
-const AV_CODEC_ID_Y41P = 32768 % UInt32
-const AV_CODEC_ID_AVRP = 32769 % UInt32
-const AV_CODEC_ID_012V = 32770 % UInt32
-const AV_CODEC_ID_AVUI = 32771 % UInt32
-const AV_CODEC_ID_AYUV = 32772 % UInt32
-const AV_CODEC_ID_TARGA_Y216 = 32773 % UInt32
-const AV_CODEC_ID_V308 = 32774 % UInt32
-const AV_CODEC_ID_V408 = 32775 % UInt32
-const AV_CODEC_ID_YUV4 = 32776 % UInt32
-const AV_CODEC_ID_AVRN = 32777 % UInt32
-const AV_CODEC_ID_CPIA = 32778 % UInt32
-const AV_CODEC_ID_XFACE = 32779 % UInt32
-const AV_CODEC_ID_SNOW = 32780 % UInt32
-const AV_CODEC_ID_SMVJPEG = 32781 % UInt32
-const AV_CODEC_ID_APNG = 32782 % UInt32
-const AV_CODEC_ID_DAALA = 32783 % UInt32
-const AV_CODEC_ID_CFHD = 32784 % UInt32
-const AV_CODEC_ID_TRUEMOTION2RT = 32785 % UInt32
-const AV_CODEC_ID_M101 = 32786 % UInt32
-const AV_CODEC_ID_MAGICYUV = 32787 % UInt32
-const AV_CODEC_ID_SHEERVIDEO = 32788 % UInt32
-const AV_CODEC_ID_YLC = 32789 % UInt32
-const AV_CODEC_ID_PSD = 32790 % UInt32
-const AV_CODEC_ID_PIXLET = 32791 % UInt32
-const AV_CODEC_ID_SPEEDHQ = 32792 % UInt32
-const AV_CODEC_ID_FMVC = 32793 % UInt32
-const AV_CODEC_ID_SCPR = 32794 % UInt32
-const AV_CODEC_ID_CLEARVIDEO = 32795 % UInt32
-const AV_CODEC_ID_XPM = 32796 % UInt32
-const AV_CODEC_ID_AV1 = 32797 % UInt32
-const AV_CODEC_ID_BITPACKED = 32798 % UInt32
-const AV_CODEC_ID_MSCC = 32799 % UInt32
-const AV_CODEC_ID_SRGC = 32800 % UInt32
-const AV_CODEC_ID_SVG = 32801 % UInt32
-const AV_CODEC_ID_GDV = 32802 % UInt32
-const AV_CODEC_ID_FITS = 32803 % UInt32
-const AV_CODEC_ID_IMM4 = 32804 % UInt32
-const AV_CODEC_ID_PROSUMER = 32805 % UInt32
-const AV_CODEC_ID_MWSC = 32806 % UInt32
-const AV_CODEC_ID_WCMV = 32807 % UInt32
-const AV_CODEC_ID_RASC = 32808 % UInt32
-const AV_CODEC_ID_HYMT = 32809 % UInt32
-const AV_CODEC_ID_ARBC = 32810 % UInt32
-const AV_CODEC_ID_AGM = 32811 % UInt32
-const AV_CODEC_ID_LSCR = 32812 % UInt32
-const AV_CODEC_ID_VP4 = 32813 % UInt32
-const AV_CODEC_ID_IMM5 = 32814 % UInt32
-const AV_CODEC_ID_MVDV = 32815 % UInt32
-const AV_CODEC_ID_MVHA = 32816 % UInt32
-const AV_CODEC_ID_CDTOONS = 32817 % UInt32
-const AV_CODEC_ID_MV30 = 32818 % UInt32
-const AV_CODEC_ID_NOTCHLC = 32819 % UInt32
-const AV_CODEC_ID_PFM = 32820 % UInt32
-const AV_CODEC_ID_MOBICLIP = 32821 % UInt32
-const AV_CODEC_ID_PHOTOCD = 32822 % UInt32
-const AV_CODEC_ID_IPU = 32823 % UInt32
-const AV_CODEC_ID_ARGO = 32824 % UInt32
-const AV_CODEC_ID_CRI = 32825 % UInt32
-const AV_CODEC_ID_SIMBIOSIS_IMX = 32826 % UInt32
-const AV_CODEC_ID_SGA_VIDEO = 32827 % UInt32
+const AV_CODEC_ID_Y41P = 197 % UInt32
+const AV_CODEC_ID_AVRP = 198 % UInt32
+const AV_CODEC_ID_012V = 199 % UInt32
+const AV_CODEC_ID_AVUI = 200 % UInt32
+const AV_CODEC_ID_AYUV = 201 % UInt32
+const AV_CODEC_ID_TARGA_Y216 = 202 % UInt32
+const AV_CODEC_ID_V308 = 203 % UInt32
+const AV_CODEC_ID_V408 = 204 % UInt32
+const AV_CODEC_ID_YUV4 = 205 % UInt32
+const AV_CODEC_ID_AVRN = 206 % UInt32
+const AV_CODEC_ID_CPIA = 207 % UInt32
+const AV_CODEC_ID_XFACE = 208 % UInt32
+const AV_CODEC_ID_SNOW = 209 % UInt32
+const AV_CODEC_ID_SMVJPEG = 210 % UInt32
+const AV_CODEC_ID_APNG = 211 % UInt32
+const AV_CODEC_ID_DAALA = 212 % UInt32
+const AV_CODEC_ID_CFHD = 213 % UInt32
+const AV_CODEC_ID_TRUEMOTION2RT = 214 % UInt32
+const AV_CODEC_ID_M101 = 215 % UInt32
+const AV_CODEC_ID_MAGICYUV = 216 % UInt32
+const AV_CODEC_ID_SHEERVIDEO = 217 % UInt32
+const AV_CODEC_ID_YLC = 218 % UInt32
+const AV_CODEC_ID_PSD = 219 % UInt32
+const AV_CODEC_ID_PIXLET = 220 % UInt32
+const AV_CODEC_ID_SPEEDHQ = 221 % UInt32
+const AV_CODEC_ID_FMVC = 222 % UInt32
+const AV_CODEC_ID_SCPR = 223 % UInt32
+const AV_CODEC_ID_CLEARVIDEO = 224 % UInt32
+const AV_CODEC_ID_XPM = 225 % UInt32
+const AV_CODEC_ID_AV1 = 226 % UInt32
+const AV_CODEC_ID_BITPACKED = 227 % UInt32
+const AV_CODEC_ID_MSCC = 228 % UInt32
+const AV_CODEC_ID_SRGC = 229 % UInt32
+const AV_CODEC_ID_SVG = 230 % UInt32
+const AV_CODEC_ID_GDV = 231 % UInt32
+const AV_CODEC_ID_FITS = 232 % UInt32
+const AV_CODEC_ID_IMM4 = 233 % UInt32
+const AV_CODEC_ID_PROSUMER = 234 % UInt32
+const AV_CODEC_ID_MWSC = 235 % UInt32
+const AV_CODEC_ID_WCMV = 236 % UInt32
+const AV_CODEC_ID_RASC = 237 % UInt32
+const AV_CODEC_ID_HYMT = 238 % UInt32
+const AV_CODEC_ID_ARBC = 239 % UInt32
+const AV_CODEC_ID_AGM = 240 % UInt32
+const AV_CODEC_ID_LSCR = 241 % UInt32
+const AV_CODEC_ID_VP4 = 242 % UInt32
+const AV_CODEC_ID_IMM5 = 243 % UInt32
+const AV_CODEC_ID_MVDV = 244 % UInt32
+const AV_CODEC_ID_MVHA = 245 % UInt32
+const AV_CODEC_ID_CDTOONS = 246 % UInt32
+const AV_CODEC_ID_MV30 = 247 % UInt32
+const AV_CODEC_ID_NOTCHLC = 248 % UInt32
+const AV_CODEC_ID_PFM = 249 % UInt32
+const AV_CODEC_ID_MOBICLIP = 250 % UInt32
+const AV_CODEC_ID_PHOTOCD = 251 % UInt32
+const AV_CODEC_ID_IPU = 252 % UInt32
+const AV_CODEC_ID_ARGO = 253 % UInt32
+const AV_CODEC_ID_CRI = 254 % UInt32
+const AV_CODEC_ID_SIMBIOSIS_IMX = 255 % UInt32
+const AV_CODEC_ID_SGA_VIDEO = 256 % UInt32
+const AV_CODEC_ID_GEM = 257 % UInt32
+const AV_CODEC_ID_VBN = 258 % UInt32
+const AV_CODEC_ID_JPEGXL = 259 % UInt32
+const AV_CODEC_ID_QOI = 260 % UInt32
+const AV_CODEC_ID_PHM = 261 % UInt32
+const AV_CODEC_ID_RADIANCE_HDR = 262 % UInt32
+const AV_CODEC_ID_WBMP = 263 % UInt32
+const AV_CODEC_ID_MEDIA100 = 264 % UInt32
+const AV_CODEC_ID_VQC = 265 % UInt32
+const AV_CODEC_ID_PDV = 266 % UInt32
+const AV_CODEC_ID_EVC = 267 % UInt32
+const AV_CODEC_ID_RTV1 = 268 % UInt32
+const AV_CODEC_ID_VMIX = 269 % UInt32
 const AV_CODEC_ID_FIRST_AUDIO = 65536 % UInt32
 const AV_CODEC_ID_PCM_S16LE = 65536 % UInt32
 const AV_CODEC_ID_PCM_S16BE = 65537 % UInt32
@@ -1824,12 +2089,12 @@ const AV_CODEC_ID_PCM_S8_PLANAR = 65563 % UInt32
 const AV_CODEC_ID_PCM_S24LE_PLANAR = 65564 % UInt32
 const AV_CODEC_ID_PCM_S32LE_PLANAR = 65565 % UInt32
 const AV_CODEC_ID_PCM_S16BE_PLANAR = 65566 % UInt32
-const AV_CODEC_ID_PCM_S64LE = 67584 % UInt32
-const AV_CODEC_ID_PCM_S64BE = 67585 % UInt32
-const AV_CODEC_ID_PCM_F16LE = 67586 % UInt32
-const AV_CODEC_ID_PCM_F24LE = 67587 % UInt32
-const AV_CODEC_ID_PCM_VIDC = 67588 % UInt32
-const AV_CODEC_ID_PCM_SGA = 67589 % UInt32
+const AV_CODEC_ID_PCM_S64LE = 65567 % UInt32
+const AV_CODEC_ID_PCM_S64BE = 65568 % UInt32
+const AV_CODEC_ID_PCM_F16LE = 65569 % UInt32
+const AV_CODEC_ID_PCM_F24LE = 65570 % UInt32
+const AV_CODEC_ID_PCM_VIDC = 65571 % UInt32
+const AV_CODEC_ID_PCM_SGA = 65572 % UInt32
 const AV_CODEC_ID_ADPCM_IMA_QT = 69632 % UInt32
 const AV_CODEC_ID_ADPCM_IMA_WAV = 69633 % UInt32
 const AV_CODEC_ID_ADPCM_IMA_DK3 = 69634 % UInt32
@@ -1861,25 +2126,27 @@ const AV_CODEC_ID_ADPCM_IMA_ISS = 69659 % UInt32
 const AV_CODEC_ID_ADPCM_G722 = 69660 % UInt32
 const AV_CODEC_ID_ADPCM_IMA_APC = 69661 % UInt32
 const AV_CODEC_ID_ADPCM_VIMA = 69662 % UInt32
-const AV_CODEC_ID_ADPCM_AFC = 71680 % UInt32
-const AV_CODEC_ID_ADPCM_IMA_OKI = 71681 % UInt32
-const AV_CODEC_ID_ADPCM_DTK = 71682 % UInt32
-const AV_CODEC_ID_ADPCM_IMA_RAD = 71683 % UInt32
-const AV_CODEC_ID_ADPCM_G726LE = 71684 % UInt32
-const AV_CODEC_ID_ADPCM_THP_LE = 71685 % UInt32
-const AV_CODEC_ID_ADPCM_PSX = 71686 % UInt32
-const AV_CODEC_ID_ADPCM_AICA = 71687 % UInt32
-const AV_CODEC_ID_ADPCM_IMA_DAT4 = 71688 % UInt32
-const AV_CODEC_ID_ADPCM_MTAF = 71689 % UInt32
-const AV_CODEC_ID_ADPCM_AGM = 71690 % UInt32
-const AV_CODEC_ID_ADPCM_ARGO = 71691 % UInt32
-const AV_CODEC_ID_ADPCM_IMA_SSI = 71692 % UInt32
-const AV_CODEC_ID_ADPCM_ZORK = 71693 % UInt32
-const AV_CODEC_ID_ADPCM_IMA_APM = 71694 % UInt32
-const AV_CODEC_ID_ADPCM_IMA_ALP = 71695 % UInt32
-const AV_CODEC_ID_ADPCM_IMA_MTF = 71696 % UInt32
-const AV_CODEC_ID_ADPCM_IMA_CUNNING = 71697 % UInt32
-const AV_CODEC_ID_ADPCM_IMA_MOFLEX = 71698 % UInt32
+const AV_CODEC_ID_ADPCM_AFC = 69663 % UInt32
+const AV_CODEC_ID_ADPCM_IMA_OKI = 69664 % UInt32
+const AV_CODEC_ID_ADPCM_DTK = 69665 % UInt32
+const AV_CODEC_ID_ADPCM_IMA_RAD = 69666 % UInt32
+const AV_CODEC_ID_ADPCM_G726LE = 69667 % UInt32
+const AV_CODEC_ID_ADPCM_THP_LE = 69668 % UInt32
+const AV_CODEC_ID_ADPCM_PSX = 69669 % UInt32
+const AV_CODEC_ID_ADPCM_AICA = 69670 % UInt32
+const AV_CODEC_ID_ADPCM_IMA_DAT4 = 69671 % UInt32
+const AV_CODEC_ID_ADPCM_MTAF = 69672 % UInt32
+const AV_CODEC_ID_ADPCM_AGM = 69673 % UInt32
+const AV_CODEC_ID_ADPCM_ARGO = 69674 % UInt32
+const AV_CODEC_ID_ADPCM_IMA_SSI = 69675 % UInt32
+const AV_CODEC_ID_ADPCM_ZORK = 69676 % UInt32
+const AV_CODEC_ID_ADPCM_IMA_APM = 69677 % UInt32
+const AV_CODEC_ID_ADPCM_IMA_ALP = 69678 % UInt32
+const AV_CODEC_ID_ADPCM_IMA_MTF = 69679 % UInt32
+const AV_CODEC_ID_ADPCM_IMA_CUNNING = 69680 % UInt32
+const AV_CODEC_ID_ADPCM_IMA_MOFLEX = 69681 % UInt32
+const AV_CODEC_ID_ADPCM_IMA_ACORN = 69682 % UInt32
+const AV_CODEC_ID_ADPCM_XMD = 69683 % UInt32
 const AV_CODEC_ID_AMR_NB = 73728 % UInt32
 const AV_CODEC_ID_AMR_WB = 73729 % UInt32
 const AV_CODEC_ID_RA_144 = 77824 % UInt32
@@ -1888,9 +2155,11 @@ const AV_CODEC_ID_ROQ_DPCM = 81920 % UInt32
 const AV_CODEC_ID_INTERPLAY_DPCM = 81921 % UInt32
 const AV_CODEC_ID_XAN_DPCM = 81922 % UInt32
 const AV_CODEC_ID_SOL_DPCM = 81923 % UInt32
-const AV_CODEC_ID_SDX2_DPCM = 83968 % UInt32
-const AV_CODEC_ID_GREMLIN_DPCM = 83969 % UInt32
-const AV_CODEC_ID_DERF_DPCM = 83970 % UInt32
+const AV_CODEC_ID_SDX2_DPCM = 81924 % UInt32
+const AV_CODEC_ID_GREMLIN_DPCM = 81925 % UInt32
+const AV_CODEC_ID_DERF_DPCM = 81926 % UInt32
+const AV_CODEC_ID_WADY_DPCM = 81927 % UInt32
+const AV_CODEC_ID_CBD2_DPCM = 81928 % UInt32
 const AV_CODEC_ID_MP2 = 86016 % UInt32
 const AV_CODEC_ID_MP3 = 86017 % UInt32
 const AV_CODEC_ID_AAC = 86018 % UInt32
@@ -1959,33 +2228,43 @@ const AV_CODEC_ID_PAF_AUDIO = 86080 % UInt32
 const AV_CODEC_ID_ON2AVC = 86081 % UInt32
 const AV_CODEC_ID_DSS_SP = 86082 % UInt32
 const AV_CODEC_ID_CODEC2 = 86083 % UInt32
-const AV_CODEC_ID_FFWAVESYNTH = 88064 % UInt32
-const AV_CODEC_ID_SONIC = 88065 % UInt32
-const AV_CODEC_ID_SONIC_LS = 88066 % UInt32
-const AV_CODEC_ID_EVRC = 88067 % UInt32
-const AV_CODEC_ID_SMV = 88068 % UInt32
-const AV_CODEC_ID_DSD_LSBF = 88069 % UInt32
-const AV_CODEC_ID_DSD_MSBF = 88070 % UInt32
-const AV_CODEC_ID_DSD_LSBF_PLANAR = 88071 % UInt32
-const AV_CODEC_ID_DSD_MSBF_PLANAR = 88072 % UInt32
-const AV_CODEC_ID_4GV = 88073 % UInt32
-const AV_CODEC_ID_INTERPLAY_ACM = 88074 % UInt32
-const AV_CODEC_ID_XMA1 = 88075 % UInt32
-const AV_CODEC_ID_XMA2 = 88076 % UInt32
-const AV_CODEC_ID_DST = 88077 % UInt32
-const AV_CODEC_ID_ATRAC3AL = 88078 % UInt32
-const AV_CODEC_ID_ATRAC3PAL = 88079 % UInt32
-const AV_CODEC_ID_DOLBY_E = 88080 % UInt32
-const AV_CODEC_ID_APTX = 88081 % UInt32
-const AV_CODEC_ID_APTX_HD = 88082 % UInt32
-const AV_CODEC_ID_SBC = 88083 % UInt32
-const AV_CODEC_ID_ATRAC9 = 88084 % UInt32
-const AV_CODEC_ID_HCOM = 88085 % UInt32
-const AV_CODEC_ID_ACELP_KELVIN = 88086 % UInt32
-const AV_CODEC_ID_MPEGH_3D_AUDIO = 88087 % UInt32
-const AV_CODEC_ID_SIREN = 88088 % UInt32
-const AV_CODEC_ID_HCA = 88089 % UInt32
-const AV_CODEC_ID_FASTAUDIO = 88090 % UInt32
+const AV_CODEC_ID_FFWAVESYNTH = 86084 % UInt32
+const AV_CODEC_ID_SONIC = 86085 % UInt32
+const AV_CODEC_ID_SONIC_LS = 86086 % UInt32
+const AV_CODEC_ID_EVRC = 86087 % UInt32
+const AV_CODEC_ID_SMV = 86088 % UInt32
+const AV_CODEC_ID_DSD_LSBF = 86089 % UInt32
+const AV_CODEC_ID_DSD_MSBF = 86090 % UInt32
+const AV_CODEC_ID_DSD_LSBF_PLANAR = 86091 % UInt32
+const AV_CODEC_ID_DSD_MSBF_PLANAR = 86092 % UInt32
+const AV_CODEC_ID_4GV = 86093 % UInt32
+const AV_CODEC_ID_INTERPLAY_ACM = 86094 % UInt32
+const AV_CODEC_ID_XMA1 = 86095 % UInt32
+const AV_CODEC_ID_XMA2 = 86096 % UInt32
+const AV_CODEC_ID_DST = 86097 % UInt32
+const AV_CODEC_ID_ATRAC3AL = 86098 % UInt32
+const AV_CODEC_ID_ATRAC3PAL = 86099 % UInt32
+const AV_CODEC_ID_DOLBY_E = 86100 % UInt32
+const AV_CODEC_ID_APTX = 86101 % UInt32
+const AV_CODEC_ID_APTX_HD = 86102 % UInt32
+const AV_CODEC_ID_SBC = 86103 % UInt32
+const AV_CODEC_ID_ATRAC9 = 86104 % UInt32
+const AV_CODEC_ID_HCOM = 86105 % UInt32
+const AV_CODEC_ID_ACELP_KELVIN = 86106 % UInt32
+const AV_CODEC_ID_MPEGH_3D_AUDIO = 86107 % UInt32
+const AV_CODEC_ID_SIREN = 86108 % UInt32
+const AV_CODEC_ID_HCA = 86109 % UInt32
+const AV_CODEC_ID_FASTAUDIO = 86110 % UInt32
+const AV_CODEC_ID_MSNSIREN = 86111 % UInt32
+const AV_CODEC_ID_DFPWM = 86112 % UInt32
+const AV_CODEC_ID_BONK = 86113 % UInt32
+const AV_CODEC_ID_MISC4 = 86114 % UInt32
+const AV_CODEC_ID_APAC = 86115 % UInt32
+const AV_CODEC_ID_FTR = 86116 % UInt32
+const AV_CODEC_ID_WAVARC = 86117 % UInt32
+const AV_CODEC_ID_RKA = 86118 % UInt32
+const AV_CODEC_ID_AC4 = 86119 % UInt32
+const AV_CODEC_ID_OSQ = 86120 % UInt32
 const AV_CODEC_ID_FIRST_SUBTITLE = 94208 % UInt32
 const AV_CODEC_ID_DVD_SUBTITLE = 94208 % UInt32
 const AV_CODEC_ID_DVB_SUBTITLE = 94209 % UInt32
@@ -1996,42 +2275,43 @@ const AV_CODEC_ID_MOV_TEXT = 94213 % UInt32
 const AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214 % UInt32
 const AV_CODEC_ID_DVB_TELETEXT = 94215 % UInt32
 const AV_CODEC_ID_SRT = 94216 % UInt32
-const AV_CODEC_ID_MICRODVD = 96256 % UInt32
-const AV_CODEC_ID_EIA_608 = 96257 % UInt32
-const AV_CODEC_ID_JACOSUB = 96258 % UInt32
-const AV_CODEC_ID_SAMI = 96259 % UInt32
-const AV_CODEC_ID_REALTEXT = 96260 % UInt32
-const AV_CODEC_ID_STL = 96261 % UInt32
-const AV_CODEC_ID_SUBVIEWER1 = 96262 % UInt32
-const AV_CODEC_ID_SUBVIEWER = 96263 % UInt32
-const AV_CODEC_ID_SUBRIP = 96264 % UInt32
-const AV_CODEC_ID_WEBVTT = 96265 % UInt32
-const AV_CODEC_ID_MPL2 = 96266 % UInt32
-const AV_CODEC_ID_VPLAYER = 96267 % UInt32
-const AV_CODEC_ID_PJS = 96268 % UInt32
-const AV_CODEC_ID_ASS = 96269 % UInt32
-const AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 96270 % UInt32
-const AV_CODEC_ID_TTML = 96271 % UInt32
-const AV_CODEC_ID_ARIB_CAPTION = 96272 % UInt32
+const AV_CODEC_ID_MICRODVD = 94217 % UInt32
+const AV_CODEC_ID_EIA_608 = 94218 % UInt32
+const AV_CODEC_ID_JACOSUB = 94219 % UInt32
+const AV_CODEC_ID_SAMI = 94220 % UInt32
+const AV_CODEC_ID_REALTEXT = 94221 % UInt32
+const AV_CODEC_ID_STL = 94222 % UInt32
+const AV_CODEC_ID_SUBVIEWER1 = 94223 % UInt32
+const AV_CODEC_ID_SUBVIEWER = 94224 % UInt32
+const AV_CODEC_ID_SUBRIP = 94225 % UInt32
+const AV_CODEC_ID_WEBVTT = 94226 % UInt32
+const AV_CODEC_ID_MPL2 = 94227 % UInt32
+const AV_CODEC_ID_VPLAYER = 94228 % UInt32
+const AV_CODEC_ID_PJS = 94229 % UInt32
+const AV_CODEC_ID_ASS = 94230 % UInt32
+const AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 94231 % UInt32
+const AV_CODEC_ID_TTML = 94232 % UInt32
+const AV_CODEC_ID_ARIB_CAPTION = 94233 % UInt32
 const AV_CODEC_ID_FIRST_UNKNOWN = 98304 % UInt32
 const AV_CODEC_ID_TTF = 98304 % UInt32
 const AV_CODEC_ID_SCTE_35 = 98305 % UInt32
 const AV_CODEC_ID_EPG = 98306 % UInt32
-const AV_CODEC_ID_BINTEXT = 100352 % UInt32
-const AV_CODEC_ID_XBIN = 100353 % UInt32
-const AV_CODEC_ID_IDF = 100354 % UInt32
-const AV_CODEC_ID_OTF = 100355 % UInt32
-const AV_CODEC_ID_SMPTE_KLV = 100356 % UInt32
-const AV_CODEC_ID_DVD_NAV = 100357 % UInt32
-const AV_CODEC_ID_TIMED_ID3 = 100358 % UInt32
-const AV_CODEC_ID_BIN_DATA = 100359 % UInt32
+const AV_CODEC_ID_BINTEXT = 98307 % UInt32
+const AV_CODEC_ID_XBIN = 98308 % UInt32
+const AV_CODEC_ID_IDF = 98309 % UInt32
+const AV_CODEC_ID_OTF = 98310 % UInt32
+const AV_CODEC_ID_SMPTE_KLV = 98311 % UInt32
+const AV_CODEC_ID_DVD_NAV = 98312 % UInt32
+const AV_CODEC_ID_TIMED_ID3 = 98313 % UInt32
+const AV_CODEC_ID_BIN_DATA = 98314 % UInt32
+const AV_CODEC_ID_SMPTE_2038 = 98315 % UInt32
 const AV_CODEC_ID_PROBE = 102400 % UInt32
 const AV_CODEC_ID_MPEG2TS = 131072 % UInt32
 const AV_CODEC_ID_MPEG4SYSTEMS = 131073 % UInt32
 const AV_CODEC_ID_FFMETADATA = 135168 % UInt32
 const AV_CODEC_ID_WRAPPED_AVFRAME = 135169 % UInt32
-
-mutable struct AVCodecInternal end
+const AV_CODEC_ID_VNULL = 135170 % UInt32
+const AV_CODEC_ID_ANULL = 135171 % UInt32
 
 """
     AVRational
@@ -2106,234 +2386,415 @@ const AV_PIX_FMT_BGR565BE = 40 % Int32
 const AV_PIX_FMT_BGR565LE = 41 % Int32
 const AV_PIX_FMT_BGR555BE = 42 % Int32
 const AV_PIX_FMT_BGR555LE = 43 % Int32
-const AV_PIX_FMT_VAAPI_MOCO = 44 % Int32
-const AV_PIX_FMT_VAAPI_IDCT = 45 % Int32
-const AV_PIX_FMT_VAAPI_VLD = 46 % Int32
-const AV_PIX_FMT_VAAPI = 46 % Int32
-const AV_PIX_FMT_YUV420P16LE = 47 % Int32
-const AV_PIX_FMT_YUV420P16BE = 48 % Int32
-const AV_PIX_FMT_YUV422P16LE = 49 % Int32
-const AV_PIX_FMT_YUV422P16BE = 50 % Int32
-const AV_PIX_FMT_YUV444P16LE = 51 % Int32
-const AV_PIX_FMT_YUV444P16BE = 52 % Int32
-const AV_PIX_FMT_DXVA2_VLD = 53 % Int32
-const AV_PIX_FMT_RGB444LE = 54 % Int32
-const AV_PIX_FMT_RGB444BE = 55 % Int32
-const AV_PIX_FMT_BGR444LE = 56 % Int32
-const AV_PIX_FMT_BGR444BE = 57 % Int32
-const AV_PIX_FMT_YA8 = 58 % Int32
-const AV_PIX_FMT_Y400A = 58 % Int32
-const AV_PIX_FMT_GRAY8A = 58 % Int32
-const AV_PIX_FMT_BGR48BE = 59 % Int32
-const AV_PIX_FMT_BGR48LE = 60 % Int32
-const AV_PIX_FMT_YUV420P9BE = 61 % Int32
-const AV_PIX_FMT_YUV420P9LE = 62 % Int32
-const AV_PIX_FMT_YUV420P10BE = 63 % Int32
-const AV_PIX_FMT_YUV420P10LE = 64 % Int32
-const AV_PIX_FMT_YUV422P10BE = 65 % Int32
-const AV_PIX_FMT_YUV422P10LE = 66 % Int32
-const AV_PIX_FMT_YUV444P9BE = 67 % Int32
-const AV_PIX_FMT_YUV444P9LE = 68 % Int32
-const AV_PIX_FMT_YUV444P10BE = 69 % Int32
-const AV_PIX_FMT_YUV444P10LE = 70 % Int32
-const AV_PIX_FMT_YUV422P9BE = 71 % Int32
-const AV_PIX_FMT_YUV422P9LE = 72 % Int32
-const AV_PIX_FMT_GBRP = 73 % Int32
-const AV_PIX_FMT_GBR24P = 73 % Int32
-const AV_PIX_FMT_GBRP9BE = 74 % Int32
-const AV_PIX_FMT_GBRP9LE = 75 % Int32
-const AV_PIX_FMT_GBRP10BE = 76 % Int32
-const AV_PIX_FMT_GBRP10LE = 77 % Int32
-const AV_PIX_FMT_GBRP16BE = 78 % Int32
-const AV_PIX_FMT_GBRP16LE = 79 % Int32
-const AV_PIX_FMT_YUVA422P = 80 % Int32
-const AV_PIX_FMT_YUVA444P = 81 % Int32
-const AV_PIX_FMT_YUVA420P9BE = 82 % Int32
-const AV_PIX_FMT_YUVA420P9LE = 83 % Int32
-const AV_PIX_FMT_YUVA422P9BE = 84 % Int32
-const AV_PIX_FMT_YUVA422P9LE = 85 % Int32
-const AV_PIX_FMT_YUVA444P9BE = 86 % Int32
-const AV_PIX_FMT_YUVA444P9LE = 87 % Int32
-const AV_PIX_FMT_YUVA420P10BE = 88 % Int32
-const AV_PIX_FMT_YUVA420P10LE = 89 % Int32
-const AV_PIX_FMT_YUVA422P10BE = 90 % Int32
-const AV_PIX_FMT_YUVA422P10LE = 91 % Int32
-const AV_PIX_FMT_YUVA444P10BE = 92 % Int32
-const AV_PIX_FMT_YUVA444P10LE = 93 % Int32
-const AV_PIX_FMT_YUVA420P16BE = 94 % Int32
-const AV_PIX_FMT_YUVA420P16LE = 95 % Int32
-const AV_PIX_FMT_YUVA422P16BE = 96 % Int32
-const AV_PIX_FMT_YUVA422P16LE = 97 % Int32
-const AV_PIX_FMT_YUVA444P16BE = 98 % Int32
-const AV_PIX_FMT_YUVA444P16LE = 99 % Int32
-const AV_PIX_FMT_VDPAU = 100 % Int32
-const AV_PIX_FMT_XYZ12LE = 101 % Int32
-const AV_PIX_FMT_XYZ12BE = 102 % Int32
-const AV_PIX_FMT_NV16 = 103 % Int32
-const AV_PIX_FMT_NV20LE = 104 % Int32
-const AV_PIX_FMT_NV20BE = 105 % Int32
-const AV_PIX_FMT_RGBA64BE = 106 % Int32
-const AV_PIX_FMT_RGBA64LE = 107 % Int32
-const AV_PIX_FMT_BGRA64BE = 108 % Int32
-const AV_PIX_FMT_BGRA64LE = 109 % Int32
-const AV_PIX_FMT_YVYU422 = 110 % Int32
-const AV_PIX_FMT_YA16BE = 111 % Int32
-const AV_PIX_FMT_YA16LE = 112 % Int32
-const AV_PIX_FMT_GBRAP = 113 % Int32
-const AV_PIX_FMT_GBRAP16BE = 114 % Int32
-const AV_PIX_FMT_GBRAP16LE = 115 % Int32
-const AV_PIX_FMT_QSV = 116 % Int32
-const AV_PIX_FMT_MMAL = 117 % Int32
-const AV_PIX_FMT_D3D11VA_VLD = 118 % Int32
-const AV_PIX_FMT_CUDA = 119 % Int32
-const AV_PIX_FMT_0RGB = 120 % Int32
-const AV_PIX_FMT_RGB0 = 121 % Int32
-const AV_PIX_FMT_0BGR = 122 % Int32
-const AV_PIX_FMT_BGR0 = 123 % Int32
-const AV_PIX_FMT_YUV420P12BE = 124 % Int32
-const AV_PIX_FMT_YUV420P12LE = 125 % Int32
-const AV_PIX_FMT_YUV420P14BE = 126 % Int32
-const AV_PIX_FMT_YUV420P14LE = 127 % Int32
-const AV_PIX_FMT_YUV422P12BE = 128 % Int32
-const AV_PIX_FMT_YUV422P12LE = 129 % Int32
-const AV_PIX_FMT_YUV422P14BE = 130 % Int32
-const AV_PIX_FMT_YUV422P14LE = 131 % Int32
-const AV_PIX_FMT_YUV444P12BE = 132 % Int32
-const AV_PIX_FMT_YUV444P12LE = 133 % Int32
-const AV_PIX_FMT_YUV444P14BE = 134 % Int32
-const AV_PIX_FMT_YUV444P14LE = 135 % Int32
-const AV_PIX_FMT_GBRP12BE = 136 % Int32
-const AV_PIX_FMT_GBRP12LE = 137 % Int32
-const AV_PIX_FMT_GBRP14BE = 138 % Int32
-const AV_PIX_FMT_GBRP14LE = 139 % Int32
-const AV_PIX_FMT_YUVJ411P = 140 % Int32
-const AV_PIX_FMT_BAYER_BGGR8 = 141 % Int32
-const AV_PIX_FMT_BAYER_RGGB8 = 142 % Int32
-const AV_PIX_FMT_BAYER_GBRG8 = 143 % Int32
-const AV_PIX_FMT_BAYER_GRBG8 = 144 % Int32
-const AV_PIX_FMT_BAYER_BGGR16LE = 145 % Int32
-const AV_PIX_FMT_BAYER_BGGR16BE = 146 % Int32
-const AV_PIX_FMT_BAYER_RGGB16LE = 147 % Int32
-const AV_PIX_FMT_BAYER_RGGB16BE = 148 % Int32
-const AV_PIX_FMT_BAYER_GBRG16LE = 149 % Int32
-const AV_PIX_FMT_BAYER_GBRG16BE = 150 % Int32
-const AV_PIX_FMT_BAYER_GRBG16LE = 151 % Int32
-const AV_PIX_FMT_BAYER_GRBG16BE = 152 % Int32
-const AV_PIX_FMT_XVMC = 153 % Int32
-const AV_PIX_FMT_YUV440P10LE = 154 % Int32
-const AV_PIX_FMT_YUV440P10BE = 155 % Int32
-const AV_PIX_FMT_YUV440P12LE = 156 % Int32
-const AV_PIX_FMT_YUV440P12BE = 157 % Int32
-const AV_PIX_FMT_AYUV64LE = 158 % Int32
-const AV_PIX_FMT_AYUV64BE = 159 % Int32
-const AV_PIX_FMT_VIDEOTOOLBOX = 160 % Int32
-const AV_PIX_FMT_P010LE = 161 % Int32
-const AV_PIX_FMT_P010BE = 162 % Int32
-const AV_PIX_FMT_GBRAP12BE = 163 % Int32
-const AV_PIX_FMT_GBRAP12LE = 164 % Int32
-const AV_PIX_FMT_GBRAP10BE = 165 % Int32
-const AV_PIX_FMT_GBRAP10LE = 166 % Int32
-const AV_PIX_FMT_MEDIACODEC = 167 % Int32
-const AV_PIX_FMT_GRAY12BE = 168 % Int32
-const AV_PIX_FMT_GRAY12LE = 169 % Int32
-const AV_PIX_FMT_GRAY10BE = 170 % Int32
-const AV_PIX_FMT_GRAY10LE = 171 % Int32
-const AV_PIX_FMT_P016LE = 172 % Int32
-const AV_PIX_FMT_P016BE = 173 % Int32
-const AV_PIX_FMT_D3D11 = 174 % Int32
-const AV_PIX_FMT_GRAY9BE = 175 % Int32
-const AV_PIX_FMT_GRAY9LE = 176 % Int32
-const AV_PIX_FMT_GBRPF32BE = 177 % Int32
-const AV_PIX_FMT_GBRPF32LE = 178 % Int32
-const AV_PIX_FMT_GBRAPF32BE = 179 % Int32
-const AV_PIX_FMT_GBRAPF32LE = 180 % Int32
-const AV_PIX_FMT_DRM_PRIME = 181 % Int32
-const AV_PIX_FMT_OPENCL = 182 % Int32
-const AV_PIX_FMT_GRAY14BE = 183 % Int32
-const AV_PIX_FMT_GRAY14LE = 184 % Int32
-const AV_PIX_FMT_GRAYF32BE = 185 % Int32
-const AV_PIX_FMT_GRAYF32LE = 186 % Int32
-const AV_PIX_FMT_YUVA422P12BE = 187 % Int32
-const AV_PIX_FMT_YUVA422P12LE = 188 % Int32
-const AV_PIX_FMT_YUVA444P12BE = 189 % Int32
-const AV_PIX_FMT_YUVA444P12LE = 190 % Int32
-const AV_PIX_FMT_NV24 = 191 % Int32
-const AV_PIX_FMT_NV42 = 192 % Int32
-const AV_PIX_FMT_VULKAN = 193 % Int32
-const AV_PIX_FMT_Y210BE = 194 % Int32
-const AV_PIX_FMT_Y210LE = 195 % Int32
-const AV_PIX_FMT_X2RGB10LE = 196 % Int32
-const AV_PIX_FMT_X2RGB10BE = 197 % Int32
-const AV_PIX_FMT_NB = 198 % Int32
+const AV_PIX_FMT_VAAPI = 44 % Int32
+const AV_PIX_FMT_YUV420P16LE = 45 % Int32
+const AV_PIX_FMT_YUV420P16BE = 46 % Int32
+const AV_PIX_FMT_YUV422P16LE = 47 % Int32
+const AV_PIX_FMT_YUV422P16BE = 48 % Int32
+const AV_PIX_FMT_YUV444P16LE = 49 % Int32
+const AV_PIX_FMT_YUV444P16BE = 50 % Int32
+const AV_PIX_FMT_DXVA2_VLD = 51 % Int32
+const AV_PIX_FMT_RGB444LE = 52 % Int32
+const AV_PIX_FMT_RGB444BE = 53 % Int32
+const AV_PIX_FMT_BGR444LE = 54 % Int32
+const AV_PIX_FMT_BGR444BE = 55 % Int32
+const AV_PIX_FMT_YA8 = 56 % Int32
+const AV_PIX_FMT_Y400A = 56 % Int32
+const AV_PIX_FMT_GRAY8A = 56 % Int32
+const AV_PIX_FMT_BGR48BE = 57 % Int32
+const AV_PIX_FMT_BGR48LE = 58 % Int32
+const AV_PIX_FMT_YUV420P9BE = 59 % Int32
+const AV_PIX_FMT_YUV420P9LE = 60 % Int32
+const AV_PIX_FMT_YUV420P10BE = 61 % Int32
+const AV_PIX_FMT_YUV420P10LE = 62 % Int32
+const AV_PIX_FMT_YUV422P10BE = 63 % Int32
+const AV_PIX_FMT_YUV422P10LE = 64 % Int32
+const AV_PIX_FMT_YUV444P9BE = 65 % Int32
+const AV_PIX_FMT_YUV444P9LE = 66 % Int32
+const AV_PIX_FMT_YUV444P10BE = 67 % Int32
+const AV_PIX_FMT_YUV444P10LE = 68 % Int32
+const AV_PIX_FMT_YUV422P9BE = 69 % Int32
+const AV_PIX_FMT_YUV422P9LE = 70 % Int32
+const AV_PIX_FMT_GBRP = 71 % Int32
+const AV_PIX_FMT_GBR24P = 71 % Int32
+const AV_PIX_FMT_GBRP9BE = 72 % Int32
+const AV_PIX_FMT_GBRP9LE = 73 % Int32
+const AV_PIX_FMT_GBRP10BE = 74 % Int32
+const AV_PIX_FMT_GBRP10LE = 75 % Int32
+const AV_PIX_FMT_GBRP16BE = 76 % Int32
+const AV_PIX_FMT_GBRP16LE = 77 % Int32
+const AV_PIX_FMT_YUVA422P = 78 % Int32
+const AV_PIX_FMT_YUVA444P = 79 % Int32
+const AV_PIX_FMT_YUVA420P9BE = 80 % Int32
+const AV_PIX_FMT_YUVA420P9LE = 81 % Int32
+const AV_PIX_FMT_YUVA422P9BE = 82 % Int32
+const AV_PIX_FMT_YUVA422P9LE = 83 % Int32
+const AV_PIX_FMT_YUVA444P9BE = 84 % Int32
+const AV_PIX_FMT_YUVA444P9LE = 85 % Int32
+const AV_PIX_FMT_YUVA420P10BE = 86 % Int32
+const AV_PIX_FMT_YUVA420P10LE = 87 % Int32
+const AV_PIX_FMT_YUVA422P10BE = 88 % Int32
+const AV_PIX_FMT_YUVA422P10LE = 89 % Int32
+const AV_PIX_FMT_YUVA444P10BE = 90 % Int32
+const AV_PIX_FMT_YUVA444P10LE = 91 % Int32
+const AV_PIX_FMT_YUVA420P16BE = 92 % Int32
+const AV_PIX_FMT_YUVA420P16LE = 93 % Int32
+const AV_PIX_FMT_YUVA422P16BE = 94 % Int32
+const AV_PIX_FMT_YUVA422P16LE = 95 % Int32
+const AV_PIX_FMT_YUVA444P16BE = 96 % Int32
+const AV_PIX_FMT_YUVA444P16LE = 97 % Int32
+const AV_PIX_FMT_VDPAU = 98 % Int32
+const AV_PIX_FMT_XYZ12LE = 99 % Int32
+const AV_PIX_FMT_XYZ12BE = 100 % Int32
+const AV_PIX_FMT_NV16 = 101 % Int32
+const AV_PIX_FMT_NV20LE = 102 % Int32
+const AV_PIX_FMT_NV20BE = 103 % Int32
+const AV_PIX_FMT_RGBA64BE = 104 % Int32
+const AV_PIX_FMT_RGBA64LE = 105 % Int32
+const AV_PIX_FMT_BGRA64BE = 106 % Int32
+const AV_PIX_FMT_BGRA64LE = 107 % Int32
+const AV_PIX_FMT_YVYU422 = 108 % Int32
+const AV_PIX_FMT_YA16BE = 109 % Int32
+const AV_PIX_FMT_YA16LE = 110 % Int32
+const AV_PIX_FMT_GBRAP = 111 % Int32
+const AV_PIX_FMT_GBRAP16BE = 112 % Int32
+const AV_PIX_FMT_GBRAP16LE = 113 % Int32
+const AV_PIX_FMT_QSV = 114 % Int32
+const AV_PIX_FMT_MMAL = 115 % Int32
+const AV_PIX_FMT_D3D11VA_VLD = 116 % Int32
+const AV_PIX_FMT_CUDA = 117 % Int32
+const AV_PIX_FMT_0RGB = 118 % Int32
+const AV_PIX_FMT_RGB0 = 119 % Int32
+const AV_PIX_FMT_0BGR = 120 % Int32
+const AV_PIX_FMT_BGR0 = 121 % Int32
+const AV_PIX_FMT_YUV420P12BE = 122 % Int32
+const AV_PIX_FMT_YUV420P12LE = 123 % Int32
+const AV_PIX_FMT_YUV420P14BE = 124 % Int32
+const AV_PIX_FMT_YUV420P14LE = 125 % Int32
+const AV_PIX_FMT_YUV422P12BE = 126 % Int32
+const AV_PIX_FMT_YUV422P12LE = 127 % Int32
+const AV_PIX_FMT_YUV422P14BE = 128 % Int32
+const AV_PIX_FMT_YUV422P14LE = 129 % Int32
+const AV_PIX_FMT_YUV444P12BE = 130 % Int32
+const AV_PIX_FMT_YUV444P12LE = 131 % Int32
+const AV_PIX_FMT_YUV444P14BE = 132 % Int32
+const AV_PIX_FMT_YUV444P14LE = 133 % Int32
+const AV_PIX_FMT_GBRP12BE = 134 % Int32
+const AV_PIX_FMT_GBRP12LE = 135 % Int32
+const AV_PIX_FMT_GBRP14BE = 136 % Int32
+const AV_PIX_FMT_GBRP14LE = 137 % Int32
+const AV_PIX_FMT_YUVJ411P = 138 % Int32
+const AV_PIX_FMT_BAYER_BGGR8 = 139 % Int32
+const AV_PIX_FMT_BAYER_RGGB8 = 140 % Int32
+const AV_PIX_FMT_BAYER_GBRG8 = 141 % Int32
+const AV_PIX_FMT_BAYER_GRBG8 = 142 % Int32
+const AV_PIX_FMT_BAYER_BGGR16LE = 143 % Int32
+const AV_PIX_FMT_BAYER_BGGR16BE = 144 % Int32
+const AV_PIX_FMT_BAYER_RGGB16LE = 145 % Int32
+const AV_PIX_FMT_BAYER_RGGB16BE = 146 % Int32
+const AV_PIX_FMT_BAYER_GBRG16LE = 147 % Int32
+const AV_PIX_FMT_BAYER_GBRG16BE = 148 % Int32
+const AV_PIX_FMT_BAYER_GRBG16LE = 149 % Int32
+const AV_PIX_FMT_BAYER_GRBG16BE = 150 % Int32
+const AV_PIX_FMT_XVMC = 151 % Int32
+const AV_PIX_FMT_YUV440P10LE = 152 % Int32
+const AV_PIX_FMT_YUV440P10BE = 153 % Int32
+const AV_PIX_FMT_YUV440P12LE = 154 % Int32
+const AV_PIX_FMT_YUV440P12BE = 155 % Int32
+const AV_PIX_FMT_AYUV64LE = 156 % Int32
+const AV_PIX_FMT_AYUV64BE = 157 % Int32
+const AV_PIX_FMT_VIDEOTOOLBOX = 158 % Int32
+const AV_PIX_FMT_P010LE = 159 % Int32
+const AV_PIX_FMT_P010BE = 160 % Int32
+const AV_PIX_FMT_GBRAP12BE = 161 % Int32
+const AV_PIX_FMT_GBRAP12LE = 162 % Int32
+const AV_PIX_FMT_GBRAP10BE = 163 % Int32
+const AV_PIX_FMT_GBRAP10LE = 164 % Int32
+const AV_PIX_FMT_MEDIACODEC = 165 % Int32
+const AV_PIX_FMT_GRAY12BE = 166 % Int32
+const AV_PIX_FMT_GRAY12LE = 167 % Int32
+const AV_PIX_FMT_GRAY10BE = 168 % Int32
+const AV_PIX_FMT_GRAY10LE = 169 % Int32
+const AV_PIX_FMT_P016LE = 170 % Int32
+const AV_PIX_FMT_P016BE = 171 % Int32
+const AV_PIX_FMT_D3D11 = 172 % Int32
+const AV_PIX_FMT_GRAY9BE = 173 % Int32
+const AV_PIX_FMT_GRAY9LE = 174 % Int32
+const AV_PIX_FMT_GBRPF32BE = 175 % Int32
+const AV_PIX_FMT_GBRPF32LE = 176 % Int32
+const AV_PIX_FMT_GBRAPF32BE = 177 % Int32
+const AV_PIX_FMT_GBRAPF32LE = 178 % Int32
+const AV_PIX_FMT_DRM_PRIME = 179 % Int32
+const AV_PIX_FMT_OPENCL = 180 % Int32
+const AV_PIX_FMT_GRAY14BE = 181 % Int32
+const AV_PIX_FMT_GRAY14LE = 182 % Int32
+const AV_PIX_FMT_GRAYF32BE = 183 % Int32
+const AV_PIX_FMT_GRAYF32LE = 184 % Int32
+const AV_PIX_FMT_YUVA422P12BE = 185 % Int32
+const AV_PIX_FMT_YUVA422P12LE = 186 % Int32
+const AV_PIX_FMT_YUVA444P12BE = 187 % Int32
+const AV_PIX_FMT_YUVA444P12LE = 188 % Int32
+const AV_PIX_FMT_NV24 = 189 % Int32
+const AV_PIX_FMT_NV42 = 190 % Int32
+const AV_PIX_FMT_VULKAN = 191 % Int32
+const AV_PIX_FMT_Y210BE = 192 % Int32
+const AV_PIX_FMT_Y210LE = 193 % Int32
+const AV_PIX_FMT_X2RGB10LE = 194 % Int32
+const AV_PIX_FMT_X2RGB10BE = 195 % Int32
+const AV_PIX_FMT_X2BGR10LE = 196 % Int32
+const AV_PIX_FMT_X2BGR10BE = 197 % Int32
+const AV_PIX_FMT_P210BE = 198 % Int32
+const AV_PIX_FMT_P210LE = 199 % Int32
+const AV_PIX_FMT_P410BE = 200 % Int32
+const AV_PIX_FMT_P410LE = 201 % Int32
+const AV_PIX_FMT_P216BE = 202 % Int32
+const AV_PIX_FMT_P216LE = 203 % Int32
+const AV_PIX_FMT_P416BE = 204 % Int32
+const AV_PIX_FMT_P416LE = 205 % Int32
+const AV_PIX_FMT_VUYA = 206 % Int32
+const AV_PIX_FMT_RGBAF16BE = 207 % Int32
+const AV_PIX_FMT_RGBAF16LE = 208 % Int32
+const AV_PIX_FMT_VUYX = 209 % Int32
+const AV_PIX_FMT_P012LE = 210 % Int32
+const AV_PIX_FMT_P012BE = 211 % Int32
+const AV_PIX_FMT_Y212BE = 212 % Int32
+const AV_PIX_FMT_Y212LE = 213 % Int32
+const AV_PIX_FMT_XV30BE = 214 % Int32
+const AV_PIX_FMT_XV30LE = 215 % Int32
+const AV_PIX_FMT_XV36BE = 216 % Int32
+const AV_PIX_FMT_XV36LE = 217 % Int32
+const AV_PIX_FMT_RGBF32BE = 218 % Int32
+const AV_PIX_FMT_RGBF32LE = 219 % Int32
+const AV_PIX_FMT_RGBAF32BE = 220 % Int32
+const AV_PIX_FMT_RGBAF32LE = 221 % Int32
+const AV_PIX_FMT_P212BE = 222 % Int32
+const AV_PIX_FMT_P212LE = 223 % Int32
+const AV_PIX_FMT_P412BE = 224 % Int32
+const AV_PIX_FMT_P412LE = 225 % Int32
+const AV_PIX_FMT_GBRAP14BE = 226 % Int32
+const AV_PIX_FMT_GBRAP14LE = 227 % Int32
+const AV_PIX_FMT_NB = 228 % Int32
 
 """
-    AVColorPrimaries
+    AVSampleFormat
 
-Chromaticity coordinates of the source primaries. These values match the ones defined by ISO/IEC 23001-8\\_2013 § 7.1.
-"""
-const AVColorPrimaries = UInt32
-const AVCOL_PRI_RESERVED0 = 0 % UInt32
-const AVCOL_PRI_BT709 = 1 % UInt32
-const AVCOL_PRI_UNSPECIFIED = 2 % UInt32
-const AVCOL_PRI_RESERVED = 3 % UInt32
-const AVCOL_PRI_BT470M = 4 % UInt32
-const AVCOL_PRI_BT470BG = 5 % UInt32
-const AVCOL_PRI_SMPTE170M = 6 % UInt32
-const AVCOL_PRI_SMPTE240M = 7 % UInt32
-const AVCOL_PRI_FILM = 8 % UInt32
-const AVCOL_PRI_BT2020 = 9 % UInt32
-const AVCOL_PRI_SMPTE428 = 10 % UInt32
-const AVCOL_PRI_SMPTEST428_1 = 10 % UInt32
-const AVCOL_PRI_SMPTE431 = 11 % UInt32
-const AVCOL_PRI_SMPTE432 = 12 % UInt32
-const AVCOL_PRI_EBU3213 = 22 % UInt32
-const AVCOL_PRI_JEDEC_P22 = 22 % UInt32
-const AVCOL_PRI_NB = 23 % UInt32
+Audio sample formats
 
-"""
-    AVColorTransferCharacteristic
+- The data described by the sample format is always in native-endian order. Sample values can be expressed by native C types, hence the lack of a signed 24-bit sample format even though it is a common raw audio data format.
 
-Color Transfer Characteristic. These values match the ones defined by ISO/IEC 23001-8\\_2013 § 7.2.
-"""
-const AVColorTransferCharacteristic = UInt32
-const AVCOL_TRC_RESERVED0 = 0 % UInt32
-const AVCOL_TRC_BT709 = 1 % UInt32
-const AVCOL_TRC_UNSPECIFIED = 2 % UInt32
-const AVCOL_TRC_RESERVED = 3 % UInt32
-const AVCOL_TRC_GAMMA22 = 4 % UInt32
-const AVCOL_TRC_GAMMA28 = 5 % UInt32
-const AVCOL_TRC_SMPTE170M = 6 % UInt32
-const AVCOL_TRC_SMPTE240M = 7 % UInt32
-const AVCOL_TRC_LINEAR = 8 % UInt32
-const AVCOL_TRC_LOG = 9 % UInt32
-const AVCOL_TRC_LOG_SQRT = 10 % UInt32
-const AVCOL_TRC_IEC61966_2_4 = 11 % UInt32
-const AVCOL_TRC_BT1361_ECG = 12 % UInt32
-const AVCOL_TRC_IEC61966_2_1 = 13 % UInt32
-const AVCOL_TRC_BT2020_10 = 14 % UInt32
-const AVCOL_TRC_BT2020_12 = 15 % UInt32
-const AVCOL_TRC_SMPTE2084 = 16 % UInt32
-const AVCOL_TRC_SMPTEST2084 = 16 % UInt32
-const AVCOL_TRC_SMPTE428 = 17 % UInt32
-const AVCOL_TRC_SMPTEST428_1 = 17 % UInt32
-const AVCOL_TRC_ARIB_STD_B67 = 18 % UInt32
-const AVCOL_TRC_NB = 19 % UInt32
+- The floating-point formats are based on full volume being in the range [-1.0, 1.0]. Any values outside this range are beyond full volume level.
 
-"""
-    AVColorSpace
+- The data layout as used in [`av_samples_fill_arrays`](@ref)() and elsewhere in FFmpeg (such as [`AVFrame`](@ref) in libavcodec) is as follows:
 
-YUV colorspace type. These values match the ones defined by ISO/IEC 23001-8\\_2013 § 7.3.
+\\par For planar sample formats, each audio channel is in a separate data plane, and linesize is the buffer size, in bytes, for a single plane. All data planes must be the same size. For packed sample formats, only the first data plane is used, and samples for each channel are interleaved. In this case, linesize is the buffer size, in bytes, for the 1 plane.
 """
-const AVColorSpace = UInt32
-const AVCOL_SPC_RGB = 0 % UInt32
-const AVCOL_SPC_BT709 = 1 % UInt32
-const AVCOL_SPC_UNSPECIFIED = 2 % UInt32
-const AVCOL_SPC_RESERVED = 3 % UInt32
-const AVCOL_SPC_FCC = 4 % UInt32
-const AVCOL_SPC_BT470BG = 5 % UInt32
-const AVCOL_SPC_SMPTE170M = 6 % UInt32
-const AVCOL_SPC_SMPTE240M = 7 % UInt32
-const AVCOL_SPC_YCGCO = 8 % UInt32
+const AVSampleFormat = Int32
+const AV_SAMPLE_FMT_NONE = -1 % Int32
+const AV_SAMPLE_FMT_U8 = 0 % Int32
+const AV_SAMPLE_FMT_S16 = 1 % Int32
+const AV_SAMPLE_FMT_S32 = 2 % Int32
+const AV_SAMPLE_FMT_FLT = 3 % Int32
+const AV_SAMPLE_FMT_DBL = 4 % Int32
+const AV_SAMPLE_FMT_U8P = 5 % Int32
+const AV_SAMPLE_FMT_S16P = 6 % Int32
+const AV_SAMPLE_FMT_S32P = 7 % Int32
+const AV_SAMPLE_FMT_FLTP = 8 % Int32
+const AV_SAMPLE_FMT_DBLP = 9 % Int32
+const AV_SAMPLE_FMT_S64 = 10 % Int32
+const AV_SAMPLE_FMT_S64P = 11 % Int32
+const AV_SAMPLE_FMT_NB = 12 % Int32
+
+"""
+    AVProfile
+
+[`AVProfile`](@ref).
+"""
+struct AVProfile
+    profile::Cint
+    name::Cstring
+end
+
+const AVChannelOrder = UInt32
+const AV_CHANNEL_ORDER_UNSPEC = 0 % UInt32
+const AV_CHANNEL_ORDER_NATIVE = 1 % UInt32
+const AV_CHANNEL_ORDER_CUSTOM = 2 % UInt32
+const AV_CHANNEL_ORDER_AMBISONIC = 3 % UInt32
+
+"""
+    __JL_Ctag_977
+
+Details about which channels are present in this layout. For AV\\_CHANNEL\\_ORDER\\_UNSPEC, this field is undefined and must not be used.
+"""
+struct __JL_Ctag_977
+    data::NTuple{8, UInt8}
+end
+
+function Base.getproperty(x::Ptr{__JL_Ctag_977}, f::Symbol)
+    f === :mask && return Ptr{UInt64}(x + 0)
+    f === :map && return Ptr{Ptr{AVChannelCustom}}(x + 0)
+    return getfield(x, f)
+end
+
+function Base.getproperty(x::__JL_Ctag_977, f::Symbol)
+    r = Ref{__JL_Ctag_977}(x)
+    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_977}, r)
+    fptr = getproperty(ptr, f)
+    GC.@preserve r unsafe_load(fptr)
+end
+
+function Base.setproperty!(x::Ptr{__JL_Ctag_977}, f::Symbol, v)
+    unsafe_store!(getproperty(x, f), v)
+end
+
+"""
+    AVChannelLayout
+
+An [`AVChannelLayout`](@ref) holds information about the channel layout of audio data.
+
+A channel layout here is defined as a set of channels ordered in a specific way (unless the channel order is AV\\_CHANNEL\\_ORDER\\_UNSPEC, in which case an [`AVChannelLayout`](@ref) carries only the channel count). All orders may be treated as if they were AV\\_CHANNEL\\_ORDER\\_UNSPEC by ignoring everything but the channel count, as long as [`av_channel_layout_check`](@ref)() considers they are valid.
+
+Unlike most structures in FFmpeg, sizeof([`AVChannelLayout`](@ref)) is a part of the public ABI and may be used by the caller. E.g. it may be allocated on stack or embedded in caller-defined structs.
+
+[`AVChannelLayout`](@ref) can be initialized as follows: - default initialization with {0}, followed by setting all used fields correctly; - by assigning one of the predefined AV\\_CHANNEL\\_LAYOUT\\_* initializers; - with a constructor function, such as [`av_channel_layout_default`](@ref)(), [`av_channel_layout_from_mask`](@ref)() or [`av_channel_layout_from_string`](@ref)().
+
+The channel layout must be unitialized with [`av_channel_layout_uninit`](@ref)()
+
+Copying an [`AVChannelLayout`](@ref) via assigning is forbidden, [`av_channel_layout_copy`](@ref)() must be used instead (and its return value should be checked)
+
+No new fields may be added to it without a major version bump, except for new elements of the union fitting in sizeof(uint64\\_t).
+"""
+struct AVChannelLayout
+    data::NTuple{24, UInt8}
+end
+
+function Base.getproperty(x::Ptr{AVChannelLayout}, f::Symbol)
+    f === :order && return Ptr{AVChannelOrder}(x + 0)
+    f === :nb_channels && return Ptr{Cint}(x + 4)
+    f === :u && return Ptr{__JL_Ctag_977}(x + 8)
+    f === :opaque && return Ptr{Ptr{Cvoid}}(x + 16)
+    return getfield(x, f)
+end
+
+function Base.getproperty(x::AVChannelLayout, f::Symbol)
+    r = Ref{AVChannelLayout}(x)
+    ptr = Base.unsafe_convert(Ptr{AVChannelLayout}, r)
+    fptr = getproperty(ptr, f)
+    GC.@preserve r unsafe_load(fptr)
+end
+
+function Base.setproperty!(x::Ptr{AVChannelLayout}, f::Symbol, v)
+    unsafe_store!(getproperty(x, f), v)
+end
+
+"""
+    AVCodec
+
+[`AVCodec`](@ref).
+"""
+struct AVCodec
+    data::NTuple{104, UInt8}
+end
+
+function Base.getproperty(x::Ptr{AVCodec}, f::Symbol)
+    f === :name && return Ptr{Cstring}(x + 0)
+    f === :long_name && return Ptr{Cstring}(x + 8)
+    f === :type && return Ptr{AVMediaType}(x + 16)
+    f === :id && return Ptr{AVCodecID}(x + 20)
+    f === :capabilities && return Ptr{Cint}(x + 24)
+    f === :max_lowres && return Ptr{UInt8}(x + 28)
+    f === :supported_framerates && return Ptr{Ptr{AVRational}}(x + 32)
+    f === :pix_fmts && return Ptr{Ptr{AVPixelFormat}}(x + 40)
+    f === :supported_samplerates && return Ptr{Ptr{Cint}}(x + 48)
+    f === :sample_fmts && return Ptr{Ptr{AVSampleFormat}}(x + 56)
+    f === :channel_layouts && return Ptr{Ptr{UInt64}}(x + 64)
+    f === :priv_class && return Ptr{Ptr{AVClass}}(x + 72)
+    f === :profiles && return Ptr{Ptr{AVProfile}}(x + 80)
+    f === :wrapper_name && return Ptr{Cstring}(x + 88)
+    f === :ch_layouts && return Ptr{Ptr{AVChannelLayout}}(x + 96)
+    return getfield(x, f)
+end
+
+function Base.getproperty(x::AVCodec, f::Symbol)
+    r = Ref{AVCodec}(x)
+    ptr = Base.unsafe_convert(Ptr{AVCodec}, r)
+    fptr = getproperty(ptr, f)
+    GC.@preserve r unsafe_load(fptr)
+end
+
+function Base.setproperty!(x::Ptr{AVCodec}, f::Symbol, v)
+    unsafe_store!(getproperty(x, f), v)
+end
+
+mutable struct AVCodecInternal end
+
+"""
+    AVColorPrimaries
+
+Chromaticity coordinates of the source primaries. These values match the ones defined by ISO/IEC 23091-2\\_2019 subclause 8.1 and ITU-T H.273.
+"""
+const AVColorPrimaries = UInt32
+const AVCOL_PRI_RESERVED0 = 0 % UInt32
+const AVCOL_PRI_BT709 = 1 % UInt32
+const AVCOL_PRI_UNSPECIFIED = 2 % UInt32
+const AVCOL_PRI_RESERVED = 3 % UInt32
+const AVCOL_PRI_BT470M = 4 % UInt32
+const AVCOL_PRI_BT470BG = 5 % UInt32
+const AVCOL_PRI_SMPTE170M = 6 % UInt32
+const AVCOL_PRI_SMPTE240M = 7 % UInt32
+const AVCOL_PRI_FILM = 8 % UInt32
+const AVCOL_PRI_BT2020 = 9 % UInt32
+const AVCOL_PRI_SMPTE428 = 10 % UInt32
+const AVCOL_PRI_SMPTEST428_1 = 10 % UInt32
+const AVCOL_PRI_SMPTE431 = 11 % UInt32
+const AVCOL_PRI_SMPTE432 = 12 % UInt32
+const AVCOL_PRI_EBU3213 = 22 % UInt32
+const AVCOL_PRI_JEDEC_P22 = 22 % UInt32
+const AVCOL_PRI_NB = 23 % UInt32
+
+"""
+    AVColorTransferCharacteristic
+
+Color Transfer Characteristic. These values match the ones defined by ISO/IEC 23091-2\\_2019 subclause 8.2.
+"""
+const AVColorTransferCharacteristic = UInt32
+const AVCOL_TRC_RESERVED0 = 0 % UInt32
+const AVCOL_TRC_BT709 = 1 % UInt32
+const AVCOL_TRC_UNSPECIFIED = 2 % UInt32
+const AVCOL_TRC_RESERVED = 3 % UInt32
+const AVCOL_TRC_GAMMA22 = 4 % UInt32
+const AVCOL_TRC_GAMMA28 = 5 % UInt32
+const AVCOL_TRC_SMPTE170M = 6 % UInt32
+const AVCOL_TRC_SMPTE240M = 7 % UInt32
+const AVCOL_TRC_LINEAR = 8 % UInt32
+const AVCOL_TRC_LOG = 9 % UInt32
+const AVCOL_TRC_LOG_SQRT = 10 % UInt32
+const AVCOL_TRC_IEC61966_2_4 = 11 % UInt32
+const AVCOL_TRC_BT1361_ECG = 12 % UInt32
+const AVCOL_TRC_IEC61966_2_1 = 13 % UInt32
+const AVCOL_TRC_BT2020_10 = 14 % UInt32
+const AVCOL_TRC_BT2020_12 = 15 % UInt32
+const AVCOL_TRC_SMPTE2084 = 16 % UInt32
+const AVCOL_TRC_SMPTEST2084 = 16 % UInt32
+const AVCOL_TRC_SMPTE428 = 17 % UInt32
+const AVCOL_TRC_SMPTEST428_1 = 17 % UInt32
+const AVCOL_TRC_ARIB_STD_B67 = 18 % UInt32
+const AVCOL_TRC_NB = 19 % UInt32
+
+"""
+    AVColorSpace
+
+YUV colorspace type. These values match the ones defined by ISO/IEC 23091-2\\_2019 subclause 8.3.
+"""
+const AVColorSpace = UInt32
+const AVCOL_SPC_RGB = 0 % UInt32
+const AVCOL_SPC_BT709 = 1 % UInt32
+const AVCOL_SPC_UNSPECIFIED = 2 % UInt32
+const AVCOL_SPC_RESERVED = 3 % UInt32
+const AVCOL_SPC_FCC = 4 % UInt32
+const AVCOL_SPC_BT470BG = 5 % UInt32
+const AVCOL_SPC_SMPTE170M = 6 % UInt32
+const AVCOL_SPC_SMPTE240M = 7 % UInt32
+const AVCOL_SPC_YCGCO = 8 % UInt32
 const AVCOL_SPC_YCOCG = 8 % UInt32
 const AVCOL_SPC_BT2020_NCL = 9 % UInt32
 const AVCOL_SPC_BT2020_CL = 10 % UInt32
@@ -2350,7 +2811,7 @@ Visual content value range.
 
 These values are based on definitions that can be found in multiple specifications, such as ITU-T BT.709 (3.4 - Quantization of RGB, luminance and colour-difference signals), ITU-T BT.2020 (Table 5 - Digital Representation) as well as ITU-T BT.2100 (Table 9 - Digital 10- and 12-bit integer representation). At the time of writing, the BT.2100 one is recommended, as it also defines the full range representation.
 
-Common definitions: - For RGB and luminance planes such as Y in YCbCr and I in ICtCp, 'E' is the original value in range of 0.0 to 1.0. - For chrominance planes such as Cb,Cr and Ct,Cp, 'E' is the original value in range of -0.5 to 0.5. - 'n' is the output bit depth. - For additional definitions such as rounding and clipping to valid n bit unsigned integer range, please refer to BT.2100 (Table 9).
+Common definitions: - For RGB and luma planes such as Y in YCbCr and I in ICtCp, 'E' is the original value in range of 0.0 to 1.0. - For chroma planes such as Cb,Cr and Ct,Cp, 'E' is the original value in range of -0.5 to 0.5. - 'n' is the output bit depth. - For additional definitions such as rounding and clipping to valid n bit unsigned integer range, please refer to BT.2100 (Table 9).
 """
 const AVColorRange = UInt32
 const AVCOL_RANGE_UNSPECIFIED = 0 % UInt32
@@ -2377,11 +2838,6 @@ const AVCHROMA_LOC_BOTTOMLEFT = 5 % UInt32
 const AVCHROMA_LOC_BOTTOM = 6 % UInt32
 const AVCHROMA_LOC_NB = 7 % UInt32
 
-"""
-    AVFieldOrder
-
-` lavc_core`
-"""
 const AVFieldOrder = UInt32
 const AV_FIELD_UNKNOWN = 0 % UInt32
 const AV_FIELD_PROGRESSIVE = 1 % UInt32
@@ -2390,34 +2846,17 @@ const AV_FIELD_BB = 3 % UInt32
 const AV_FIELD_TB = 4 % UInt32
 const AV_FIELD_BT = 5 % UInt32
 
-"""
-    AVSampleFormat
-
-Audio sample formats
-
-- The data described by the sample format is always in native-endian order. Sample values can be expressed by native C types, hence the lack of a signed 24-bit sample format even though it is a common raw audio data format.
-
-- The floating-point formats are based on full volume being in the range [-1.0, 1.0]. Any values outside this range are beyond full volume level.
-
-- The data layout as used in [`av_samples_fill_arrays`](@ref)() and elsewhere in FFmpeg (such as [`AVFrame`](@ref) in libavcodec) is as follows:
-
-\\par For planar sample formats, each audio channel is in a separate data plane, and linesize is the buffer size, in bytes, for a single plane. All data planes must be the same size. For packed sample formats, only the first data plane is used, and samples for each channel are interleaved. In this case, linesize is the buffer size, in bytes, for the 1 plane.
-"""
-const AVSampleFormat = Int32
-const AV_SAMPLE_FMT_NONE = -1 % Int32
-const AV_SAMPLE_FMT_U8 = 0 % Int32
-const AV_SAMPLE_FMT_S16 = 1 % Int32
-const AV_SAMPLE_FMT_S32 = 2 % Int32
-const AV_SAMPLE_FMT_FLT = 3 % Int32
-const AV_SAMPLE_FMT_DBL = 4 % Int32
-const AV_SAMPLE_FMT_U8P = 5 % Int32
-const AV_SAMPLE_FMT_S16P = 6 % Int32
-const AV_SAMPLE_FMT_S32P = 7 % Int32
-const AV_SAMPLE_FMT_FLTP = 8 % Int32
-const AV_SAMPLE_FMT_DBLP = 9 % Int32
-const AV_SAMPLE_FMT_S64 = 10 % Int32
-const AV_SAMPLE_FMT_S64P = 11 % Int32
-const AV_SAMPLE_FMT_NB = 12 % Int32
+const AVAudioServiceType = UInt32
+const AV_AUDIO_SERVICE_TYPE_MAIN = 0 % UInt32
+const AV_AUDIO_SERVICE_TYPE_EFFECTS = 1 % UInt32
+const AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2 % UInt32
+const AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3 % UInt32
+const AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4 % UInt32
+const AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5 % UInt32
+const AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6 % UInt32
+const AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7 % UInt32
+const AV_AUDIO_SERVICE_TYPE_KARAOKE = 8 % UInt32
+const AV_AUDIO_SERVICE_TYPE_NB = 9 % UInt32
 
 """
     AVHWAccel
@@ -2436,210 +2875,26 @@ struct AVHWAccel
     id::AVCodecID
     pix_fmt::AVPixelFormat
     capabilities::Cint
-    alloc_frame::Ptr{Cvoid}
-    start_frame::Ptr{Cvoid}
-    decode_params::Ptr{Cvoid}
-    decode_slice::Ptr{Cvoid}
-    end_frame::Ptr{Cvoid}
-    frame_priv_data_size::Cint
-    decode_mb::Ptr{Cvoid}
-    init::Ptr{Cvoid}
-    uninit::Ptr{Cvoid}
-    priv_data_size::Cint
-    caps_internal::Cint
-    frame_params::Ptr{Cvoid}
-end
-
-"""
-    AVPictureType
-
-@} @} 
-
-` lavu_picture Image related`
-
-[`AVPicture`](@ref) types, pixel formats and basic image planes manipulation.
-
-@{
-"""
-const AVPictureType = UInt32
-const AV_PICTURE_TYPE_NONE = 0 % UInt32
-const AV_PICTURE_TYPE_I = 1 % UInt32
-const AV_PICTURE_TYPE_P = 2 % UInt32
-const AV_PICTURE_TYPE_B = 3 % UInt32
-const AV_PICTURE_TYPE_S = 4 % UInt32
-const AV_PICTURE_TYPE_SI = 5 % UInt32
-const AV_PICTURE_TYPE_SP = 6 % UInt32
-const AV_PICTURE_TYPE_BI = 7 % UInt32
-
-mutable struct AVBuffer end
-
-"""
-    AVBufferRef
-
-A reference to a data buffer.
-
-The size of this struct is not a part of the public ABI and it is not meant to be allocated directly.
-"""
-struct AVBufferRef
-    buffer::Ptr{AVBuffer}
-    data::Ptr{UInt8}
-    size::Cint
-end
-
-"""
-    AVFrameSideDataType
-
-` lavu_frame AVFrame`
-
-` lavu_data`
-
-@{ [`AVFrame`](@ref) is an abstraction for reference-counted raw multimedia data.
-"""
-const AVFrameSideDataType = UInt32
-const AV_FRAME_DATA_PANSCAN = 0 % UInt32
-const AV_FRAME_DATA_A53_CC = 1 % UInt32
-const AV_FRAME_DATA_STEREO3D = 2 % UInt32
-const AV_FRAME_DATA_MATRIXENCODING = 3 % UInt32
-const AV_FRAME_DATA_DOWNMIX_INFO = 4 % UInt32
-const AV_FRAME_DATA_REPLAYGAIN = 5 % UInt32
-const AV_FRAME_DATA_DISPLAYMATRIX = 6 % UInt32
-const AV_FRAME_DATA_AFD = 7 % UInt32
-const AV_FRAME_DATA_MOTION_VECTORS = 8 % UInt32
-const AV_FRAME_DATA_SKIP_SAMPLES = 9 % UInt32
-const AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10 % UInt32
-const AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11 % UInt32
-const AV_FRAME_DATA_GOP_TIMECODE = 12 % UInt32
-const AV_FRAME_DATA_SPHERICAL = 13 % UInt32
-const AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = 14 % UInt32
-const AV_FRAME_DATA_ICC_PROFILE = 15 % UInt32
-const AV_FRAME_DATA_QP_TABLE_PROPERTIES = 16 % UInt32
-const AV_FRAME_DATA_QP_TABLE_DATA = 17 % UInt32
-const AV_FRAME_DATA_S12M_TIMECODE = 18 % UInt32
-const AV_FRAME_DATA_DYNAMIC_HDR_PLUS = 19 % UInt32
-const AV_FRAME_DATA_REGIONS_OF_INTEREST = 20 % UInt32
-const AV_FRAME_DATA_VIDEO_ENC_PARAMS = 21 % UInt32
-const AV_FRAME_DATA_SEI_UNREGISTERED = 22 % UInt32
-const AV_FRAME_DATA_FILM_GRAIN_PARAMS = 23 % UInt32
-
-mutable struct AVDictionary end
-
-"""
-    AVFrameSideData
-
-Structure to hold side data for an [`AVFrame`](@ref).
-
-sizeof([`AVFrameSideData`](@ref)) is not a part of the public ABI, so new fields may be added to the end with a minor bump.
-"""
-struct AVFrameSideData
-    type::AVFrameSideDataType
-    data::Ptr{UInt8}
-    size::Cint
-    metadata::Ptr{AVDictionary}
-    buf::Ptr{AVBufferRef}
-end
-
-"""
-    AVFrame
-
-This structure describes decoded (raw) audio or video data.
-
-[`AVFrame`](@ref) must be allocated using [`av_frame_alloc`](@ref)(). Note that this only allocates the [`AVFrame`](@ref) itself, the buffers for the data must be managed through other means (see below). [`AVFrame`](@ref) must be freed with [`av_frame_free`](@ref)().
-
-[`AVFrame`](@ref) is typically allocated once and then reused multiple times to hold different data (e.g. a single [`AVFrame`](@ref) to hold frames received from a decoder). In such a case, [`av_frame_unref`](@ref)() will free any references held by the frame and reset it to its original clean state before it is reused again.
-
-The data described by an [`AVFrame`](@ref) is usually reference counted through the [`AVBuffer`](@ref) API. The underlying buffer references are stored in [`AVFrame`](@ref).buf / [`AVFrame`](@ref).extended\\_buf. An [`AVFrame`](@ref) is considered to be reference counted if at least one reference is set, i.e. if [`AVFrame`](@ref).buf[0] != NULL. In such a case, every single data plane must be contained in one of the buffers in [`AVFrame`](@ref).buf or [`AVFrame`](@ref).extended\\_buf. There may be a single buffer for all the data, or one separate buffer for each plane, or anything in between.
-
-sizeof([`AVFrame`](@ref)) is not a part of the public ABI, so new fields may be added to the end with a minor bump.
-
-Fields can be accessed through AVOptions, the name string used, matches the C structure field name for fields accessible through AVOptions. The [`AVClass`](@ref) for [`AVFrame`](@ref) can be obtained from [`avcodec_get_frame_class`](@ref)()
-"""
-struct AVFrame
-    data::NTuple{536, UInt8}
-end
-
-function Base.getproperty(x::Ptr{AVFrame}, f::Symbol)
-    f === :data && return Ptr{NTuple{8, Ptr{UInt8}}}(x + 0)
-    f === :linesize && return Ptr{NTuple{8, Cint}}(x + 64)
-    f === :extended_data && return Ptr{Ptr{Ptr{UInt8}}}(x + 96)
-    f === :width && return Ptr{Cint}(x + 104)
-    f === :height && return Ptr{Cint}(x + 108)
-    f === :nb_samples && return Ptr{Cint}(x + 112)
-    f === :format && return Ptr{Cint}(x + 116)
-    f === :key_frame && return Ptr{Cint}(x + 120)
-    f === :pict_type && return Ptr{AVPictureType}(x + 124)
-    f === :sample_aspect_ratio && return Ptr{AVRational}(x + 128)
-    f === :pts && return Ptr{Int64}(x + 136)
-    f === :pkt_pts && return Ptr{Int64}(x + 144)
-    f === :pkt_dts && return Ptr{Int64}(x + 152)
-    f === :coded_picture_number && return Ptr{Cint}(x + 160)
-    f === :display_picture_number && return Ptr{Cint}(x + 164)
-    f === :quality && return Ptr{Cint}(x + 168)
-    f === :opaque && return Ptr{Ptr{Cvoid}}(x + 176)
-    f === :error && return Ptr{NTuple{8, UInt64}}(x + 184)
-    f === :repeat_pict && return Ptr{Cint}(x + 248)
-    f === :interlaced_frame && return Ptr{Cint}(x + 252)
-    f === :top_field_first && return Ptr{Cint}(x + 256)
-    f === :palette_has_changed && return Ptr{Cint}(x + 260)
-    f === :reordered_opaque && return Ptr{Int64}(x + 264)
-    f === :sample_rate && return Ptr{Cint}(x + 272)
-    f === :channel_layout && return Ptr{UInt64}(x + 280)
-    f === :buf && return Ptr{NTuple{8, Ptr{AVBufferRef}}}(x + 288)
-    f === :extended_buf && return Ptr{Ptr{Ptr{AVBufferRef}}}(x + 352)
-    f === :nb_extended_buf && return Ptr{Cint}(x + 360)
-    f === :side_data && return Ptr{Ptr{Ptr{AVFrameSideData}}}(x + 368)
-    f === :nb_side_data && return Ptr{Cint}(x + 376)
-    f === :flags && return Ptr{Cint}(x + 380)
-    f === :color_range && return Ptr{AVColorRange}(x + 384)
-    f === :color_primaries && return Ptr{AVColorPrimaries}(x + 388)
-    f === :color_trc && return Ptr{AVColorTransferCharacteristic}(x + 392)
-    f === :colorspace && return Ptr{AVColorSpace}(x + 396)
-    f === :chroma_location && return Ptr{AVChromaLocation}(x + 400)
-    f === :best_effort_timestamp && return Ptr{Int64}(x + 408)
-    f === :pkt_pos && return Ptr{Int64}(x + 416)
-    f === :pkt_duration && return Ptr{Int64}(x + 424)
-    f === :metadata && return Ptr{Ptr{AVDictionary}}(x + 432)
-    f === :decode_error_flags && return Ptr{Cint}(x + 440)
-    f === :channels && return Ptr{Cint}(x + 444)
-    f === :pkt_size && return Ptr{Cint}(x + 448)
-    f === :qscale_table && return Ptr{Ptr{Int8}}(x + 456)
-    f === :qstride && return Ptr{Cint}(x + 464)
-    f === :qscale_type && return Ptr{Cint}(x + 468)
-    f === :qp_table_buf && return Ptr{Ptr{AVBufferRef}}(x + 472)
-    f === :hw_frames_ctx && return Ptr{Ptr{AVBufferRef}}(x + 480)
-    f === :opaque_ref && return Ptr{Ptr{AVBufferRef}}(x + 488)
-    f === :crop_top && return Ptr{Csize_t}(x + 496)
-    f === :crop_bottom && return Ptr{Csize_t}(x + 504)
-    f === :crop_left && return Ptr{Csize_t}(x + 512)
-    f === :crop_right && return Ptr{Csize_t}(x + 520)
-    f === :private_ref && return Ptr{Ptr{AVBufferRef}}(x + 528)
-    return getfield(x, f)
-end
-
-function Base.getproperty(x::AVFrame, f::Symbol)
-    r = Ref{AVFrame}(x)
-    ptr = Base.unsafe_convert(Ptr{AVFrame}, r)
-    fptr = getproperty(ptr, f)
-    GC.@preserve r unsafe_load(fptr)
-end
-
-function Base.setproperty!(x::Ptr{AVFrame}, f::Symbol, v)
-    unsafe_store!(getproperty(x, f), v)
 end
 
 """
-    AVProfile
+    AVDiscard
 
-[`AVProfile`](@ref).
+` lavc_decoding`
 """
-struct AVProfile
-    profile::Cint
-    name::Cstring
-end
+const AVDiscard = Int32
+const AVDISCARD_NONE = -16 % Int32
+const AVDISCARD_DEFAULT = 0 % Int32
+const AVDISCARD_NONREF = 8 % Int32
+const AVDISCARD_BIDIR = 16 % Int32
+const AVDISCARD_NONINTRA = 24 % Int32
+const AVDISCARD_NONKEY = 32 % Int32
+const AVDISCARD_ALL = 48 % Int32
 
 """
     AVCodecDescriptor
 
-This struct describes the properties of a single codec described by an [`AVCodecID`](@ref). 
+This struct describes the properties of a single codec described by an [`AVCodecID`](@ref).
 
 ### See also
 [`avcodec_descriptor_get`](@ref)()
@@ -2657,9 +2912,9 @@ end
 """
     AVPacketSideDataType
 
-` lavc_packet AVPacket`
+` lavc_packet_side_data AVPacketSideData`
 
-Types and functions for working with [`AVPacket`](@ref). @{
+Types and functions for working with [`AVPacketSideData`](@ref). @{
 """
 const AVPacketSideDataType = UInt32
 const AV_PKT_DATA_PALETTE = 0 % UInt32
@@ -2693,21 +2948,48 @@ const AV_PKT_DATA_PRFT = 27 % UInt32
 const AV_PKT_DATA_ICC_PROFILE = 28 % UInt32
 const AV_PKT_DATA_DOVI_CONF = 29 % UInt32
 const AV_PKT_DATA_S12M_TIMECODE = 30 % UInt32
-const AV_PKT_DATA_NB = 31 % UInt32
+const AV_PKT_DATA_DYNAMIC_HDR10_PLUS = 31 % UInt32
+const AV_PKT_DATA_NB = 32 % UInt32
+
+"""
+    AVPacketSideData
+
+This structure stores auxiliary information for decoding, presenting, or otherwise processing the coded stream. It is typically exported by demuxers and encoders and can be fed to decoders and muxers either in a per packet basis, or as global side data (applying to the entire coded stream).
+
+Global side data is handled as follows: - During demuxing, it may be exported through AVStream.codecpar.side_data "[`AVStream`](@ref)'s codec parameters", which can then be passed as input to decoders through the AVCodecContext.coded_side_data "decoder context's side data", for initialization. - For muxing, it can be fed through AVStream.codecpar.side_data "[`AVStream`](@ref)'s codec parameters", typically the output of encoders through the AVCodecContext.coded_side_data "encoder context's side data", for initialization.
+
+Packet specific side data is handled as follows: - During demuxing, it may be exported through AVPacket.side_data "[`AVPacket`](@ref)'s side data", which can then be passed as input to decoders. - For muxing, it can be fed through AVPacket.side_data "[`AVPacket`](@ref)'s side data", typically the output of encoders.
 
+Different modules may accept or export different types of side data depending on media type and codec. Refer to AVPacketSideDataType for a list of defined types and where they may be found or used.
+"""
 struct AVPacketSideData
     data::Ptr{UInt8}
-    size::Cint
+    size::Csize_t
     type::AVPacketSideDataType
 end
 
+mutable struct AVBuffer end
+
+"""
+    AVBufferRef
+
+A reference to a data buffer.
+
+The size of this struct is not a part of the public ABI and it is not meant to be allocated directly.
+"""
+struct AVBufferRef
+    buffer::Ptr{AVBuffer}
+    data::Ptr{UInt8}
+    size::Csize_t
+end
+
 """
     AVCodecContext
 
 main external API structure. New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. You can use AVOptions (av\\_opt* / av\\_set/get*()) to access these fields from user applications. The name string for AVOptions options matches the associated command line parameter name and can be found in libavcodec/options\\_table.h The [`AVOption`](@ref)/command line parameter names differ in some cases from the C structure field names for historic reasons or brevity. sizeof([`AVCodecContext`](@ref)) must not be used outside libav*.
 """
 struct AVCodecContext
-    data::NTuple{1080, UInt8}
+    data::NTuple{944, UInt8}
 end
 
 function Base.getproperty(x::Ptr{AVCodecContext}, f::Symbol)
@@ -2741,170 +3023,135 @@ function Base.getproperty(x::Ptr{AVCodecContext}, f::Symbol)
     f === :get_format && return Ptr{Ptr{Cvoid}}(x + 152)
     f === :max_b_frames && return Ptr{Cint}(x + 160)
     f === :b_quant_factor && return Ptr{Cfloat}(x + 164)
-    f === :b_frame_strategy && return Ptr{Cint}(x + 168)
-    f === :b_quant_offset && return Ptr{Cfloat}(x + 172)
-    f === :has_b_frames && return Ptr{Cint}(x + 176)
-    f === :mpeg_quant && return Ptr{Cint}(x + 180)
-    f === :i_quant_factor && return Ptr{Cfloat}(x + 184)
-    f === :i_quant_offset && return Ptr{Cfloat}(x + 188)
-    f === :lumi_masking && return Ptr{Cfloat}(x + 192)
-    f === :temporal_cplx_masking && return Ptr{Cfloat}(x + 196)
-    f === :spatial_cplx_masking && return Ptr{Cfloat}(x + 200)
-    f === :p_masking && return Ptr{Cfloat}(x + 204)
-    f === :dark_masking && return Ptr{Cfloat}(x + 208)
-    f === :slice_count && return Ptr{Cint}(x + 212)
-    f === :prediction_method && return Ptr{Cint}(x + 216)
-    f === :slice_offset && return Ptr{Ptr{Cint}}(x + 224)
-    f === :sample_aspect_ratio && return Ptr{AVRational}(x + 232)
-    f === :me_cmp && return Ptr{Cint}(x + 240)
-    f === :me_sub_cmp && return Ptr{Cint}(x + 244)
-    f === :mb_cmp && return Ptr{Cint}(x + 248)
-    f === :ildct_cmp && return Ptr{Cint}(x + 252)
-    f === :dia_size && return Ptr{Cint}(x + 256)
-    f === :last_predictor_count && return Ptr{Cint}(x + 260)
-    f === :pre_me && return Ptr{Cint}(x + 264)
-    f === :me_pre_cmp && return Ptr{Cint}(x + 268)
-    f === :pre_dia_size && return Ptr{Cint}(x + 272)
-    f === :me_subpel_quality && return Ptr{Cint}(x + 276)
-    f === :me_range && return Ptr{Cint}(x + 280)
-    f === :slice_flags && return Ptr{Cint}(x + 284)
-    f === :mb_decision && return Ptr{Cint}(x + 288)
-    f === :intra_matrix && return Ptr{Ptr{UInt16}}(x + 296)
-    f === :inter_matrix && return Ptr{Ptr{UInt16}}(x + 304)
-    f === :scenechange_threshold && return Ptr{Cint}(x + 312)
-    f === :noise_reduction && return Ptr{Cint}(x + 316)
-    f === :intra_dc_precision && return Ptr{Cint}(x + 320)
-    f === :skip_top && return Ptr{Cint}(x + 324)
-    f === :skip_bottom && return Ptr{Cint}(x + 328)
-    f === :mb_lmin && return Ptr{Cint}(x + 332)
-    f === :mb_lmax && return Ptr{Cint}(x + 336)
-    f === :me_penalty_compensation && return Ptr{Cint}(x + 340)
-    f === :bidir_refine && return Ptr{Cint}(x + 344)
-    f === :brd_scale && return Ptr{Cint}(x + 348)
-    f === :keyint_min && return Ptr{Cint}(x + 352)
-    f === :refs && return Ptr{Cint}(x + 356)
-    f === :chromaoffset && return Ptr{Cint}(x + 360)
-    f === :mv0_threshold && return Ptr{Cint}(x + 364)
-    f === :b_sensitivity && return Ptr{Cint}(x + 368)
-    f === :color_primaries && return Ptr{AVColorPrimaries}(x + 372)
-    f === :color_trc && return Ptr{AVColorTransferCharacteristic}(x + 376)
-    f === :colorspace && return Ptr{AVColorSpace}(x + 380)
-    f === :color_range && return Ptr{AVColorRange}(x + 384)
-    f === :chroma_sample_location && return Ptr{AVChromaLocation}(x + 388)
-    f === :slices && return Ptr{Cint}(x + 392)
-    f === :field_order && return Ptr{AVFieldOrder}(x + 396)
-    f === :sample_rate && return Ptr{Cint}(x + 400)
-    f === :channels && return Ptr{Cint}(x + 404)
-    f === :sample_fmt && return Ptr{AVSampleFormat}(x + 408)
-    f === :frame_size && return Ptr{Cint}(x + 412)
-    f === :frame_number && return Ptr{Cint}(x + 416)
-    f === :block_align && return Ptr{Cint}(x + 420)
-    f === :cutoff && return Ptr{Cint}(x + 424)
-    f === :channel_layout && return Ptr{UInt64}(x + 432)
-    f === :request_channel_layout && return Ptr{UInt64}(x + 440)
-    f === :audio_service_type && return Ptr{AVAudioServiceType}(x + 448)
-    f === :request_sample_fmt && return Ptr{AVSampleFormat}(x + 452)
-    f === :get_buffer2 && return Ptr{Ptr{Cvoid}}(x + 456)
-    f === :refcounted_frames && return Ptr{Cint}(x + 464)
-    f === :qcompress && return Ptr{Cfloat}(x + 468)
-    f === :qblur && return Ptr{Cfloat}(x + 472)
-    f === :qmin && return Ptr{Cint}(x + 476)
-    f === :qmax && return Ptr{Cint}(x + 480)
-    f === :max_qdiff && return Ptr{Cint}(x + 484)
-    f === :rc_buffer_size && return Ptr{Cint}(x + 488)
-    f === :rc_override_count && return Ptr{Cint}(x + 492)
-    f === :rc_override && return Ptr{Ptr{RcOverride}}(x + 496)
-    f === :rc_max_rate && return Ptr{Int64}(x + 504)
-    f === :rc_min_rate && return Ptr{Int64}(x + 512)
-    f === :rc_max_available_vbv_use && return Ptr{Cfloat}(x + 520)
-    f === :rc_min_vbv_overflow_use && return Ptr{Cfloat}(x + 524)
-    f === :rc_initial_buffer_occupancy && return Ptr{Cint}(x + 528)
-    f === :coder_type && return Ptr{Cint}(x + 532)
-    f === :context_model && return Ptr{Cint}(x + 536)
-    f === :frame_skip_threshold && return Ptr{Cint}(x + 540)
-    f === :frame_skip_factor && return Ptr{Cint}(x + 544)
-    f === :frame_skip_exp && return Ptr{Cint}(x + 548)
-    f === :frame_skip_cmp && return Ptr{Cint}(x + 552)
-    f === :trellis && return Ptr{Cint}(x + 556)
-    f === :min_prediction_order && return Ptr{Cint}(x + 560)
-    f === :max_prediction_order && return Ptr{Cint}(x + 564)
-    f === :timecode_frame_start && return Ptr{Int64}(x + 568)
-    f === :rtp_callback && return Ptr{Ptr{Cvoid}}(x + 576)
-    f === :rtp_payload_size && return Ptr{Cint}(x + 584)
-    f === :mv_bits && return Ptr{Cint}(x + 588)
-    f === :header_bits && return Ptr{Cint}(x + 592)
-    f === :i_tex_bits && return Ptr{Cint}(x + 596)
-    f === :p_tex_bits && return Ptr{Cint}(x + 600)
-    f === :i_count && return Ptr{Cint}(x + 604)
-    f === :p_count && return Ptr{Cint}(x + 608)
-    f === :skip_count && return Ptr{Cint}(x + 612)
-    f === :misc_bits && return Ptr{Cint}(x + 616)
-    f === :frame_bits && return Ptr{Cint}(x + 620)
-    f === :stats_out && return Ptr{Cstring}(x + 624)
-    f === :stats_in && return Ptr{Cstring}(x + 632)
-    f === :workaround_bugs && return Ptr{Cint}(x + 640)
-    f === :strict_std_compliance && return Ptr{Cint}(x + 644)
-    f === :error_concealment && return Ptr{Cint}(x + 648)
-    f === :debug && return Ptr{Cint}(x + 652)
-    f === :err_recognition && return Ptr{Cint}(x + 656)
-    f === :reordered_opaque && return Ptr{Int64}(x + 664)
-    f === :hwaccel && return Ptr{Ptr{AVHWAccel}}(x + 672)
-    f === :hwaccel_context && return Ptr{Ptr{Cvoid}}(x + 680)
-    f === :error && return Ptr{NTuple{8, UInt64}}(x + 688)
-    f === :dct_algo && return Ptr{Cint}(x + 752)
-    f === :idct_algo && return Ptr{Cint}(x + 756)
-    f === :bits_per_coded_sample && return Ptr{Cint}(x + 760)
-    f === :bits_per_raw_sample && return Ptr{Cint}(x + 764)
-    f === :lowres && return Ptr{Cint}(x + 768)
-    f === :coded_frame && return Ptr{Ptr{AVFrame}}(x + 776)
-    f === :thread_count && return Ptr{Cint}(x + 784)
-    f === :thread_type && return Ptr{Cint}(x + 788)
-    f === :active_thread_type && return Ptr{Cint}(x + 792)
-    f === :thread_safe_callbacks && return Ptr{Cint}(x + 796)
-    f === :execute && return Ptr{Ptr{Cvoid}}(x + 800)
-    f === :execute2 && return Ptr{Ptr{Cvoid}}(x + 808)
-    f === :nsse_weight && return Ptr{Cint}(x + 816)
-    f === :profile && return Ptr{Cint}(x + 820)
-    f === :level && return Ptr{Cint}(x + 824)
-    f === :skip_loop_filter && return Ptr{AVDiscard}(x + 828)
-    f === :skip_idct && return Ptr{AVDiscard}(x + 832)
-    f === :skip_frame && return Ptr{AVDiscard}(x + 836)
-    f === :subtitle_header && return Ptr{Ptr{UInt8}}(x + 840)
-    f === :subtitle_header_size && return Ptr{Cint}(x + 848)
-    f === :vbv_delay && return Ptr{UInt64}(x + 856)
-    f === :side_data_only_packets && return Ptr{Cint}(x + 864)
-    f === :initial_padding && return Ptr{Cint}(x + 868)
-    f === :framerate && return Ptr{AVRational}(x + 872)
-    f === :sw_pix_fmt && return Ptr{AVPixelFormat}(x + 880)
-    f === :pkt_timebase && return Ptr{AVRational}(x + 884)
-    f === :codec_descriptor && return Ptr{Ptr{AVCodecDescriptor}}(x + 896)
-    f === :pts_correction_num_faulty_pts && return Ptr{Int64}(x + 904)
-    f === :pts_correction_num_faulty_dts && return Ptr{Int64}(x + 912)
-    f === :pts_correction_last_pts && return Ptr{Int64}(x + 920)
-    f === :pts_correction_last_dts && return Ptr{Int64}(x + 928)
-    f === :sub_charenc && return Ptr{Cstring}(x + 936)
-    f === :sub_charenc_mode && return Ptr{Cint}(x + 944)
-    f === :skip_alpha && return Ptr{Cint}(x + 948)
-    f === :seek_preroll && return Ptr{Cint}(x + 952)
-    f === :debug_mv && return Ptr{Cint}(x + 956)
-    f === :chroma_intra_matrix && return Ptr{Ptr{UInt16}}(x + 960)
-    f === :dump_separator && return Ptr{Ptr{UInt8}}(x + 968)
-    f === :codec_whitelist && return Ptr{Cstring}(x + 976)
-    f === :properties && return Ptr{Cuint}(x + 984)
-    f === :coded_side_data && return Ptr{Ptr{AVPacketSideData}}(x + 992)
-    f === :nb_coded_side_data && return Ptr{Cint}(x + 1000)
-    f === :hw_frames_ctx && return Ptr{Ptr{AVBufferRef}}(x + 1008)
-    f === :sub_text_format && return Ptr{Cint}(x + 1016)
-    f === :trailing_padding && return Ptr{Cint}(x + 1020)
-    f === :max_pixels && return Ptr{Int64}(x + 1024)
-    f === :hw_device_ctx && return Ptr{Ptr{AVBufferRef}}(x + 1032)
-    f === :hwaccel_flags && return Ptr{Cint}(x + 1040)
-    f === :apply_cropping && return Ptr{Cint}(x + 1044)
-    f === :extra_hw_frames && return Ptr{Cint}(x + 1048)
-    f === :discard_damaged_percentage && return Ptr{Cint}(x + 1052)
-    f === :max_samples && return Ptr{Int64}(x + 1056)
-    f === :export_side_data && return Ptr{Cint}(x + 1064)
-    f === :get_encode_buffer && return Ptr{Ptr{Cvoid}}(x + 1072)
+    f === :b_quant_offset && return Ptr{Cfloat}(x + 168)
+    f === :has_b_frames && return Ptr{Cint}(x + 172)
+    f === :i_quant_factor && return Ptr{Cfloat}(x + 176)
+    f === :i_quant_offset && return Ptr{Cfloat}(x + 180)
+    f === :lumi_masking && return Ptr{Cfloat}(x + 184)
+    f === :temporal_cplx_masking && return Ptr{Cfloat}(x + 188)
+    f === :spatial_cplx_masking && return Ptr{Cfloat}(x + 192)
+    f === :p_masking && return Ptr{Cfloat}(x + 196)
+    f === :dark_masking && return Ptr{Cfloat}(x + 200)
+    f === :slice_count && return Ptr{Cint}(x + 204)
+    f === :slice_offset && return Ptr{Ptr{Cint}}(x + 208)
+    f === :sample_aspect_ratio && return Ptr{AVRational}(x + 216)
+    f === :me_cmp && return Ptr{Cint}(x + 224)
+    f === :me_sub_cmp && return Ptr{Cint}(x + 228)
+    f === :mb_cmp && return Ptr{Cint}(x + 232)
+    f === :ildct_cmp && return Ptr{Cint}(x + 236)
+    f === :dia_size && return Ptr{Cint}(x + 240)
+    f === :last_predictor_count && return Ptr{Cint}(x + 244)
+    f === :me_pre_cmp && return Ptr{Cint}(x + 248)
+    f === :pre_dia_size && return Ptr{Cint}(x + 252)
+    f === :me_subpel_quality && return Ptr{Cint}(x + 256)
+    f === :me_range && return Ptr{Cint}(x + 260)
+    f === :slice_flags && return Ptr{Cint}(x + 264)
+    f === :mb_decision && return Ptr{Cint}(x + 268)
+    f === :intra_matrix && return Ptr{Ptr{UInt16}}(x + 272)
+    f === :inter_matrix && return Ptr{Ptr{UInt16}}(x + 280)
+    f === :intra_dc_precision && return Ptr{Cint}(x + 288)
+    f === :skip_top && return Ptr{Cint}(x + 292)
+    f === :skip_bottom && return Ptr{Cint}(x + 296)
+    f === :mb_lmin && return Ptr{Cint}(x + 300)
+    f === :mb_lmax && return Ptr{Cint}(x + 304)
+    f === :bidir_refine && return Ptr{Cint}(x + 308)
+    f === :keyint_min && return Ptr{Cint}(x + 312)
+    f === :refs && return Ptr{Cint}(x + 316)
+    f === :mv0_threshold && return Ptr{Cint}(x + 320)
+    f === :color_primaries && return Ptr{AVColorPrimaries}(x + 324)
+    f === :color_trc && return Ptr{AVColorTransferCharacteristic}(x + 328)
+    f === :colorspace && return Ptr{AVColorSpace}(x + 332)
+    f === :color_range && return Ptr{AVColorRange}(x + 336)
+    f === :chroma_sample_location && return Ptr{AVChromaLocation}(x + 340)
+    f === :slices && return Ptr{Cint}(x + 344)
+    f === :field_order && return Ptr{AVFieldOrder}(x + 348)
+    f === :sample_rate && return Ptr{Cint}(x + 352)
+    f === :channels && return Ptr{Cint}(x + 356)
+    f === :sample_fmt && return Ptr{AVSampleFormat}(x + 360)
+    f === :frame_size && return Ptr{Cint}(x + 364)
+    f === :frame_number && return Ptr{Cint}(x + 368)
+    f === :block_align && return Ptr{Cint}(x + 372)
+    f === :cutoff && return Ptr{Cint}(x + 376)
+    f === :channel_layout && return Ptr{UInt64}(x + 384)
+    f === :request_channel_layout && return Ptr{UInt64}(x + 392)
+    f === :audio_service_type && return Ptr{AVAudioServiceType}(x + 400)
+    f === :request_sample_fmt && return Ptr{AVSampleFormat}(x + 404)
+    f === :get_buffer2 && return Ptr{Ptr{Cvoid}}(x + 408)
+    f === :qcompress && return Ptr{Cfloat}(x + 416)
+    f === :qblur && return Ptr{Cfloat}(x + 420)
+    f === :qmin && return Ptr{Cint}(x + 424)
+    f === :qmax && return Ptr{Cint}(x + 428)
+    f === :max_qdiff && return Ptr{Cint}(x + 432)
+    f === :rc_buffer_size && return Ptr{Cint}(x + 436)
+    f === :rc_override_count && return Ptr{Cint}(x + 440)
+    f === :rc_override && return Ptr{Ptr{RcOverride}}(x + 448)
+    f === :rc_max_rate && return Ptr{Int64}(x + 456)
+    f === :rc_min_rate && return Ptr{Int64}(x + 464)
+    f === :rc_max_available_vbv_use && return Ptr{Cfloat}(x + 472)
+    f === :rc_min_vbv_overflow_use && return Ptr{Cfloat}(x + 476)
+    f === :rc_initial_buffer_occupancy && return Ptr{Cint}(x + 480)
+    f === :trellis && return Ptr{Cint}(x + 484)
+    f === :stats_out && return Ptr{Cstring}(x + 488)
+    f === :stats_in && return Ptr{Cstring}(x + 496)
+    f === :workaround_bugs && return Ptr{Cint}(x + 504)
+    f === :strict_std_compliance && return Ptr{Cint}(x + 508)
+    f === :error_concealment && return Ptr{Cint}(x + 512)
+    f === :debug && return Ptr{Cint}(x + 516)
+    f === :err_recognition && return Ptr{Cint}(x + 520)
+    f === :reordered_opaque && return Ptr{Int64}(x + 528)
+    f === :hwaccel && return Ptr{Ptr{AVHWAccel}}(x + 536)
+    f === :hwaccel_context && return Ptr{Ptr{Cvoid}}(x + 544)
+    f === :error && return Ptr{NTuple{8, UInt64}}(x + 552)
+    f === :dct_algo && return Ptr{Cint}(x + 616)
+    f === :idct_algo && return Ptr{Cint}(x + 620)
+    f === :bits_per_coded_sample && return Ptr{Cint}(x + 624)
+    f === :bits_per_raw_sample && return Ptr{Cint}(x + 628)
+    f === :lowres && return Ptr{Cint}(x + 632)
+    f === :thread_count && return Ptr{Cint}(x + 636)
+    f === :thread_type && return Ptr{Cint}(x + 640)
+    f === :active_thread_type && return Ptr{Cint}(x + 644)
+    f === :execute && return Ptr{Ptr{Cvoid}}(x + 648)
+    f === :execute2 && return Ptr{Ptr{Cvoid}}(x + 656)
+    f === :nsse_weight && return Ptr{Cint}(x + 664)
+    f === :profile && return Ptr{Cint}(x + 668)
+    f === :level && return Ptr{Cint}(x + 672)
+    f === :skip_loop_filter && return Ptr{AVDiscard}(x + 676)
+    f === :skip_idct && return Ptr{AVDiscard}(x + 680)
+    f === :skip_frame && return Ptr{AVDiscard}(x + 684)
+    f === :subtitle_header && return Ptr{Ptr{UInt8}}(x + 688)
+    f === :subtitle_header_size && return Ptr{Cint}(x + 696)
+    f === :initial_padding && return Ptr{Cint}(x + 700)
+    f === :framerate && return Ptr{AVRational}(x + 704)
+    f === :sw_pix_fmt && return Ptr{AVPixelFormat}(x + 712)
+    f === :pkt_timebase && return Ptr{AVRational}(x + 716)
+    f === :codec_descriptor && return Ptr{Ptr{AVCodecDescriptor}}(x + 728)
+    f === :pts_correction_num_faulty_pts && return Ptr{Int64}(x + 736)
+    f === :pts_correction_num_faulty_dts && return Ptr{Int64}(x + 744)
+    f === :pts_correction_last_pts && return Ptr{Int64}(x + 752)
+    f === :pts_correction_last_dts && return Ptr{Int64}(x + 760)
+    f === :sub_charenc && return Ptr{Cstring}(x + 768)
+    f === :sub_charenc_mode && return Ptr{Cint}(x + 776)
+    f === :skip_alpha && return Ptr{Cint}(x + 780)
+    f === :seek_preroll && return Ptr{Cint}(x + 784)
+    f === :chroma_intra_matrix && return Ptr{Ptr{UInt16}}(x + 792)
+    f === :dump_separator && return Ptr{Ptr{UInt8}}(x + 800)
+    f === :codec_whitelist && return Ptr{Cstring}(x + 808)
+    f === :properties && return Ptr{Cuint}(x + 816)
+    f === :coded_side_data && return Ptr{Ptr{AVPacketSideData}}(x + 824)
+    f === :nb_coded_side_data && return Ptr{Cint}(x + 832)
+    f === :hw_frames_ctx && return Ptr{Ptr{AVBufferRef}}(x + 840)
+    f === :trailing_padding && return Ptr{Cint}(x + 848)
+    f === :max_pixels && return Ptr{Int64}(x + 856)
+    f === :hw_device_ctx && return Ptr{Ptr{AVBufferRef}}(x + 864)
+    f === :hwaccel_flags && return Ptr{Cint}(x + 872)
+    f === :apply_cropping && return Ptr{Cint}(x + 876)
+    f === :extra_hw_frames && return Ptr{Cint}(x + 880)
+    f === :discard_damaged_percentage && return Ptr{Cint}(x + 884)
+    f === :max_samples && return Ptr{Int64}(x + 888)
+    f === :export_side_data && return Ptr{Cint}(x + 896)
+    f === :get_encode_buffer && return Ptr{Ptr{Cvoid}}(x + 904)
+    f === :ch_layout && return Ptr{AVChannelLayout}(x + 912)
+    f === :frame_num && return Ptr{Int64}(x + 936)
     return getfield(x, f)
 end
 
@@ -2920,139 +3167,10 @@ function Base.setproperty!(x::Ptr{AVCodecContext}, f::Symbol, v)
 end
 
 """
-    av_codec_get_pkt_timebase(avctx)
-
-Accessors for some [`AVCodecContext`](@ref) fields. These used to be provided for ABI compatibility, and do not need to be used anymore.
-"""
-function av_codec_get_pkt_timebase(avctx)
-    ccall((:av_codec_get_pkt_timebase, libavcodec), AVRational, (Ptr{AVCodecContext},), avctx)
-end
-
-function av_codec_set_pkt_timebase(avctx, val::AVRational)
-    ccall((:av_codec_set_pkt_timebase, libavcodec), Cvoid, (Ptr{AVCodecContext}, AVRational), avctx, val)
-end
-
-function av_codec_get_codec_descriptor(avctx)
-    ccall((:av_codec_get_codec_descriptor, libavcodec), Ptr{AVCodecDescriptor}, (Ptr{AVCodecContext},), avctx)
-end
-
-function av_codec_set_codec_descriptor(avctx, desc)
-    ccall((:av_codec_set_codec_descriptor, libavcodec), Cvoid, (Ptr{AVCodecContext}, Ptr{AVCodecDescriptor}), avctx, desc)
-end
-
-function av_codec_get_codec_properties(avctx)
-    ccall((:av_codec_get_codec_properties, libavcodec), Cuint, (Ptr{AVCodecContext},), avctx)
-end
+    AVSubtitleType
 
-function av_codec_get_lowres(avctx)
-    ccall((:av_codec_get_lowres, libavcodec), Cint, (Ptr{AVCodecContext},), avctx)
-end
-
-function av_codec_set_lowres(avctx, val::Integer)
-    ccall((:av_codec_set_lowres, libavcodec), Cvoid, (Ptr{AVCodecContext}, Cint), avctx, val)
-end
-
-function av_codec_get_seek_preroll(avctx)
-    ccall((:av_codec_get_seek_preroll, libavcodec), Cint, (Ptr{AVCodecContext},), avctx)
-end
-
-function av_codec_set_seek_preroll(avctx, val::Integer)
-    ccall((:av_codec_set_seek_preroll, libavcodec), Cvoid, (Ptr{AVCodecContext}, Cint), avctx, val)
-end
-
-function av_codec_get_chroma_intra_matrix(avctx)
-    ccall((:av_codec_get_chroma_intra_matrix, libavcodec), Ptr{UInt16}, (Ptr{AVCodecContext},), avctx)
-end
-
-function av_codec_set_chroma_intra_matrix(avctx, val)
-    ccall((:av_codec_set_chroma_intra_matrix, libavcodec), Cvoid, (Ptr{AVCodecContext}, Ptr{UInt16}), avctx, val)
-end
-
-mutable struct AVCodecDefault end
-
-mutable struct AVCodecHWConfigInternal end
-
-"""
-    AVCodec
-
-[`AVCodec`](@ref).
-"""
-struct AVCodec
-    name::Cstring
-    long_name::Cstring
-    type::AVMediaType
-    id::AVCodecID
-    capabilities::Cint
-    supported_framerates::Ptr{AVRational}
-    pix_fmts::Ptr{AVPixelFormat}
-    supported_samplerates::Ptr{Cint}
-    sample_fmts::Ptr{AVSampleFormat}
-    channel_layouts::Ptr{Cvoid} # channel_layouts::Ptr{UInt64}
-    max_lowres::UInt8
-    priv_class::Ptr{AVClass}
-    profiles::Ptr{AVProfile}
-    wrapper_name::Cstring
-    priv_data_size::Cint
-    next::Ptr{AVCodec}
-    update_thread_context::Ptr{Cvoid}
-    defaults::Ptr{AVCodecDefault}
-    init_static_data::Ptr{Cvoid}
-    init::Ptr{Cvoid}
-    encode_sub::Ptr{Cvoid}
-    encode2::Ptr{Cvoid}
-    decode::Ptr{Cvoid}
-    close::Ptr{Cvoid}
-    receive_packet::Ptr{Cvoid}
-    receive_frame::Ptr{Cvoid}
-    flush::Ptr{Cvoid}
-    caps_internal::Cint
-    bsfs::Cstring
-    hw_configs::Ptr{Ptr{AVCodecHWConfigInternal}}
-    codec_tags::Ptr{Cvoid} # codec_tags::Ptr{UInt32}
-end
-
-function Base.getproperty(x::AVCodec, f::Symbol)
-    f === :channel_layouts && return Ptr{UInt64}(getfield(x, f))
-    f === :codec_tags && return Ptr{UInt32}(getfield(x, f))
-    return getfield(x, f)
-end
-
-function av_codec_get_max_lowres(codec)
-    ccall((:av_codec_get_max_lowres, libavcodec), Cint, (Ptr{AVCodec},), codec)
-end
-
-mutable struct MpegEncContext end
-
-"""
-    AVPicture
-
-[`Picture`](@ref) data structure.
-
-Up to four components can be stored into it, the last component is alpha. 
-
-\\deprecated use [`AVFrame`](@ref) or imgutils functions instead
+@}
 """
-struct AVPicture
-    data::NTuple{96, UInt8}
-end
-
-function Base.getproperty(x::Ptr{AVPicture}, f::Symbol)
-    f === :data && return Ptr{NTuple{8, Ptr{UInt8}}}(x + 0)
-    f === :linesize && return Ptr{NTuple{8, Cint}}(x + 64)
-    return getfield(x, f)
-end
-
-function Base.getproperty(x::AVPicture, f::Symbol)
-    r = Ref{AVPicture}(x)
-    ptr = Base.unsafe_convert(Ptr{AVPicture}, r)
-    fptr = getproperty(ptr, f)
-    GC.@preserve r unsafe_load(fptr)
-end
-
-function Base.setproperty!(x::Ptr{AVPicture}, f::Symbol, v)
-    unsafe_store!(getproperty(x, f), v)
-end
-
 const AVSubtitleType = UInt32
 const SUBTITLE_NONE = 0 % UInt32
 const SUBTITLE_BITMAP = 1 % UInt32
@@ -3060,34 +3178,17 @@ const SUBTITLE_TEXT = 2 % UInt32
 const SUBTITLE_ASS = 3 % UInt32
 
 struct AVSubtitleRect
-    data::NTuple{200, UInt8}
-end
-
-function Base.getproperty(x::Ptr{AVSubtitleRect}, f::Symbol)
-    f === :x && return Ptr{Cint}(x + 0)
-    f === :y && return Ptr{Cint}(x + 4)
-    f === :w && return Ptr{Cint}(x + 8)
-    f === :h && return Ptr{Cint}(x + 12)
-    f === :nb_colors && return Ptr{Cint}(x + 16)
-    f === :pict && return Ptr{AVPicture}(x + 24)
-    f === :data && return Ptr{NTuple{4, Ptr{UInt8}}}(x + 120)
-    f === :linesize && return Ptr{NTuple{4, Cint}}(x + 152)
-    f === :type && return Ptr{AVSubtitleType}(x + 168)
-    f === :text && return Ptr{Cstring}(x + 176)
-    f === :ass && return Ptr{Cstring}(x + 184)
-    f === :flags && return Ptr{Cint}(x + 192)
-    return getfield(x, f)
-end
-
-function Base.getproperty(x::AVSubtitleRect, f::Symbol)
-    r = Ref{AVSubtitleRect}(x)
-    ptr = Base.unsafe_convert(Ptr{AVSubtitleRect}, r)
-    fptr = getproperty(ptr, f)
-    GC.@preserve r unsafe_load(fptr)
-end
-
-function Base.setproperty!(x::Ptr{AVSubtitleRect}, f::Symbol, v)
-    unsafe_store!(getproperty(x, f), v)
+    x::Cint
+    y::Cint
+    w::Cint
+    h::Cint
+    nb_colors::Cint
+    data::NTuple{4, Ptr{UInt8}}
+    linesize::NTuple{4, Cint}
+    type::AVSubtitleType
+    text::Cstring
+    ass::Cstring
+    flags::Cint
 end
 
 struct AVSubtitle
@@ -3099,15 +3200,6 @@ struct AVSubtitle
     pts::Int64
 end
 
-"""
-    av_codec_next(c)
-
-If c is NULL, returns the first registered codec, if c is non-NULL, returns the next registered codec after c, or NULL if c is the last one.
-"""
-function av_codec_next(c)
-    ccall((:av_codec_next, libavcodec), Ptr{AVCodec}, (Ptr{AVCodec},), c)
-end
-
 """
     avcodec_version()
 
@@ -3135,24 +3227,6 @@ function avcodec_license()
     ccall((:avcodec_license, libavcodec), Cstring, ())
 end
 
-"""
-    avcodec_register(codec)
-
-\\deprecated Calling this function is unnecessary.
-"""
-function avcodec_register(codec)
-    ccall((:avcodec_register, libavcodec), Cvoid, (Ptr{AVCodec},), codec)
-end
-
-"""
-    avcodec_register_all()
-
-\\deprecated Calling this function is unnecessary.
-"""
-function avcodec_register_all()
-    ccall((:avcodec_register_all, libavcodec), Cvoid, ())
-end
-
 """
     avcodec_alloc_context3(codec)
 
@@ -3160,7 +3234,6 @@ Allocate an [`AVCodecContext`](@ref) and set its fields to default values. The r
 
 ### Parameters
 * `codec`: if non-NULL, allocate private data and initialize defaults for the given codec. It is illegal to then call [`avcodec_open2`](@ref)() with a different codec. If NULL, then the codec-specific defaults won't be initialized, which may result in suboptimal default settings (this is important mainly for encoders, e.g. libx264).
-
 ### Returns
 An [`AVCodecContext`](@ref) filled with default values or NULL on failure.
 """
@@ -3177,15 +3250,6 @@ function avcodec_free_context(avctx)
     ccall((:avcodec_free_context, libavcodec), Cvoid, (Ptr{Ptr{AVCodecContext}},), avctx)
 end
 
-"""
-    avcodec_get_context_defaults3(s, codec)
-
-\\deprecated This function should not be used, as closing and opening a codec context multiple time is not supported. A new codec context should be allocated for each new use.
-"""
-function avcodec_get_context_defaults3(s, codec)
-    ccall((:avcodec_get_context_defaults3, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVCodec}), s, codec)
-end
-
 """
     avcodec_get_class()
 
@@ -3198,15 +3262,6 @@ function avcodec_get_class()
     ccall((:avcodec_get_class, libavcodec), Ptr{AVClass}, ())
 end
 
-"""
-    avcodec_get_frame_class()
-
-\\deprecated This function should not be used.
-"""
-function avcodec_get_frame_class()
-    ccall((:avcodec_get_frame_class, libavcodec), Ptr{AVClass}, ())
-end
-
 """
     avcodec_get_subtitle_rect_class()
 
@@ -3219,25 +3274,6 @@ function avcodec_get_subtitle_rect_class()
     ccall((:avcodec_get_subtitle_rect_class, libavcodec), Ptr{AVClass}, ())
 end
 
-"""
-    avcodec_copy_context(dest, src)
-
-Copy the settings of the source [`AVCodecContext`](@ref) into the destination [`AVCodecContext`](@ref). The resulting destination codec context will be unopened, i.e. you are required to call [`avcodec_open2`](@ref)() before you can use this [`AVCodecContext`](@ref) to decode/encode video/audio data.
-
-\\deprecated The semantics of this function are ill-defined and it should not be used. If you need to transfer the stream parameters from one codec context to another, use an intermediate [`AVCodecParameters`](@ref) instance and the [`avcodec_parameters_from_context`](@ref)() / [`avcodec_parameters_to_context`](@ref)() functions.
-
-### Parameters
-* `dest`: target codec context, should be initialized with [`avcodec_alloc_context3`](@ref)(NULL), but otherwise uninitialized 
-
-* `src`: source codec context 
-
-### Returns
-[`AVERROR`](@ref)() on error (e.g. memory allocation error), 0 on success
-"""
-function avcodec_copy_context(dest, src)
-    ccall((:avcodec_copy_context, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVCodecContext}), dest, src)
-end
-
 """
     AVCodecParameters
 
@@ -3246,35 +3282,55 @@ This struct describes the properties of an encoded stream.
 sizeof([`AVCodecParameters`](@ref)) is not a part of the public ABI, this struct must be allocated with [`avcodec_parameters_alloc`](@ref)() and freed with [`avcodec_parameters_free`](@ref)().
 """
 struct AVCodecParameters
-    codec_type::AVMediaType
-    codec_id::AVCodecID
-    codec_tag::UInt32
-    extradata::Ptr{UInt8}
-    extradata_size::Cint
-    format::Cint
-    bit_rate::Int64
-    bits_per_coded_sample::Cint
-    bits_per_raw_sample::Cint
-    profile::Cint
-    level::Cint
-    width::Cint
-    height::Cint
-    sample_aspect_ratio::AVRational
-    field_order::AVFieldOrder
-    color_range::AVColorRange
-    color_primaries::AVColorPrimaries
-    color_trc::AVColorTransferCharacteristic
-    color_space::AVColorSpace
-    chroma_location::AVChromaLocation
-    video_delay::Cint
-    channel_layout::UInt64
-    channels::Cint
-    sample_rate::Cint
-    block_align::Cint
-    frame_size::Cint
-    initial_padding::Cint
-    trailing_padding::Cint
-    seek_preroll::Cint
+    data::NTuple{192, UInt8}
+end
+
+function Base.getproperty(x::Ptr{AVCodecParameters}, f::Symbol)
+    f === :codec_type && return Ptr{AVMediaType}(x + 0)
+    f === :codec_id && return Ptr{AVCodecID}(x + 4)
+    f === :codec_tag && return Ptr{UInt32}(x + 8)
+    f === :extradata && return Ptr{Ptr{UInt8}}(x + 16)
+    f === :extradata_size && return Ptr{Cint}(x + 24)
+    f === :format && return Ptr{Cint}(x + 28)
+    f === :bit_rate && return Ptr{Int64}(x + 32)
+    f === :bits_per_coded_sample && return Ptr{Cint}(x + 40)
+    f === :bits_per_raw_sample && return Ptr{Cint}(x + 44)
+    f === :profile && return Ptr{Cint}(x + 48)
+    f === :level && return Ptr{Cint}(x + 52)
+    f === :width && return Ptr{Cint}(x + 56)
+    f === :height && return Ptr{Cint}(x + 60)
+    f === :sample_aspect_ratio && return Ptr{AVRational}(x + 64)
+    f === :field_order && return Ptr{AVFieldOrder}(x + 72)
+    f === :color_range && return Ptr{AVColorRange}(x + 76)
+    f === :color_primaries && return Ptr{AVColorPrimaries}(x + 80)
+    f === :color_trc && return Ptr{AVColorTransferCharacteristic}(x + 84)
+    f === :color_space && return Ptr{AVColorSpace}(x + 88)
+    f === :chroma_location && return Ptr{AVChromaLocation}(x + 92)
+    f === :video_delay && return Ptr{Cint}(x + 96)
+    f === :channel_layout && return Ptr{UInt64}(x + 104)
+    f === :channels && return Ptr{Cint}(x + 112)
+    f === :sample_rate && return Ptr{Cint}(x + 116)
+    f === :block_align && return Ptr{Cint}(x + 120)
+    f === :frame_size && return Ptr{Cint}(x + 124)
+    f === :initial_padding && return Ptr{Cint}(x + 128)
+    f === :trailing_padding && return Ptr{Cint}(x + 132)
+    f === :seek_preroll && return Ptr{Cint}(x + 136)
+    f === :ch_layout && return Ptr{AVChannelLayout}(x + 144)
+    f === :framerate && return Ptr{AVRational}(x + 168)
+    f === :coded_side_data && return Ptr{Ptr{AVPacketSideData}}(x + 176)
+    f === :nb_coded_side_data && return Ptr{Cint}(x + 184)
+    return getfield(x, f)
+end
+
+function Base.getproperty(x::AVCodecParameters, f::Symbol)
+    r = Ref{AVCodecParameters}(x)
+    ptr = Base.unsafe_convert(Ptr{AVCodecParameters}, r)
+    fptr = getproperty(ptr, f)
+    GC.@preserve r unsafe_load(fptr)
+end
+
+function Base.setproperty!(x::Ptr{AVCodecParameters}, f::Symbol, v)
+    unsafe_store!(getproperty(x, f), v)
 end
 
 """
@@ -3301,6 +3357,8 @@ function avcodec_parameters_to_context(codec, par)
     ccall((:avcodec_parameters_to_context, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVCodecParameters}), codec, par)
 end
 
+mutable struct AVDictionary end
+
 """
     avcodec_open2(avctx, codec, options)
 
@@ -3308,13 +3366,11 @@ Initialize the [`AVCodecContext`](@ref) to use the given [`AVCodec`](@ref). Prio
 
 The functions [`avcodec_find_decoder_by_name`](@ref)(), [`avcodec_find_encoder_by_name`](@ref)(), [`avcodec_find_decoder`](@ref)() and [`avcodec_find_encoder`](@ref)() provide an easy way for retrieving a codec.
 
-!!! warning
-
-    This function is not thread safe!
+Depending on the codec, you might need to set options in the codec context also for decoding (e.g. width, height, or the pixel or audio sample format in the case the information is not available in the bitstream, as when decoding raw audio or video).
 
-!!! note
+Options in the codec context can be set either by setting them in the options [`AVDictionary`](@ref), or by setting the values in the context itself, directly or by using the [`av_opt_set`](@ref)() API before calling this function.
 
-    Always call this function before using decoding routines (such as avcodec_receive_frame()).
+Example:
 
 ```c++
  av_dict_set(&opts, "b", "2.5M", 0);
@@ -3326,18 +3382,29 @@ The functions [`avcodec_find_decoder_by_name`](@ref)(), [`avcodec_find_encoder_b
      exit(1);
 ```
 
-### Parameters
-* `avctx`: The context to initialize. 
+In the case [`AVCodecParameters`](@ref) are available (e.g. when demuxing a stream using libavformat, and accessing the [`AVStream`](@ref) contained in the demuxer), the codec parameters can be copied to the codec context using [`avcodec_parameters_to_context`](@ref)(), as in the following example:
+
+```c++
+ AVStream *stream = ...;
+ context = avcodec_alloc_context3(codec);
+ if (avcodec_parameters_to_context(context, stream->codecpar) < 0)
+     exit(1);
+ if (avcodec_open2(context, codec, NULL) < 0)
+     exit(1);
+```
 
-* `codec`: The codec to open this context for. If a non-NULL codec has been previously passed to [`avcodec_alloc_context3`](@ref)() or for this context, then this parameter MUST be either NULL or equal to the previously passed codec. 
+!!! note
 
-* `options`: A dictionary filled with [`AVCodecContext`](@ref) and codec-private options. On return this object will be filled with options that were not found.
+    Always call this function before using decoding routines (such as avcodec_receive_frame()).
 
+### Parameters
+* `avctx`: The context to initialize.
+* `codec`: The codec to open this context for. If a non-NULL codec has been previously passed to [`avcodec_alloc_context3`](@ref)() or for this context, then this parameter MUST be either NULL or equal to the previously passed codec.
+* `options`: A dictionary filled with [`AVCodecContext`](@ref) and codec-private options, which are set on top of the options already set in avctx, can be NULL. On return this object will be filled with options that were not found in the avctx codec context.
 ### Returns
-zero on success, a negative value on error 
-
+zero on success, a negative value on error
 ### See also
-[`avcodec_alloc_context3`](@ref)(), [`avcodec_find_decoder`](@ref)(), [`avcodec_find_encoder`](@ref)(), [`av_dict_set`](@ref)(), [`av_opt_find`](@ref)().
+[`avcodec_alloc_context3`](@ref)(), [`avcodec_find_decoder`](@ref)(), [`avcodec_find_encoder`](@ref)(), [`av_dict_set`](@ref)(), [`av_opt_set`](@ref)(), [`av_opt_find`](@ref)(), [`avcodec_parameters_to_context`](@ref)()
 """
 function avcodec_open2(avctx, codec, options)
     ccall((:avcodec_open2, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVCodec}, Ptr{Ptr{AVDictionary}}), avctx, codec, options)
@@ -3370,6 +3437,166 @@ function avsubtitle_free(sub)
     ccall((:avsubtitle_free, libavcodec), Cvoid, (Ptr{AVSubtitle},), sub)
 end
 
+"""
+    AVPictureType
+
+@} @}
+
+` lavu_picture Image related`
+
+AVPicture types, pixel formats and basic image planes manipulation.
+
+@{
+"""
+const AVPictureType = UInt32
+const AV_PICTURE_TYPE_NONE = 0 % UInt32
+const AV_PICTURE_TYPE_I = 1 % UInt32
+const AV_PICTURE_TYPE_P = 2 % UInt32
+const AV_PICTURE_TYPE_B = 3 % UInt32
+const AV_PICTURE_TYPE_S = 4 % UInt32
+const AV_PICTURE_TYPE_SI = 5 % UInt32
+const AV_PICTURE_TYPE_SP = 6 % UInt32
+const AV_PICTURE_TYPE_BI = 7 % UInt32
+
+"""
+    AVFrameSideDataType
+
+` lavu_frame AVFrame`
+
+` lavu_data`
+
+@{ [`AVFrame`](@ref) is an abstraction for reference-counted raw multimedia data.
+"""
+const AVFrameSideDataType = UInt32
+const AV_FRAME_DATA_PANSCAN = 0 % UInt32
+const AV_FRAME_DATA_A53_CC = 1 % UInt32
+const AV_FRAME_DATA_STEREO3D = 2 % UInt32
+const AV_FRAME_DATA_MATRIXENCODING = 3 % UInt32
+const AV_FRAME_DATA_DOWNMIX_INFO = 4 % UInt32
+const AV_FRAME_DATA_REPLAYGAIN = 5 % UInt32
+const AV_FRAME_DATA_DISPLAYMATRIX = 6 % UInt32
+const AV_FRAME_DATA_AFD = 7 % UInt32
+const AV_FRAME_DATA_MOTION_VECTORS = 8 % UInt32
+const AV_FRAME_DATA_SKIP_SAMPLES = 9 % UInt32
+const AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10 % UInt32
+const AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11 % UInt32
+const AV_FRAME_DATA_GOP_TIMECODE = 12 % UInt32
+const AV_FRAME_DATA_SPHERICAL = 13 % UInt32
+const AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = 14 % UInt32
+const AV_FRAME_DATA_ICC_PROFILE = 15 % UInt32
+const AV_FRAME_DATA_S12M_TIMECODE = 16 % UInt32
+const AV_FRAME_DATA_DYNAMIC_HDR_PLUS = 17 % UInt32
+const AV_FRAME_DATA_REGIONS_OF_INTEREST = 18 % UInt32
+const AV_FRAME_DATA_VIDEO_ENC_PARAMS = 19 % UInt32
+const AV_FRAME_DATA_SEI_UNREGISTERED = 20 % UInt32
+const AV_FRAME_DATA_FILM_GRAIN_PARAMS = 21 % UInt32
+const AV_FRAME_DATA_DETECTION_BBOXES = 22 % UInt32
+const AV_FRAME_DATA_DOVI_RPU_BUFFER = 23 % UInt32
+const AV_FRAME_DATA_DOVI_METADATA = 24 % UInt32
+const AV_FRAME_DATA_DYNAMIC_HDR_VIVID = 25 % UInt32
+const AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT = 26 % UInt32
+const AV_FRAME_DATA_VIDEO_HINT = 27 % UInt32
+
+"""
+    AVFrameSideData
+
+Structure to hold side data for an [`AVFrame`](@ref).
+
+sizeof([`AVFrameSideData`](@ref)) is not a part of the public ABI, so new fields may be added to the end with a minor bump.
+"""
+struct AVFrameSideData
+    type::AVFrameSideDataType
+    data::Ptr{UInt8}
+    size::Csize_t
+    metadata::Ptr{AVDictionary}
+    buf::Ptr{AVBufferRef}
+end
+
+"""
+    AVFrame
+
+This structure describes decoded (raw) audio or video data.
+
+[`AVFrame`](@ref) must be allocated using [`av_frame_alloc`](@ref)(). Note that this only allocates the [`AVFrame`](@ref) itself, the buffers for the data must be managed through other means (see below). [`AVFrame`](@ref) must be freed with [`av_frame_free`](@ref)().
+
+[`AVFrame`](@ref) is typically allocated once and then reused multiple times to hold different data (e.g. a single [`AVFrame`](@ref) to hold frames received from a decoder). In such a case, [`av_frame_unref`](@ref)() will free any references held by the frame and reset it to its original clean state before it is reused again.
+
+The data described by an [`AVFrame`](@ref) is usually reference counted through the [`AVBuffer`](@ref) API. The underlying buffer references are stored in [`AVFrame`](@ref).buf / [`AVFrame`](@ref).extended\\_buf. An [`AVFrame`](@ref) is considered to be reference counted if at least one reference is set, i.e. if [`AVFrame`](@ref).buf[0] != NULL. In such a case, every single data plane must be contained in one of the buffers in [`AVFrame`](@ref).buf or [`AVFrame`](@ref).extended\\_buf. There may be a single buffer for all the data, or one separate buffer for each plane, or anything in between.
+
+sizeof([`AVFrame`](@ref)) is not a part of the public ABI, so new fields may be added to the end with a minor bump.
+
+Fields can be accessed through AVOptions, the name string used, matches the C structure field name for fields accessible through AVOptions. The [`AVClass`](@ref) for [`AVFrame`](@ref) can be obtained from avcodec\\_get\\_frame\\_class()
+"""
+struct AVFrame
+    data::NTuple{480, UInt8}
+end
+
+function Base.getproperty(x::Ptr{AVFrame}, f::Symbol)
+    f === :data && return Ptr{NTuple{8, Ptr{UInt8}}}(x + 0)
+    f === :linesize && return Ptr{NTuple{8, Cint}}(x + 64)
+    f === :extended_data && return Ptr{Ptr{Ptr{UInt8}}}(x + 96)
+    f === :width && return Ptr{Cint}(x + 104)
+    f === :height && return Ptr{Cint}(x + 108)
+    f === :nb_samples && return Ptr{Cint}(x + 112)
+    f === :format && return Ptr{Cint}(x + 116)
+    f === :key_frame && return Ptr{Cint}(x + 120)
+    f === :pict_type && return Ptr{AVPictureType}(x + 124)
+    f === :sample_aspect_ratio && return Ptr{AVRational}(x + 128)
+    f === :pts && return Ptr{Int64}(x + 136)
+    f === :pkt_dts && return Ptr{Int64}(x + 144)
+    f === :time_base && return Ptr{AVRational}(x + 152)
+    f === :coded_picture_number && return Ptr{Cint}(x + 160)
+    f === :display_picture_number && return Ptr{Cint}(x + 164)
+    f === :quality && return Ptr{Cint}(x + 168)
+    f === :opaque && return Ptr{Ptr{Cvoid}}(x + 176)
+    f === :repeat_pict && return Ptr{Cint}(x + 184)
+    f === :interlaced_frame && return Ptr{Cint}(x + 188)
+    f === :top_field_first && return Ptr{Cint}(x + 192)
+    f === :palette_has_changed && return Ptr{Cint}(x + 196)
+    f === :reordered_opaque && return Ptr{Int64}(x + 200)
+    f === :sample_rate && return Ptr{Cint}(x + 208)
+    f === :channel_layout && return Ptr{UInt64}(x + 216)
+    f === :buf && return Ptr{NTuple{8, Ptr{AVBufferRef}}}(x + 224)
+    f === :extended_buf && return Ptr{Ptr{Ptr{AVBufferRef}}}(x + 288)
+    f === :nb_extended_buf && return Ptr{Cint}(x + 296)
+    f === :side_data && return Ptr{Ptr{Ptr{AVFrameSideData}}}(x + 304)
+    f === :nb_side_data && return Ptr{Cint}(x + 312)
+    f === :flags && return Ptr{Cint}(x + 316)
+    f === :color_range && return Ptr{AVColorRange}(x + 320)
+    f === :color_primaries && return Ptr{AVColorPrimaries}(x + 324)
+    f === :color_trc && return Ptr{AVColorTransferCharacteristic}(x + 328)
+    f === :colorspace && return Ptr{AVColorSpace}(x + 332)
+    f === :chroma_location && return Ptr{AVChromaLocation}(x + 336)
+    f === :best_effort_timestamp && return Ptr{Int64}(x + 344)
+    f === :pkt_pos && return Ptr{Int64}(x + 352)
+    f === :pkt_duration && return Ptr{Int64}(x + 360)
+    f === :metadata && return Ptr{Ptr{AVDictionary}}(x + 368)
+    f === :decode_error_flags && return Ptr{Cint}(x + 376)
+    f === :channels && return Ptr{Cint}(x + 380)
+    f === :pkt_size && return Ptr{Cint}(x + 384)
+    f === :hw_frames_ctx && return Ptr{Ptr{AVBufferRef}}(x + 392)
+    f === :opaque_ref && return Ptr{Ptr{AVBufferRef}}(x + 400)
+    f === :crop_top && return Ptr{Csize_t}(x + 408)
+    f === :crop_bottom && return Ptr{Csize_t}(x + 416)
+    f === :crop_left && return Ptr{Csize_t}(x + 424)
+    f === :crop_right && return Ptr{Csize_t}(x + 432)
+    f === :private_ref && return Ptr{Ptr{AVBufferRef}}(x + 440)
+    f === :ch_layout && return Ptr{AVChannelLayout}(x + 448)
+    f === :duration && return Ptr{Int64}(x + 472)
+    return getfield(x, f)
+end
+
+function Base.getproperty(x::AVFrame, f::Symbol)
+    r = Ref{AVFrame}(x)
+    ptr = Base.unsafe_convert(Ptr{AVFrame}, r)
+    fptr = getproperty(ptr, f)
+    GC.@preserve r unsafe_load(fptr)
+end
+
+function Base.setproperty!(x::Ptr{AVFrame}, f::Symbol, v)
+    unsafe_store!(getproperty(x, f), v)
+end
+
 """
     avcodec_default_get_buffer2(s, frame, flags::Integer)
 
@@ -3398,34 +3625,20 @@ sizeof([`AVPacket`](@ref)) being a part of the public ABI is deprecated. once [`
 [`av_packet_alloc`](@ref), [`av_packet_ref`](@ref), [`av_packet_unref`](@ref)
 """
 struct AVPacket
-    data::NTuple{88, UInt8}
-end
-
-function Base.getproperty(x::Ptr{AVPacket}, f::Symbol)
-    f === :buf && return Ptr{Ptr{AVBufferRef}}(x + 0)
-    f === :pts && return Ptr{Int64}(x + 8)
-    f === :dts && return Ptr{Int64}(x + 16)
-    f === :data && return Ptr{Ptr{UInt8}}(x + 24)
-    f === :size && return Ptr{Cint}(x + 32)
-    f === :stream_index && return Ptr{Cint}(x + 36)
-    f === :flags && return Ptr{Cint}(x + 40)
-    f === :side_data && return Ptr{Ptr{AVPacketSideData}}(x + 48)
-    f === :side_data_elems && return Ptr{Cint}(x + 56)
-    f === :duration && return Ptr{Int64}(x + 64)
-    f === :pos && return Ptr{Int64}(x + 72)
-    f === :convergence_duration && return Ptr{Int64}(x + 80)
-    return getfield(x, f)
-end
-
-function Base.getproperty(x::AVPacket, f::Symbol)
-    r = Ref{AVPacket}(x)
-    ptr = Base.unsafe_convert(Ptr{AVPacket}, r)
-    fptr = getproperty(ptr, f)
-    GC.@preserve r unsafe_load(fptr)
-end
-
-function Base.setproperty!(x::Ptr{AVPacket}, f::Symbol, v)
-    unsafe_store!(getproperty(x, f), v)
+    buf::Ptr{AVBufferRef}
+    pts::Int64
+    dts::Int64
+    data::Ptr{UInt8}
+    size::Cint
+    stream_index::Cint
+    flags::Cint
+    side_data::Ptr{AVPacketSideData}
+    side_data_elems::Cint
+    duration::Int64
+    pos::Int64
+    opaque::Ptr{Cvoid}
+    opaque_ref::Ptr{AVBufferRef}
+    time_base::AVRational
 end
 
 """
@@ -3454,115 +3667,43 @@ end
 Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you also ensure that all line sizes are a multiple of the respective linesize\\_align[i].
 
 May only be used if a codec with [`AV_CODEC_CAP_DR1`](@ref) has been opened.
-"""
-function avcodec_align_dimensions2(s, width, height, linesize_align)
-    ccall((:avcodec_align_dimensions2, libavcodec), Cvoid, (Ptr{AVCodecContext}, Ptr{Cint}, Ptr{Cint}, Ptr{Cint}), s, width, height, linesize_align)
-end
-
-"""
-    avcodec_enum_to_chroma_pos(xpos, ypos, pos::AVChromaLocation)
-
-Converts [`AVChromaLocation`](@ref) to swscale x/y chroma position.
-
-The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256
-
-### Parameters
-* `xpos`: horizontal chroma sample position 
-
-* `ypos`: vertical chroma sample position
-"""
-function avcodec_enum_to_chroma_pos(xpos, ypos, pos::AVChromaLocation)
-    ccall((:avcodec_enum_to_chroma_pos, libavcodec), Cint, (Ptr{Cint}, Ptr{Cint}, AVChromaLocation), xpos, ypos, pos)
-end
-
-"""
-    avcodec_chroma_pos_to_enum(xpos::Integer, ypos::Integer)
-
-Converts swscale x/y chroma position to [`AVChromaLocation`](@ref).
-
-The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256
-
-### Parameters
-* `xpos`: horizontal chroma sample position 
-
-* `ypos`: vertical chroma sample position
-"""
-function avcodec_chroma_pos_to_enum(xpos::Integer, ypos::Integer)
-    ccall((:avcodec_chroma_pos_to_enum, libavcodec), AVChromaLocation, (Cint, Cint), xpos, ypos)
-end
-
-"""
-    avcodec_decode_audio4(avctx, frame, got_frame_ptr, avpkt)
-
-Decode the audio frame of size avpkt->size from avpkt->data into frame.
-
-Some decoders may support multiple frames in a single [`AVPacket`](@ref). Such decoders would then just decode the first frame and the return value would be less than the packet size. In this case, [`avcodec_decode_audio4`](@ref) has to be called again with an [`AVPacket`](@ref) containing the remaining data in order to decode the second frame, etc... Even if no frames are returned, the packet needs to be fed to the decoder with remaining data until it is completely consumed or an error occurs.
-
-Some decoders (those marked with [`AV_CODEC_CAP_DELAY`](@ref)) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt->data set to NULL and avpkt->size set to 0 until it stops returning samples. It is safe to flush even those decoders that are not marked with [`AV_CODEC_CAP_DELAY`](@ref), then no samples will be returned.
-
-!!! warning
-
-    The input buffer, avpkt->data must be [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref) larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.
-
-!!! note
-
-    The [`AVCodecContext`](@ref) MUST have been opened with avcodec_open2() before packets may be fed to the decoder.
-
-\\deprecated Use [`avcodec_send_packet`](@ref)() and [`avcodec_receive_frame`](@ref)().
-
-### Parameters
-* `avctx`: the codec context 
-
-* `frame`:\\[out\\] The [`AVFrame`](@ref) in which to store decoded audio samples. The decoder will allocate a buffer for the decoded frame by calling the [`AVCodecContext`](@ref).get\\_buffer2() callback. When [`AVCodecContext`](@ref).refcounted\\_frames is set to 1, the frame is reference counted and the returned reference belongs to the caller. The caller must release the frame using [`av_frame_unref`](@ref)() when the frame is no longer needed. The caller may safely write to the frame if [`av_frame_is_writable`](@ref)() returns 1. When [`AVCodecContext`](@ref).refcounted\\_frames is set to 0, the returned reference belongs to the decoder and is valid only until the next call to this function or until closing or flushing the decoder. The caller may not write to it. 
-
-* `got_frame_ptr`:\\[out\\] Zero if no frame could be decoded, otherwise it is non-zero. Note that this field being set to zero does not mean that an error has occurred. For decoders with [`AV_CODEC_CAP_DELAY`](@ref) set, no given decode call is guaranteed to produce a frame. 
-
-* `avpkt`:\\[in\\] The input [`AVPacket`](@ref) containing the input buffer. At least avpkt->data and avpkt->size should be set. Some decoders might also require additional fields to be set. 
-
-### Returns
-A negative error code is returned if an error occurred during decoding, otherwise the number of bytes consumed from the input [`AVPacket`](@ref) is returned.
-"""
-function avcodec_decode_audio4(avctx, frame, got_frame_ptr, avpkt)
-    ccall((:avcodec_decode_audio4, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVFrame}, Ptr{Cint}, Ptr{AVPacket}), avctx, frame, got_frame_ptr, avpkt)
-end
-
-"""
-    avcodec_decode_video2(avctx, picture, got_picture_ptr, avpkt)
-
-Decode the video frame of size avpkt->size from avpkt->data into picture. Some decoders may support multiple frames in a single [`AVPacket`](@ref), such decoders would then just decode the first frame.
-
-!!! warning
-
-    The input buffer must be [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref) larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.
-
-!!! warning
-
-    The end of the input buffer buf should be set to 0 to ensure that no overreading happens for damaged MPEG streams.
-
-!!! note
+"""
+function avcodec_align_dimensions2(s, width, height, linesize_align)
+    ccall((:avcodec_align_dimensions2, libavcodec), Cvoid, (Ptr{AVCodecContext}, Ptr{Cint}, Ptr{Cint}, Ptr{Cint}), s, width, height, linesize_align)
+end
 
-    Codecs which have the [`AV_CODEC_CAP_DELAY`](@ref) capability set have a delay between input and output, these need to be fed with avpkt->data=NULL, avpkt->size=0 at the end to return the remaining frames.
+"""
+    avcodec_enum_to_chroma_pos(xpos, ypos, pos::AVChromaLocation)
 
-!!! note
+Converts [`AVChromaLocation`](@ref) to swscale x/y chroma position.
 
-    The [`AVCodecContext`](@ref) MUST have been opened with avcodec_open2() before packets may be fed to the decoder.
+The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256
 
-\\deprecated Use [`avcodec_send_packet`](@ref)() and [`avcodec_receive_frame`](@ref)().
+\\deprecated Use [`av_chroma_location_enum_to_pos`](@ref)() instead.
 
 ### Parameters
-* `avctx`: the codec context 
+* `xpos`: horizontal chroma sample position
+* `ypos`: vertical chroma sample position
+"""
+function avcodec_enum_to_chroma_pos(xpos, ypos, pos::AVChromaLocation)
+    ccall((:avcodec_enum_to_chroma_pos, libavcodec), Cint, (Ptr{Cint}, Ptr{Cint}, AVChromaLocation), xpos, ypos, pos)
+end
+
+"""
+    avcodec_chroma_pos_to_enum(xpos::Integer, ypos::Integer)
 
-* `picture`:\\[out\\] The [`AVFrame`](@ref) in which the decoded video frame will be stored. Use [`av_frame_alloc`](@ref)() to get an [`AVFrame`](@ref). The codec will allocate memory for the actual bitmap by calling the [`AVCodecContext`](@ref).get\\_buffer2() callback. When [`AVCodecContext`](@ref).refcounted\\_frames is set to 1, the frame is reference counted and the returned reference belongs to the caller. The caller must release the frame using [`av_frame_unref`](@ref)() when the frame is no longer needed. The caller may safely write to the frame if [`av_frame_is_writable`](@ref)() returns 1. When [`AVCodecContext`](@ref).refcounted\\_frames is set to 0, the returned reference belongs to the decoder and is valid only until the next call to this function or until closing or flushing the decoder. The caller may not write to it.
+Converts swscale x/y chroma position to [`AVChromaLocation`](@ref).
 
-* `avpkt`:\\[in\\] The input [`AVPacket`](@ref) containing the input buffer. You can create such packet with [`av_init_packet`](@ref)() and by then setting data and size, some decoders might in addition need other fields like flags&AV\\_PKT\\_FLAG\\_KEY. All decoders are designed to use the least fields possible. 
+The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256
 
-* `got_picture_ptr`:\\[in,out\\] Zero if no frame could be decompressed, otherwise, it is nonzero. 
+\\deprecated Use [`av_chroma_location_pos_to_enum`](@ref)() instead.
 
-### Returns
-On error a negative value is returned, otherwise the number of bytes used or zero if no frame could be decompressed.
+### Parameters
+* `xpos`: horizontal chroma sample position
+* `ypos`: vertical chroma sample position
 """
-function avcodec_decode_video2(avctx, picture, got_picture_ptr, avpkt)
-    ccall((:avcodec_decode_video2, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVFrame}, Ptr{Cint}, Ptr{AVPacket}), avctx, picture, got_picture_ptr, avpkt)
+function avcodec_chroma_pos_to_enum(xpos::Integer, ypos::Integer)
+    ccall((:avcodec_chroma_pos_to_enum, libavcodec), AVChromaLocation, (Cint, Cint), xpos, ypos)
 end
 
 """
@@ -3577,12 +3718,9 @@ Some decoders (those marked with [`AV_CODEC_CAP_DELAY`](@ref)) have a delay betw
     The [`AVCodecContext`](@ref) MUST have been opened with avcodec_open2() before packets may be fed to the decoder.
 
 ### Parameters
-* `avctx`: the codec context 
-
-* `sub`:\\[out\\] The preallocated [`AVSubtitle`](@ref) in which the decoded subtitle will be stored, must be freed with [`avsubtitle_free`](@ref) if *got\\_sub\\_ptr is set. 
-
-* `got_sub_ptr`:\\[in,out\\] Zero if no subtitle could be decompressed, otherwise, it is nonzero. 
-
+* `avctx`: the codec context
+* `sub`:\\[out\\] The preallocated [`AVSubtitle`](@ref) in which the decoded subtitle will be stored, must be freed with [`avsubtitle_free`](@ref) if *got\\_sub\\_ptr is set.
+* `got_sub_ptr`:\\[in,out\\] Zero if no subtitle could be decompressed, otherwise, it is nonzero.
 * `avpkt`:\\[in\\] The input [`AVPacket`](@ref) containing the input buffer.
 """
 function avcodec_decode_subtitle2(avctx, sub, got_sub_ptr, avpkt)
@@ -3600,21 +3738,25 @@ Internally, this call will copy relevant [`AVCodecContext`](@ref) fields, which
 
     The input buffer, avpkt->data must be [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref) larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.
 
-!!! warning
-
-    Do not mix this API with the legacy API (like [`avcodec_decode_video2`](@ref)()) on the same [`AVCodecContext`](@ref). It will return unexpected results now or in future libavcodec versions.
-
 !!! note
 
     The [`AVCodecContext`](@ref) MUST have been opened with avcodec_open2() before packets may be fed to the decoder.
 
-### Parameters
-* `avctx`: codec context 
+\\retval0 success
 
-* `avpkt`:\\[in\\] The input [`AVPacket`](@ref). Usually, this will be a single video frame, or several complete audio frames. Ownership of the packet remains with the caller, and the decoder will not write to the packet. The decoder may create a reference to the packet data (or copy it if the packet is not reference-counted). Unlike with older APIs, the packet is always fully consumed, and if it contains multiple frames (e.g. some audio codecs), will require you to call [`avcodec_receive_frame`](@ref)() multiple times afterwards before you can send a new packet. It can be NULL (or an [`AVPacket`](@ref) with data set to NULL and size set to 0); in this case, it is considered a flush packet, which signals the end of the stream. Sending the first flush packet will return success. Subsequent ones are unnecessary and will return [`AVERROR_EOF`](@ref). If the decoder still has frames buffered, it will return them after sending a flush packet.
+\\retvalAVERROR(EAGAIN) input is not accepted in the current state - user must read output with [`avcodec_receive_frame`](@ref)() (once all output is read, the packet should be resent, and the call will not fail with EAGAIN).
 
-### Returns
-0 on success, otherwise negative error code: [`AVERROR`](@ref)(EAGAIN): input is not accepted in the current state - user must read output with [`avcodec_receive_frame`](@ref)() (once all output is read, the packet should be resent, and the call will not fail with EAGAIN). [`AVERROR_EOF`](@ref): the decoder has been flushed, and no new packets can be sent to it (also returned if more than 1 flush packet is sent) [`AVERROR`](@ref)(EINVAL): codec not opened, it is an encoder, or requires flush [`AVERROR`](@ref)(ENOMEM): failed to add packet to internal queue, or similar other errors: legitimate decoding errors
+\\retvalAVERROR_EOF the decoder has been flushed, and no new packets can be sent to it (also returned if more than 1 flush packet is sent)
+
+\\retvalAVERROR(EINVAL) codec not opened, it is an encoder, or requires flush
+
+\\retvalAVERROR(ENOMEM) failed to add packet to internal queue, or similar
+
+\\retval"another negative error code" legitimate decoding errors
+
+### Parameters
+* `avctx`: codec context
+* `avpkt`:\\[in\\] The input [`AVPacket`](@ref). Usually, this will be a single video frame, or several complete audio frames. Ownership of the packet remains with the caller, and the decoder will not write to the packet. The decoder may create a reference to the packet data (or copy it if the packet is not reference-counted). Unlike with older APIs, the packet is always fully consumed, and if it contains multiple frames (e.g. some audio codecs), will require you to call [`avcodec_receive_frame`](@ref)() multiple times afterwards before you can send a new packet. It can be NULL (or an [`AVPacket`](@ref) with data set to NULL and size set to 0); in this case, it is considered a flush packet, which signals the end of the stream. Sending the first flush packet will return success. Subsequent ones are unnecessary and will return [`AVERROR_EOF`](@ref). If the decoder still has frames buffered, it will return them after sending a flush packet.
 """
 function avcodec_send_packet(avctx, avpkt)
     ccall((:avcodec_send_packet, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVPacket}), avctx, avpkt)
@@ -3623,15 +3765,21 @@ end
 """
     avcodec_receive_frame(avctx, frame)
 
-Return decoded output data from a decoder.
+Return decoded output data from a decoder or encoder (when the AV_CODEC_FLAG_RECON_FRAME flag is used).
 
-### Parameters
-* `avctx`: codec context 
+\\retval0 success, a frame was returned
 
-* `frame`: This will be set to a reference-counted video or audio frame (depending on the decoder type) allocated by the decoder. Note that the function will always call [`av_frame_unref`](@ref)(frame) before doing anything else.
+\\retvalAVERROR(EAGAIN) output is not available in this state - user must try to send new input
 
-### Returns
-0: success, a frame was returned [`AVERROR`](@ref)(EAGAIN): output is not available in this state - user must try to send new input [`AVERROR_EOF`](@ref): the decoder has been fully flushed, and there will be no more output frames [`AVERROR`](@ref)(EINVAL): codec not opened, or it is an encoder [`AVERROR_INPUT_CHANGED`](@ref): current decoded frame has changed parameters with respect to first decoded frame. Applicable when flag [`AV_CODEC_FLAG_DROPCHANGED`](@ref) is set. other negative values: legitimate decoding errors
+\\retvalAVERROR_EOF the codec has been fully flushed, and there will be no more output frames
+
+\\retvalAVERROR(EINVAL) codec not opened, or it is an encoder without the AV_CODEC_FLAG_RECON_FRAME flag enabled
+
+\\retval"other negative error code" legitimate decoding errors
+
+### Parameters
+* `avctx`: codec context
+* `frame`: This will be set to a reference-counted video or audio frame (depending on the decoder type) allocated by the codec. Note that the function will always call [`av_frame_unref`](@ref)(frame) before doing anything else.
 """
 function avcodec_receive_frame(avctx, frame)
     ccall((:avcodec_receive_frame, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVFrame}), avctx, frame)
@@ -3642,15 +3790,23 @@ end
 
 Supply a raw video or audio frame to the encoder. Use [`avcodec_receive_packet`](@ref)() to retrieve buffered output packets.
 
-For audio: If [`AV_CODEC_CAP_VARIABLE_FRAME_SIZE`](@ref) is set, then each frame can have any number of samples. If it is not set, frame->nb\\_samples must be equal to avctx->frame\\_size for all frames except the last. The final frame may be smaller than avctx->frame\\_size. 
+For audio: If [`AV_CODEC_CAP_VARIABLE_FRAME_SIZE`](@ref) is set, then each frame can have any number of samples. If it is not set, frame->nb\\_samples must be equal to avctx->frame\\_size for all frames except the last. The final frame may be smaller than avctx->frame\\_size.
 
-### Parameters
-* `avctx`: codec context 
+\\retval0 success
 
-* `frame`:\\[in\\] [`AVFrame`](@ref) containing the raw audio or video frame to be encoded. Ownership of the frame remains with the caller, and the encoder will not write to the frame. The encoder may create a reference to the frame data (or copy it if the frame is not reference-counted). It can be NULL, in which case it is considered a flush packet. This signals the end of the stream. If the encoder still has packets buffered, it will return them after this call. Once flushing mode has been entered, additional flush packets are ignored, and sending frames will return [`AVERROR_EOF`](@ref).
+\\retvalAVERROR(EAGAIN) input is not accepted in the current state - user must read output with [`avcodec_receive_packet`](@ref)() (once all output is read, the packet should be resent, and the call will not fail with EAGAIN).
 
-### Returns
-0 on success, otherwise negative error code: [`AVERROR`](@ref)(EAGAIN): input is not accepted in the current state - user must read output with [`avcodec_receive_packet`](@ref)() (once all output is read, the packet should be resent, and the call will not fail with EAGAIN). [`AVERROR_EOF`](@ref): the encoder has been flushed, and no new frames can be sent to it [`AVERROR`](@ref)(EINVAL): codec not opened, refcounted\\_frames not set, it is a decoder, or requires flush [`AVERROR`](@ref)(ENOMEM): failed to add packet to internal queue, or similar other errors: legitimate encoding errors
+\\retvalAVERROR_EOF the encoder has been flushed, and no new frames can be sent to it
+
+\\retvalAVERROR(EINVAL) codec not opened, it is a decoder, or requires flush
+
+\\retvalAVERROR(ENOMEM) failed to add packet to internal queue, or similar
+
+\\retval"another negative error code" legitimate encoding errors
+
+### Parameters
+* `avctx`: codec context
+* `frame`:\\[in\\] [`AVFrame`](@ref) containing the raw audio or video frame to be encoded. Ownership of the frame remains with the caller, and the encoder will not write to the frame. The encoder may create a reference to the frame data (or copy it if the frame is not reference-counted). It can be NULL, in which case it is considered a flush packet. This signals the end of the stream. If the encoder still has packets buffered, it will return them after this call. Once flushing mode has been entered, additional flush packets are ignored, and sending frames will return [`AVERROR_EOF`](@ref).
 """
 function avcodec_send_frame(avctx, frame)
     ccall((:avcodec_send_frame, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVFrame}), avctx, frame)
@@ -3661,13 +3817,19 @@ end
 
 Read encoded data from the encoder.
 
-### Parameters
-* `avctx`: codec context 
+\\retval0 success
 
-* `avpkt`: This will be set to a reference-counted packet allocated by the encoder. Note that the function will always call [`av_packet_unref`](@ref)(avpkt) before doing anything else. 
+\\retvalAVERROR(EAGAIN) output is not available in the current state - user must try to send input
 
-### Returns
-0 on success, otherwise negative error code: [`AVERROR`](@ref)(EAGAIN): output is not available in the current state - user must try to send input [`AVERROR_EOF`](@ref): the encoder has been fully flushed, and there will be no more output packets [`AVERROR`](@ref)(EINVAL): codec not opened, or it is a decoder other errors: legitimate encoding errors
+\\retvalAVERROR_EOF the encoder has been fully flushed, and there will be no more output packets
+
+\\retvalAVERROR(EINVAL) codec not opened, or it is a decoder
+
+\\retval"another negative error code" legitimate encoding errors
+
+### Parameters
+* `avctx`: codec context
+* `avpkt`: This will be set to a reference-counted packet allocated by the encoder. Note that the function will always call [`av_packet_unref`](@ref)(avpkt) before doing anything else.
 """
 function avcodec_receive_packet(avctx, avpkt)
     ccall((:avcodec_receive_packet, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVPacket}), avctx, avpkt)
@@ -3697,14 +3859,10 @@ Essentially, out\\_frames\\_ref returns the same as [`av_hwframe_ctx_alloc`](@re
 The function is stateless, and does not change the [`AVCodecContext`](@ref) or the device\\_ref [`AVHWDeviceContext`](@ref).
 
 ### Parameters
-* `avctx`: The context which is currently calling get\\_format, and which implicitly contains all state needed for filling the returned [`AVHWFramesContext`](@ref) properly. 
-
-* `device_ref`: A reference to the [`AVHWDeviceContext`](@ref) describing the device which will be used by the hardware decoder. 
-
-* `hw_pix_fmt`: The hwaccel format you are going to return from get\\_format. 
-
-* `out_frames_ref`: On success, set to a reference to an \\_uninitialized\\_ [`AVHWFramesContext`](@ref), created from the given device\\_ref. Fields will be set to values required for decoding. Not changed if an error is returned. 
-
+* `avctx`: The context which is currently calling get\\_format, and which implicitly contains all state needed for filling the returned [`AVHWFramesContext`](@ref) properly.
+* `device_ref`: A reference to the [`AVHWDeviceContext`](@ref) describing the device which will be used by the hardware decoder.
+* `hw_pix_fmt`: The hwaccel format you are going to return from get\\_format.
+* `out_frames_ref`: On success, set to a reference to an \\_uninitialized\\_ [`AVHWFramesContext`](@ref), created from the given device\\_ref. Fields will be set to values required for decoding. Not changed if an error is returned.
 ### Returns
 zero on success, a negative value on error. The following error codes have special semantics: [`AVERROR`](@ref)(ENOENT): the decoder does not support this functionality. Setup is always manual, or it is a decoder which does not support setting [`AVCodecContext`](@ref).hw\\_frames\\_ctx at all, or it is a software format. [`AVERROR`](@ref)(EINVAL): it is known that hardware decoding is not supported for this configuration, or the device\\_ref is not supported for the hwaccel referenced by hw\\_pix\\_fmt.
 """
@@ -3725,85 +3883,51 @@ const AV_PICTURE_STRUCTURE_TOP_FIELD = 1 % UInt32
 const AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2 % UInt32
 const AV_PICTURE_STRUCTURE_FRAME = 3 % UInt32
 
-struct AVCodecParserContext
-    data::NTuple{352, UInt8}
-end
-
-function Base.getproperty(x::Ptr{AVCodecParserContext}, f::Symbol)
-    f === :priv_data && return Ptr{Ptr{Cvoid}}(x + 0)
-    f === :parser && return Ptr{Ptr{AVCodecParser}}(x + 8)
-    f === :frame_offset && return Ptr{Int64}(x + 16)
-    f === :cur_offset && return Ptr{Int64}(x + 24)
-    f === :next_frame_offset && return Ptr{Int64}(x + 32)
-    f === :pict_type && return Ptr{Cint}(x + 40)
-    f === :repeat_pict && return Ptr{Cint}(x + 44)
-    f === :pts && return Ptr{Int64}(x + 48)
-    f === :dts && return Ptr{Int64}(x + 56)
-    f === :last_pts && return Ptr{Int64}(x + 64)
-    f === :last_dts && return Ptr{Int64}(x + 72)
-    f === :fetch_timestamp && return Ptr{Cint}(x + 80)
-    f === :cur_frame_start_index && return Ptr{Cint}(x + 84)
-    f === :cur_frame_offset && return Ptr{NTuple{4, Int64}}(x + 88)
-    f === :cur_frame_pts && return Ptr{NTuple{4, Int64}}(x + 120)
-    f === :cur_frame_dts && return Ptr{NTuple{4, Int64}}(x + 152)
-    f === :flags && return Ptr{Cint}(x + 184)
-    f === :offset && return Ptr{Int64}(x + 192)
-    f === :cur_frame_end && return Ptr{NTuple{4, Int64}}(x + 200)
-    f === :key_frame && return Ptr{Cint}(x + 232)
-    f === :convergence_duration && return Ptr{Int64}(x + 240)
-    f === :dts_sync_point && return Ptr{Cint}(x + 248)
-    f === :dts_ref_dts_delta && return Ptr{Cint}(x + 252)
-    f === :pts_dts_delta && return Ptr{Cint}(x + 256)
-    f === :cur_frame_pos && return Ptr{NTuple{4, Int64}}(x + 264)
-    f === :pos && return Ptr{Int64}(x + 296)
-    f === :last_pos && return Ptr{Int64}(x + 304)
-    f === :duration && return Ptr{Cint}(x + 312)
-    f === :field_order && return Ptr{AVFieldOrder}(x + 316)
-    f === :picture_structure && return Ptr{AVPictureStructure}(x + 320)
-    f === :output_picture_number && return Ptr{Cint}(x + 324)
-    f === :width && return Ptr{Cint}(x + 328)
-    f === :height && return Ptr{Cint}(x + 332)
-    f === :coded_width && return Ptr{Cint}(x + 336)
-    f === :coded_height && return Ptr{Cint}(x + 340)
-    f === :format && return Ptr{Cint}(x + 344)
-    return getfield(x, f)
-end
-
-function Base.getproperty(x::AVCodecParserContext, f::Symbol)
-    r = Ref{AVCodecParserContext}(x)
-    ptr = Base.unsafe_convert(Ptr{AVCodecParserContext}, r)
-    fptr = getproperty(ptr, f)
-    GC.@preserve r unsafe_load(fptr)
-end
-
-function Base.setproperty!(x::Ptr{AVCodecParserContext}, f::Symbol, v)
-    unsafe_store!(getproperty(x, f), v)
-end
-
 struct AVCodecParser
-    data::NTuple{64, UInt8}
-end
-
-function Base.getproperty(x::Ptr{AVCodecParser}, f::Symbol)
-    f === :codec_ids && return Ptr{NTuple{5, Cint}}(x + 0)
-    f === :priv_data_size && return Ptr{Cint}(x + 20)
-    f === :parser_init && return Ptr{Ptr{Cvoid}}(x + 24)
-    f === :parser_parse && return Ptr{Ptr{Cvoid}}(x + 32)
-    f === :parser_close && return Ptr{Ptr{Cvoid}}(x + 40)
-    f === :split && return Ptr{Ptr{Cvoid}}(x + 48)
-    f === :next && return Ptr{Ptr{AVCodecParser}}(x + 56)
-    return getfield(x, f)
-end
-
-function Base.getproperty(x::AVCodecParser, f::Symbol)
-    r = Ref{AVCodecParser}(x)
-    ptr = Base.unsafe_convert(Ptr{AVCodecParser}, r)
-    fptr = getproperty(ptr, f)
-    GC.@preserve r unsafe_load(fptr)
+    codec_ids::NTuple{7, Cint}
+    priv_data_size::Cint
+    parser_init::Ptr{Cvoid}
+    parser_parse::Ptr{Cvoid}
+    parser_close::Ptr{Cvoid}
+    split::Ptr{Cvoid}
 end
 
-function Base.setproperty!(x::Ptr{AVCodecParser}, f::Symbol, v)
-    unsafe_store!(getproperty(x, f), v)
+struct AVCodecParserContext
+    priv_data::Ptr{Cvoid}
+    parser::Ptr{AVCodecParser}
+    frame_offset::Int64
+    cur_offset::Int64
+    next_frame_offset::Int64
+    pict_type::Cint
+    repeat_pict::Cint
+    pts::Int64
+    dts::Int64
+    last_pts::Int64
+    last_dts::Int64
+    fetch_timestamp::Cint
+    cur_frame_start_index::Cint
+    cur_frame_offset::NTuple{4, Int64}
+    cur_frame_pts::NTuple{4, Int64}
+    cur_frame_dts::NTuple{4, Int64}
+    flags::Cint
+    offset::Int64
+    cur_frame_end::NTuple{4, Int64}
+    key_frame::Cint
+    dts_sync_point::Cint
+    dts_ref_dts_delta::Cint
+    pts_dts_delta::Cint
+    cur_frame_pos::NTuple{4, Int64}
+    pos::Int64
+    last_pos::Int64
+    duration::Cint
+    field_order::AVFieldOrder
+    picture_structure::AVPictureStructure
+    output_picture_number::Cint
+    width::Cint
+    height::Cint
+    coded_width::Cint
+    coded_height::Cint
+    format::Cint
 end
 
 """
@@ -3813,7 +3937,6 @@ Iterate over all registered codec parsers.
 
 ### Parameters
 * `opaque`: a pointer where libavcodec will store the iteration state. Must point to NULL to start the iteration.
-
 ### Returns
 the next registered codec parser or NULL when the iteration is finished
 """
@@ -3821,14 +3944,6 @@ function av_parser_iterate(opaque)
     ccall((:av_parser_iterate, libavcodec), Ptr{AVCodecParser}, (Ptr{Ptr{Cvoid}},), opaque)
 end
 
-function av_parser_next(c)
-    ccall((:av_parser_next, libavcodec), Ptr{AVCodecParser}, (Ptr{AVCodecParser},), c)
-end
-
-function av_register_codec_parser(parser)
-    ccall((:av_register_codec_parser, libavcodec), Cvoid, (Ptr{AVCodecParser},), parser)
-end
-
 function av_parser_init(codec_id::Integer)
     ccall((:av_parser_init, libavcodec), Ptr{AVCodecParserContext}, (Cint,), codec_id)
 end
@@ -3838,7 +3953,7 @@ end
 
 Parse a packet.
 
-Example: 
+Example:
 
 ```c++
    while(in_len){
@@ -3853,24 +3968,15 @@ Example:
 ```
 
 ### Parameters
-* `s`: parser context. 
-
-* `avctx`: codec context. 
-
-* `poutbuf`: set to pointer to parsed buffer or NULL if not yet finished. 
-
-* `poutbuf_size`: set to size of parsed buffer or zero if not yet finished. 
-
-* `buf`: input buffer. 
-
-* `buf_size`: buffer size in bytes without the padding. I.e. the full buffer size is assumed to be buf\\_size + [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref). To signal EOF, this should be 0 (so that the last frame can be output). 
-
-* `pts`: input presentation timestamp. 
-
-* `dts`: input decoding timestamp. 
-
-* `pos`: input byte position in stream. 
-
+* `s`: parser context.
+* `avctx`: codec context.
+* `poutbuf`: set to pointer to parsed buffer or NULL if not yet finished.
+* `poutbuf_size`: set to size of parsed buffer or zero if not yet finished.
+* `buf`: input buffer.
+* `buf_size`: buffer size in bytes without the padding. I.e. the full buffer size is assumed to be buf\\_size + [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref). To signal EOF, this should be 0 (so that the last frame can be output).
+* `pts`: input presentation timestamp.
+* `dts`: input decoding timestamp.
+* `pos`: input byte position in stream.
 ### Returns
 the number of bytes of the input bitstream used.
 """
@@ -3878,161 +3984,21 @@ function av_parser_parse2(s, avctx, poutbuf, poutbuf_size, buf, buf_size::Intege
     ccall((:av_parser_parse2, libavcodec), Cint, (Ptr{AVCodecParserContext}, Ptr{AVCodecContext}, Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{UInt8}, Cint, Int64, Int64, Int64), s, avctx, poutbuf, poutbuf_size, buf, buf_size, pts, dts, pos)
 end
 
-"""
-    av_parser_change(s, avctx, poutbuf, poutbuf_size, buf, buf_size::Integer, keyframe::Integer)
-
-\\deprecated Use dump\\_extradata, remove\\_extra or extract\\_extradata bitstream filters instead.
-
-### Returns
-0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed 
-"""
-function av_parser_change(s, avctx, poutbuf, poutbuf_size, buf, buf_size::Integer, keyframe::Integer)
-    ccall((:av_parser_change, libavcodec), Cint, (Ptr{AVCodecParserContext}, Ptr{AVCodecContext}, Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{UInt8}, Cint, Cint), s, avctx, poutbuf, poutbuf_size, buf, buf_size, keyframe)
-end
-
 function av_parser_close(s)
     ccall((:av_parser_close, libavcodec), Cvoid, (Ptr{AVCodecParserContext},), s)
 end
 
 """
-    avcodec_encode_audio2(avctx, avpkt, frame, got_packet_ptr)
-
-Encode a frame of audio.
-
-Takes input samples from frame and writes the next output packet, if available, to avpkt. The output packet does not necessarily contain data for the most recent frame, as encoders can delay, split, and combine input frames internally as needed.
-
-If this function fails or produces no output, avpkt will be freed using [`av_packet_unref`](@ref)(). 
-
-\\deprecated use [`avcodec_send_frame`](@ref)()/[`avcodec_receive_packet`](@ref)() instead. If allowed and required, set [`AVCodecContext`](@ref).get\\_encode\\_buffer to a custom function to pass user supplied output buffers.
-
-### Parameters
-* `avctx`: codec context 
-
-* `avpkt`: output [`AVPacket`](@ref). The user can supply an output buffer by setting avpkt->data and avpkt->size prior to calling the function, but if the size of the user-provided data is not large enough, encoding will fail. If avpkt->data and avpkt->size are set, avpkt->destruct must also be set. All other [`AVPacket`](@ref) fields will be reset by the encoder using [`av_init_packet`](@ref)(). If avpkt->data is NULL, the encoder will allocate it. The encoder will set avpkt->size to the size of the output packet.
-
-* `frame`:\\[in\\] [`AVFrame`](@ref) containing the raw audio data to be encoded. May be NULL when flushing an encoder that has the [`AV_CODEC_CAP_DELAY`](@ref) capability set. If [`AV_CODEC_CAP_VARIABLE_FRAME_SIZE`](@ref) is set, then each frame can have any number of samples. If it is not set, frame->nb\\_samples must be equal to avctx->frame\\_size for all frames except the last. The final frame may be smaller than avctx->frame\\_size. 
-
-* `got_packet_ptr`:\\[out\\] This field is set to 1 by libavcodec if the output packet is non-empty, and to 0 if it is empty. If the function returns an error, the packet can be assumed to be invalid, and the value of got\\_packet\\_ptr is undefined and should not be used. 
-
-### Returns
-0 on success, negative error code on failure
-"""
-function avcodec_encode_audio2(avctx, avpkt, frame, got_packet_ptr)
-    ccall((:avcodec_encode_audio2, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVPacket}, Ptr{AVFrame}, Ptr{Cint}), avctx, avpkt, frame, got_packet_ptr)
-end
-
-"""
-    avcodec_encode_video2(avctx, avpkt, frame, got_packet_ptr)
-
-Encode a frame of video.
-
-Takes input raw video data from frame and writes the next output packet, if available, to avpkt. The output packet does not necessarily contain data for the most recent frame, as encoders can delay and reorder input frames internally as needed.
-
-If this function fails or produces no output, avpkt will be freed using [`av_packet_unref`](@ref)(). 
-
-\\deprecated use [`avcodec_send_frame`](@ref)()/[`avcodec_receive_packet`](@ref)() instead. If allowed and required, set [`AVCodecContext`](@ref).get\\_encode\\_buffer to a custom function to pass user supplied output buffers.
-
-### Parameters
-* `avctx`: codec context 
-
-* `avpkt`: output [`AVPacket`](@ref). The user can supply an output buffer by setting avpkt->data and avpkt->size prior to calling the function, but if the size of the user-provided data is not large enough, encoding will fail. All other [`AVPacket`](@ref) fields will be reset by the encoder using [`av_init_packet`](@ref)(). If avpkt->data is NULL, the encoder will allocate it. The encoder will set avpkt->size to the size of the output packet. The returned data (if any) belongs to the caller, he is responsible for freeing it.
-
-* `frame`:\\[in\\] [`AVFrame`](@ref) containing the raw video data to be encoded. May be NULL when flushing an encoder that has the [`AV_CODEC_CAP_DELAY`](@ref) capability set. 
+    avcodec_encode_subtitle(avctx, buf, buf_size::Integer, sub)
 
-* `got_packet_ptr`:\\[out\\] This field is set to 1 by libavcodec if the output packet is non-empty, and to 0 if it is empty. If the function returns an error, the packet can be assumed to be invalid, and the value of got\\_packet\\_ptr is undefined and should not be used. 
+` lavc_encoding`
 
-### Returns
-0 on success, negative error code on failure
+@{
 """
-function avcodec_encode_video2(avctx, avpkt, frame, got_packet_ptr)
-    ccall((:avcodec_encode_video2, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVPacket}, Ptr{AVFrame}, Ptr{Cint}), avctx, avpkt, frame, got_packet_ptr)
-end
-
 function avcodec_encode_subtitle(avctx, buf, buf_size::Integer, sub)
     ccall((:avcodec_encode_subtitle, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{UInt8}, Cint, Ptr{AVSubtitle}), avctx, buf, buf_size, sub)
 end
 
-"""
-    avpicture_alloc(picture, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
-
-\\deprecated unused
-"""
-function avpicture_alloc(picture, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
-    ccall((:avpicture_alloc, libavcodec), Cint, (Ptr{AVPicture}, AVPixelFormat, Cint, Cint), picture, pix_fmt, width, height)
-end
-
-"""
-    avpicture_free(picture)
-
-\\deprecated unused
-"""
-function avpicture_free(picture)
-    ccall((:avpicture_free, libavcodec), Cvoid, (Ptr{AVPicture},), picture)
-end
-
-"""
-    avpicture_fill(picture, ptr, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
-
-\\deprecated use [`av_image_fill_arrays`](@ref)() instead.
-"""
-function avpicture_fill(picture, ptr, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
-    ccall((:avpicture_fill, libavcodec), Cint, (Ptr{AVPicture}, Ptr{UInt8}, AVPixelFormat, Cint, Cint), picture, ptr, pix_fmt, width, height)
-end
-
-"""
-    avpicture_layout(src, pix_fmt::AVPixelFormat, width::Integer, height::Integer, dest, dest_size::Integer)
-
-\\deprecated use [`av_image_copy_to_buffer`](@ref)() instead.
-"""
-function avpicture_layout(src, pix_fmt::AVPixelFormat, width::Integer, height::Integer, dest, dest_size::Integer)
-    ccall((:avpicture_layout, libavcodec), Cint, (Ptr{AVPicture}, AVPixelFormat, Cint, Cint, Ptr{Cuchar}, Cint), src, pix_fmt, width, height, dest, dest_size)
-end
-
-"""
-    avpicture_get_size(pix_fmt::AVPixelFormat, width::Integer, height::Integer)
-
-\\deprecated use [`av_image_get_buffer_size`](@ref)() instead.
-"""
-function avpicture_get_size(pix_fmt::AVPixelFormat, width::Integer, height::Integer)
-    ccall((:avpicture_get_size, libavcodec), Cint, (AVPixelFormat, Cint, Cint), pix_fmt, width, height)
-end
-
-"""
-    av_picture_copy(dst, src, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
-
-\\deprecated [`av_image_copy`](@ref)() instead.
-"""
-function av_picture_copy(dst, src, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
-    ccall((:av_picture_copy, libavcodec), Cvoid, (Ptr{AVPicture}, Ptr{AVPicture}, AVPixelFormat, Cint, Cint), dst, src, pix_fmt, width, height)
-end
-
-"""
-    av_picture_crop(dst, src, pix_fmt::AVPixelFormat, top_band::Integer, left_band::Integer)
-
-\\deprecated unused
-"""
-function av_picture_crop(dst, src, pix_fmt::AVPixelFormat, top_band::Integer, left_band::Integer)
-    ccall((:av_picture_crop, libavcodec), Cint, (Ptr{AVPicture}, Ptr{AVPicture}, AVPixelFormat, Cint, Cint), dst, src, pix_fmt, top_band, left_band)
-end
-
-"""
-    av_picture_pad(dst, src, height::Integer, width::Integer, pix_fmt::AVPixelFormat, padtop::Integer, padbottom::Integer, padleft::Integer, padright::Integer, color)
-
-\\deprecated unused
-"""
-function av_picture_pad(dst, src, height::Integer, width::Integer, pix_fmt::AVPixelFormat, padtop::Integer, padbottom::Integer, padleft::Integer, padright::Integer, color)
-    ccall((:av_picture_pad, libavcodec), Cint, (Ptr{AVPicture}, Ptr{AVPicture}, Cint, Cint, AVPixelFormat, Cint, Cint, Cint, Cint, Ptr{Cint}), dst, src, height, width, pix_fmt, padtop, padbottom, padleft, padright, color)
-end
-
-"""
-    avcodec_get_chroma_sub_sample(pix_fmt::AVPixelFormat, h_shift, v_shift)
-
-\\deprecated Use [`av_pix_fmt_get_chroma_sub_sample`](@ref)
-"""
-function avcodec_get_chroma_sub_sample(pix_fmt::AVPixelFormat, h_shift, v_shift)
-    ccall((:avcodec_get_chroma_sub_sample, libavcodec), Cvoid, (AVPixelFormat, Ptr{Cint}, Ptr{Cint}), pix_fmt, h_shift, v_shift)
-end
-
 """
     avcodec_pix_fmt_to_codec_tag(pix_fmt::AVPixelFormat)
 
@@ -4045,17 +4011,13 @@ end
 """
     avcodec_find_best_pix_fmt_of_list(pix_fmt_list, src_pix_fmt::AVPixelFormat, has_alpha::Integer, loss_ptr)
 
-Find the best pixel format to convert to given a certain source pixel format. When converting from one pixel format to another, information loss may occur. For example, when converting from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when converting from some formats to other formats. [`avcodec_find_best_pix_fmt_of_2`](@ref)() searches which of the given pixel formats should be used to suffer the least amount of loss. The pixel formats from which it chooses one, are determined by the pix\\_fmt\\_list parameter.
+Find the best pixel format to convert to given a certain source pixel format. When converting from one pixel format to another, information loss may occur. For example, when converting from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when converting from some formats to other formats. avcodec\\_find\\_best\\_pix\\_fmt\\_of\\_2() searches which of the given pixel formats should be used to suffer the least amount of loss. The pixel formats from which it chooses one, are determined by the pix\\_fmt\\_list parameter.
 
 ### Parameters
-* `pix_fmt_list`:\\[in\\] AV\\_PIX\\_FMT\\_NONE terminated array of pixel formats to choose from 
-
-* `src_pix_fmt`:\\[in\\] source pixel format 
-
-* `has_alpha`:\\[in\\] Whether the source pixel format alpha channel is used. 
-
-* `loss_ptr`:\\[out\\] Combination of flags informing you what kind of losses will occur. 
-
+* `pix_fmt_list`:\\[in\\] AV\\_PIX\\_FMT\\_NONE terminated array of pixel formats to choose from
+* `src_pix_fmt`:\\[in\\] source pixel format
+* `has_alpha`:\\[in\\] Whether the source pixel format alpha channel is used.
+* `loss_ptr`:\\[out\\] Combination of flags informing you what kind of losses will occur.
 ### Returns
 The best pixel format to convert to or -1 if none was found.
 """
@@ -4063,93 +4025,17 @@ function avcodec_find_best_pix_fmt_of_list(pix_fmt_list, src_pix_fmt::AVPixelFor
     ccall((:avcodec_find_best_pix_fmt_of_list, libavcodec), AVPixelFormat, (Ptr{AVPixelFormat}, AVPixelFormat, Cint, Ptr{Cint}), pix_fmt_list, src_pix_fmt, has_alpha, loss_ptr)
 end
 
-"""
-    avcodec_get_pix_fmt_loss(dst_pix_fmt::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer)
-
-\\deprecated see [`av_get_pix_fmt_loss`](@ref)()
-"""
-function avcodec_get_pix_fmt_loss(dst_pix_fmt::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer)
-    ccall((:avcodec_get_pix_fmt_loss, libavcodec), Cint, (AVPixelFormat, AVPixelFormat, Cint), dst_pix_fmt, src_pix_fmt, has_alpha)
-end
-
-"""
-    avcodec_find_best_pix_fmt_of_2(dst_pix_fmt1::AVPixelFormat, dst_pix_fmt2::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer, loss_ptr)
-
-\\deprecated see [`av_find_best_pix_fmt_of_2`](@ref)()
-"""
-function avcodec_find_best_pix_fmt_of_2(dst_pix_fmt1::AVPixelFormat, dst_pix_fmt2::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer, loss_ptr)
-    ccall((:avcodec_find_best_pix_fmt_of_2, libavcodec), AVPixelFormat, (AVPixelFormat, AVPixelFormat, AVPixelFormat, Cint, Ptr{Cint}), dst_pix_fmt1, dst_pix_fmt2, src_pix_fmt, has_alpha, loss_ptr)
-end
-
-function avcodec_find_best_pix_fmt2(dst_pix_fmt1::AVPixelFormat, dst_pix_fmt2::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer, loss_ptr)
-    ccall((:avcodec_find_best_pix_fmt2, libavcodec), AVPixelFormat, (AVPixelFormat, AVPixelFormat, AVPixelFormat, Cint, Ptr{Cint}), dst_pix_fmt1, dst_pix_fmt2, src_pix_fmt, has_alpha, loss_ptr)
-end
-
 function avcodec_default_get_format(s, fmt)
     ccall((:avcodec_default_get_format, libavcodec), AVPixelFormat, (Ptr{AVCodecContext}, Ptr{AVPixelFormat}), s, fmt)
 end
 
 """
-    av_get_codec_tag_string(buf, buf_size::Csize_t, codec_tag::Integer)
-
-Put a string representing the codec tag codec\\_tag in buf.
-
-\\deprecated see [`av_fourcc_make_string`](@ref)() and [`av_fourcc2str`](@ref)().
-
-### Parameters
-* `buf`: buffer to place codec tag in 
-
-* `buf_size`: size in bytes of buf 
+    avcodec_string(buf, buf_size::Integer, enc, encode::Integer)
 
-* `codec_tag`: codec tag to assign 
-
-### Returns
-the length of the string that would have been generated if enough space had been available, excluding the trailing null
+@}
 """
-function av_get_codec_tag_string(buf, buf_size::Csize_t, codec_tag::Integer)
-    ccall((:av_get_codec_tag_string, libavcodec), Csize_t, (Cstring, Csize_t, Cuint), buf, buf_size, codec_tag)
-end
-
 function avcodec_string(buf, buf_size::Integer, enc, encode::Integer)
-    ccall((:avcodec_string, libavcodec), Cvoid, (Cstring, Cint, Ptr{AVCodecContext}, Cint), buf, buf_size, enc, encode)
-end
-
-"""
-    av_get_profile_name(codec, profile::Integer)
-
-Return a name for the specified profile, if available.
-
-### Parameters
-* `codec`: the codec that is searched for the given profile 
-
-* `profile`: the profile value for which a name is requested 
-
-### Returns
-A name for the profile if found, NULL otherwise.
-"""
-function av_get_profile_name(codec, profile::Integer)
-    ccall((:av_get_profile_name, libavcodec), Cstring, (Ptr{AVCodec}, Cint), codec, profile)
-end
-
-"""
-    avcodec_profile_name(codec_id::AVCodecID, profile::Integer)
-
-Return a name for the specified profile, if available.
-
-!!! note
-
-    unlike [`av_get_profile_name`](@ref)(), which searches a list of profiles supported by a specific decoder or encoder implementation, this function searches the list of profiles from the [`AVCodecDescriptor`](@ref)
-
-### Parameters
-* `codec_id`: the ID of the codec to which the requested profile belongs 
-
-* `profile`: the profile value for which a name is requested 
-
-### Returns
-A name for the profile if found, NULL otherwise.
-"""
-function avcodec_profile_name(codec_id::AVCodecID, profile::Integer)
-    ccall((:avcodec_profile_name, libavcodec), Cstring, (AVCodecID, Cint), codec_id, profile)
+    ccall((:avcodec_string, libavcodec), Cvoid, (Cstring, Cint, Ptr{AVCodecContext}, Cint), buf, buf_size, enc, encode)
 end
 
 function avcodec_default_execute(c, func, arg, ret, count::Integer, size::Integer)
@@ -4172,20 +4058,14 @@ The buffer buf must be a preallocated buffer with a size big enough to contain t
 \\todo return the size in bytes required to store the samples in case of success, at the next libavutil bump
 
 ### Parameters
-* `frame`: the [`AVFrame`](@ref) frame->nb\\_samples must be set prior to calling the function. This function fills in frame->data, frame->extended\\_data, frame->linesize[0]. 
-
-* `nb_channels`: channel count 
-
-* `sample_fmt`: sample format 
-
-* `buf`: buffer to use for frame data 
-
-* `buf_size`: size of buffer 
-
-* `align`: plane size sample alignment (0 = default) 
-
+* `frame`: the [`AVFrame`](@ref) frame->nb\\_samples must be set prior to calling the function. This function fills in frame->data, frame->extended\\_data, frame->linesize[0].
+* `nb_channels`: channel count
+* `sample_fmt`: sample format
+* `buf`: buffer to use for frame data
+* `buf_size`: size of buffer
+* `align`: plane size sample alignment (0 = default)
 ### Returns
->=0 on success, negative error code on failure 
+>=0 on success, negative error code on failure
 """
 function avcodec_fill_audio_frame(frame, nb_channels::Integer, sample_fmt::AVSampleFormat, buf, buf_size::Integer, align::Integer)
     ccall((:avcodec_fill_audio_frame, libavcodec), Cint, (Ptr{AVFrame}, Cint, AVSampleFormat, Ptr{UInt8}, Cint, Cint), frame, nb_channels, sample_fmt, buf, buf_size, align)
@@ -4198,7 +4078,7 @@ Reset the internal codec state / flush internal buffers. Should be called e.g. w
 
 !!! note
 
-    for decoders, when refcounted frames are not used (i.e. avctx->refcounted\\_frames is 0), this invalidates the frames previously returned from the decoder. When refcounted frames are used, the decoder just releases any references it might keep internally, but the caller's reference remains valid.
+    for decoders, this function just releases any references the decoder might keep internally, but the caller's references remain valid.
 
 !!! note
 
@@ -4208,61 +4088,14 @@ function avcodec_flush_buffers(avctx)
     ccall((:avcodec_flush_buffers, libavcodec), Cvoid, (Ptr{AVCodecContext},), avctx)
 end
 
-"""
-    av_get_bits_per_sample(codec_id::AVCodecID)
-
-Return codec bits per sample.
-
-### Parameters
-* `codec_id`:\\[in\\] the codec 
-
-### Returns
-Number of bits per sample or zero if unknown for the given codec.
-"""
-function av_get_bits_per_sample(codec_id::AVCodecID)
-    ccall((:av_get_bits_per_sample, libavcodec), Cint, (AVCodecID,), codec_id)
-end
-
-"""
-    av_get_pcm_codec(fmt::AVSampleFormat, be::Integer)
-
-Return the PCM codec associated with a sample format. 
-
-### Parameters
-* `be`: endianness, 0 for little, 1 for big, -1 (or anything else) for native 
-
-### Returns
-AV\\_CODEC\\_ID\\_PCM\\_* or AV\\_CODEC\\_ID\\_NONE
-"""
-function av_get_pcm_codec(fmt::AVSampleFormat, be::Integer)
-    ccall((:av_get_pcm_codec, libavcodec), AVCodecID, (AVSampleFormat, Cint), fmt, be)
-end
-
-"""
-    av_get_exact_bits_per_sample(codec_id::AVCodecID)
-
-Return codec bits per sample. Only return non-zero if the bits per sample is exactly correct, not an approximation.
-
-### Parameters
-* `codec_id`:\\[in\\] the codec 
-
-### Returns
-Number of bits per sample or zero if unknown for the given codec.
-"""
-function av_get_exact_bits_per_sample(codec_id::AVCodecID)
-    ccall((:av_get_exact_bits_per_sample, libavcodec), Cint, (AVCodecID,), codec_id)
-end
-
 """
     av_get_audio_frame_duration(avctx, frame_bytes::Integer)
 
 Return audio frame duration.
 
 ### Parameters
-* `avctx`: codec context 
-
-* `frame_bytes`: size of the frame, or 0 if unknown 
-
+* `avctx`: codec context
+* `frame_bytes`: size of the frame, or 0 if unknown
 ### Returns
 frame duration, in samples, if known. 0 if not able to determine.
 """
@@ -4270,83 +4103,6 @@ function av_get_audio_frame_duration(avctx, frame_bytes::Integer)
     ccall((:av_get_audio_frame_duration, libavcodec), Cint, (Ptr{AVCodecContext}, Cint), avctx, frame_bytes)
 end
 
-"""
-    av_get_audio_frame_duration2(par, frame_bytes::Integer)
-
-This function is the same as [`av_get_audio_frame_duration`](@ref)(), except it works with [`AVCodecParameters`](@ref) instead of an [`AVCodecContext`](@ref).
-"""
-function av_get_audio_frame_duration2(par, frame_bytes::Integer)
-    ccall((:av_get_audio_frame_duration2, libavcodec), Cint, (Ptr{AVCodecParameters}, Cint), par, frame_bytes)
-end
-
-struct AVBitStreamFilter
-    name::Cstring
-    codec_ids::Ptr{AVCodecID}
-    priv_class::Ptr{AVClass}
-    priv_data_size::Cint
-    init::Ptr{Cvoid}
-    filter::Ptr{Cvoid}
-    close::Ptr{Cvoid}
-    flush::Ptr{Cvoid}
-end
-
-struct AVBitStreamFilterContext
-    priv_data::Ptr{Cvoid}
-    filter::Ptr{AVBitStreamFilter}
-    parser::Ptr{AVCodecParserContext}
-    next::Ptr{AVBitStreamFilterContext}
-    args::Cstring
-end
-
-"""
-    av_register_bitstream_filter(bsf)
-
-\\deprecated the old bitstream filtering API (using [`AVBitStreamFilterContext`](@ref)) is deprecated. Use the new bitstream filtering API (using [`AVBSFContext`](@ref)).
-"""
-function av_register_bitstream_filter(bsf)
-    ccall((:av_register_bitstream_filter, libavcodec), Cvoid, (Ptr{AVBitStreamFilter},), bsf)
-end
-
-"""
-    av_bitstream_filter_init(name)
-
-\\deprecated the old bitstream filtering API (using [`AVBitStreamFilterContext`](@ref)) is deprecated. Use [`av_bsf_get_by_name`](@ref)(), [`av_bsf_alloc`](@ref)(), and [`av_bsf_init`](@ref)() from the new bitstream filtering API (using [`AVBSFContext`](@ref)).
-"""
-function av_bitstream_filter_init(name)
-    ccall((:av_bitstream_filter_init, libavcodec), Ptr{AVBitStreamFilterContext}, (Cstring,), name)
-end
-
-"""
-    av_bitstream_filter_filter(bsfc, avctx, args, poutbuf, poutbuf_size, buf, buf_size::Integer, keyframe::Integer)
-
-\\deprecated the old bitstream filtering API (using [`AVBitStreamFilterContext`](@ref)) is deprecated. Use [`av_bsf_send_packet`](@ref)() and [`av_bsf_receive_packet`](@ref)() from the new bitstream filtering API (using [`AVBSFContext`](@ref)).
-"""
-function av_bitstream_filter_filter(bsfc, avctx, args, poutbuf, poutbuf_size, buf, buf_size::Integer, keyframe::Integer)
-    ccall((:av_bitstream_filter_filter, libavcodec), Cint, (Ptr{AVBitStreamFilterContext}, Ptr{AVCodecContext}, Cstring, Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{UInt8}, Cint, Cint), bsfc, avctx, args, poutbuf, poutbuf_size, buf, buf_size, keyframe)
-end
-
-"""
-    av_bitstream_filter_close(bsf)
-
-\\deprecated the old bitstream filtering API (using [`AVBitStreamFilterContext`](@ref)) is deprecated. Use [`av_bsf_free`](@ref)() from the new bitstream filtering API (using [`AVBSFContext`](@ref)).
-"""
-function av_bitstream_filter_close(bsf)
-    ccall((:av_bitstream_filter_close, libavcodec), Cvoid, (Ptr{AVBitStreamFilterContext},), bsf)
-end
-
-"""
-    av_bitstream_filter_next(f)
-
-\\deprecated the old bitstream filtering API (using [`AVBitStreamFilterContext`](@ref)) is deprecated. Use [`av_bsf_iterate`](@ref)() from the new bitstream filtering API (using [`AVBSFContext`](@ref)).
-"""
-function av_bitstream_filter_next(f)
-    ccall((:av_bitstream_filter_next, libavcodec), Ptr{AVBitStreamFilter}, (Ptr{AVBitStreamFilter},), f)
-end
-
-function av_bsf_next(opaque)
-    ccall((:av_bsf_next, libavcodec), Ptr{AVBitStreamFilter}, (Ptr{Ptr{Cvoid}},), opaque)
-end
-
 """
     av_fast_padded_malloc(ptr, size, min_size::Csize_t)
 
@@ -4367,72 +4123,6 @@ function av_fast_padded_mallocz(ptr, size, min_size::Csize_t)
     ccall((:av_fast_padded_mallocz, libavcodec), Cvoid, (Ptr{Cvoid}, Ptr{Cuint}, Csize_t), ptr, size, min_size)
 end
 
-"""
-    av_xiphlacing(s, v::Integer)
-
-Encode extradata length to a buffer. Used by xiph codecs.
-
-### Parameters
-* `s`: buffer to write to; must be at least (v/255+1) bytes long 
-
-* `v`: size of extradata in bytes 
-
-### Returns
-number of bytes written to the buffer.
-"""
-function av_xiphlacing(s, v::Integer)
-    ccall((:av_xiphlacing, libavcodec), Cuint, (Ptr{Cuchar}, Cuint), s, v)
-end
-
-"""
-    av_register_hwaccel(hwaccel)
-
-Register the hardware accelerator hwaccel.
-
-\\deprecated This function doesn't do anything.
-"""
-function av_register_hwaccel(hwaccel)
-    ccall((:av_register_hwaccel, libavcodec), Cvoid, (Ptr{AVHWAccel},), hwaccel)
-end
-
-"""
-    av_hwaccel_next(hwaccel)
-
-If hwaccel is NULL, returns the first registered hardware accelerator, if hwaccel is non-NULL, returns the next registered hardware accelerator after hwaccel, or NULL if hwaccel is the last one.
-
-\\deprecated AVHWaccel structures contain no user-serviceable parts, so this function should not be used.
-"""
-function av_hwaccel_next(hwaccel)
-    ccall((:av_hwaccel_next, libavcodec), Ptr{AVHWAccel}, (Ptr{AVHWAccel},), hwaccel)
-end
-
-"""
-    AVLockOp
-
-Lock operation used by lockmgr
-
-\\deprecated Deprecated together with [`av_lockmgr_register`](@ref)().
-"""
-const AVLockOp = UInt32
-const AV_LOCK_CREATE = 0 % UInt32
-const AV_LOCK_OBTAIN = 1 % UInt32
-const AV_LOCK_RELEASE = 2 % UInt32
-const AV_LOCK_DESTROY = 3 % UInt32
-
-"""
-    av_lockmgr_register(cb)
-
-Register a user provided lock manager supporting the operations specified by [`AVLockOp`](@ref). The "mutex" argument to the function points to a (void *) where the lockmgr should store/get a pointer to a user allocated mutex. It is NULL upon AV\\_LOCK\\_CREATE and equal to the value left by the last call for all other ops. If the lock manager is unable to perform the op then it should leave the mutex in the same state as when it was called and return a non-zero value. However, when called with AV\\_LOCK\\_DESTROY the mutex will always be assumed to have been successfully destroyed. If [`av_lockmgr_register`](@ref) succeeds it will return a non-negative value, if it fails it will return a negative value and destroy all mutex and unregister all callbacks. [`av_lockmgr_register`](@ref) is not thread-safe, it must be called from a single thread before any calls which make use of locking are used.
-
-\\deprecated This function does nothing, and always returns 0. Be sure to build with thread support to get basic thread safety.
-
-### Parameters
-* `cb`: User defined callback. [`av_lockmgr_register`](@ref) invokes calls to this callback and the previously registered callback. The callback will be used to create more than one mutex each of which must be backed by its own underlying locking mechanism (i.e. do not use a single static object to implement your lock manager). If cb is set to NULL the lockmgr will be unregistered.
-"""
-function av_lockmgr_register(cb)
-    ccall((:av_lockmgr_register, libavcodec), Cint, (Ptr{Cvoid},), cb)
-end
-
 """
     avcodec_is_open(s)
 
@@ -4443,25 +4133,10 @@ function avcodec_is_open(s)
     ccall((:avcodec_is_open, libavcodec), Cint, (Ptr{AVCodecContext},), s)
 end
 
-"""
-    av_cpb_properties_alloc(size)
-
-Allocate a CPB properties structure and initialize its fields to default values.
-
-### Parameters
-* `size`: if non-NULL, the size of the allocated struct will be written here. This is useful for embedding it in side data.
-
-### Returns
-the newly allocated struct or NULL on failure
-"""
-function av_cpb_properties_alloc(size)
-    ccall((:av_cpb_properties_alloc, libavcodec), Ptr{AVCPBProperties}, (Ptr{Csize_t},), size)
-end
-
 """
     AVDCT
 
-[`AVDCT`](@ref) context. 
+[`AVDCT`](@ref) context.
 
 !!! note
 
@@ -4517,11 +4192,12 @@ mutable struct FFTContext end
 """
     av_fft_init(nbits::Integer, inverse::Integer)
 
-Set up a complex FFT. 
+Set up a complex FFT.
 
-### Parameters
-* `nbits`: log2 of the length of the input array 
+\\deprecated use [`av_tx_init`](@ref) from libavutil/tx.h with a type of AV\\_TX\\_FLOAT\\_FFT
 
+### Parameters
+* `nbits`: log2 of the length of the input array
 * `inverse`: if 0 perform the forward transform, if 1 perform the inverse
 """
 function av_fft_init(nbits::Integer, inverse::Integer)
@@ -4532,6 +4208,8 @@ end
     av_fft_permute(s, z)
 
 Do the permutation needed BEFORE calling ff\\_fft\\_calc().
+
+\\deprecated without replacement
 """
 function av_fft_permute(s, z)
     ccall((:av_fft_permute, libavcodec), Cvoid, (Ptr{FFTContext}, Ptr{FFTComplex}), s, z)
@@ -4541,6 +4219,8 @@ end
     av_fft_calc(s, z)
 
 Do a complex FFT with the parameters defined in [`av_fft_init`](@ref)(). The input data must be permuted before. No 1.0/sqrt(n) normalization is done.
+
+\\deprecated use the [`av_tx_fn`](@ref) value returned by [`av_tx_init`](@ref), which also does permutation
 """
 function av_fft_calc(s, z)
     ccall((:av_fft_calc, libavcodec), Cvoid, (Ptr{FFTContext}, Ptr{FFTComplex}), s, z)
@@ -4550,6 +4230,11 @@ function av_fft_end(s)
     ccall((:av_fft_end, libavcodec), Cvoid, (Ptr{FFTContext},), s)
 end
 
+"""
+    av_mdct_init(nbits::Integer, inverse::Integer, scale::Cdouble)
+
+\\deprecated use [`av_tx_init`](@ref) from libavutil/tx.h with a type of AV\\_TX\\_FLOAT\\_MDCT, with a flag of AV\\_TX\\_FULL\\_IMDCT for a replacement to [`av_imdct_calc`](@ref).
+"""
 function av_mdct_init(nbits::Integer, inverse::Integer, scale::Cdouble)
     ccall((:av_mdct_init, libavcodec), Ptr{FFTContext}, (Cint, Cint, Cdouble), nbits, inverse, scale)
 end
@@ -4581,11 +4266,12 @@ mutable struct RDFTContext end
 """
     av_rdft_init(nbits::Integer, trans::RDFTransformType)
 
-Set up a real FFT. 
+Set up a real FFT.
 
-### Parameters
-* `nbits`: log2 of the length of the input array 
+\\deprecated use [`av_tx_init`](@ref) from libavutil/tx.h with a type of AV\\_TX\\_FLOAT\\_RDFT
 
+### Parameters
+* `nbits`: log2 of the length of the input array
 * `trans`: the type of transform
 """
 function av_rdft_init(nbits::Integer, trans::RDFTransformType)
@@ -4617,9 +4303,10 @@ Set up DCT.
 
     the first element of the input of DST-I is ignored
 
-### Parameters
-* `nbits`: size of the input array: (1 << nbits) for DCT-II, DCT-III and DST-I (1 << nbits) + 1 for DCT-I 
+\\deprecated use [`av_tx_init`](@ref) from libavutil/tx.h with an appropriate type of AV\\_TX\\_FLOAT\\_DCT
 
+### Parameters
+* `nbits`: size of the input array: (1 << nbits) for DCT-II, DCT-III and DST-I (1 << nbits) + 1 for DCT-I
 * `type`: the type of transform
 """
 function av_dct_init(nbits::Integer, type::DCTTransformType)
@@ -4634,7 +4321,11 @@ function av_dct_end(s)
     ccall((:av_dct_end, libavcodec), Cvoid, (Ptr{DCTContext},), s)
 end
 
-mutable struct AVBSFInternal end
+struct AVBitStreamFilter
+    name::Cstring
+    codec_ids::Ptr{AVCodecID}
+    priv_class::Ptr{AVClass}
+end
 
 """
     AVBSFContext
@@ -4648,7 +4339,6 @@ The fields in the struct will only be changed (by the caller or by the filter) a
 struct AVBSFContext
     av_class::Ptr{AVClass}
     filter::Ptr{AVBitStreamFilter}
-    internal::Ptr{AVBSFInternal}
     priv_data::Ptr{Cvoid}
     par_in::Ptr{AVCodecParameters}
     par_out::Ptr{AVCodecParameters}
@@ -4673,7 +4363,6 @@ Iterate over all registered bitstream filters.
 
 ### Parameters
 * `opaque`: a pointer where libavcodec will store the iteration state. Must point to NULL to start the iteration.
-
 ### Returns
 the next registered bitstream filter or NULL when the iteration is finished
 """
@@ -4687,10 +4376,8 @@ end
 Allocate a context for a given bitstream filter. The caller must fill in the context parameters as described in the documentation and then call [`av_bsf_init`](@ref)() before sending any data to the filter.
 
 ### Parameters
-* `filter`: the filter for which to allocate an instance. 
-
-* `ctx`: a pointer into which the pointer to the newly-allocated context will be written. It must be freed with [`av_bsf_free`](@ref)() after the filtering is done.
-
+* `filter`: the filter for which to allocate an instance.
+* `ctx`:\\[out\\] a pointer into which the pointer to the newly-allocated context will be written. It must be freed with [`av_bsf_free`](@ref)() after the filtering is done.
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) code on failure
 """
@@ -4702,6 +4389,9 @@ end
     av_bsf_init(ctx)
 
 Prepare the filter for use, after all the parameters and options have been set.
+
+### Parameters
+* `ctx`: a [`AVBSFContext`](@ref) previously allocated with [`av_bsf_alloc`](@ref)()
 """
 function av_bsf_init(ctx)
     ccall((:av_bsf_init, libavcodec), Cint, (Ptr{AVBSFContext},), ctx)
@@ -4715,10 +4405,10 @@ Submit a packet for filtering.
 After sending each packet, the filter must be completely drained by calling [`av_bsf_receive_packet`](@ref)() repeatedly until it returns [`AVERROR`](@ref)(EAGAIN) or [`AVERROR_EOF`](@ref).
 
 ### Parameters
+* `ctx`: an initialized [`AVBSFContext`](@ref)
 * `pkt`: the packet to filter. The bitstream filter will take ownership of the packet and reset the contents of pkt. pkt is not touched if an error occurs. If pkt is empty (i.e. NULL, or pkt->data is NULL and pkt->side\\_data\\_elems zero), it signals the end of the stream (i.e. no more non-empty packets will be sent; sending more empty packets does nothing) and will cause the filter to output any packets it may have buffered internally.
-
 ### Returns
-0 on success. [`AVERROR`](@ref)(EAGAIN) if packets need to be retrieved from the filter (using [`av_bsf_receive_packet`](@ref)()) before new input can be consumed. Another negative [`AVERROR`](@ref) value if an error occurs.
+- 0 on success. - [`AVERROR`](@ref)(EAGAIN) if packets need to be retrieved from the filter (using [`av_bsf_receive_packet`](@ref)()) before new input can be consumed. - Another negative [`AVERROR`](@ref) value if an error occurs.
 """
 function av_bsf_send_packet(ctx, pkt)
     ccall((:av_bsf_send_packet, libavcodec), Cint, (Ptr{AVBSFContext}, Ptr{AVPacket}), ctx, pkt)
@@ -4734,10 +4424,10 @@ Retrieve a filtered packet.
     one input packet may result in several output packets, so after sending a packet with [`av_bsf_send_packet`](@ref)(), this function needs to be called repeatedly until it stops returning 0. It is also possible for a filter to output fewer packets than were sent to it, so this function may return [`AVERROR`](@ref)(EAGAIN) immediately after a successful [`av_bsf_send_packet`](@ref)() call.
 
 ### Parameters
+* `ctx`: an initialized [`AVBSFContext`](@ref)
 * `pkt`:\\[out\\] this struct will be filled with the contents of the filtered packet. It is owned by the caller and must be freed using [`av_packet_unref`](@ref)() when it is no longer needed. This parameter should be "clean" (i.e. freshly allocated with [`av_packet_alloc`](@ref)() or unreffed with [`av_packet_unref`](@ref)()) when this function is called. If this function returns successfully, the contents of pkt will be completely overwritten by the returned data. On failure, pkt is not touched.
-
 ### Returns
-0 on success. [`AVERROR`](@ref)(EAGAIN) if more packets need to be sent to the filter (using [`av_bsf_send_packet`](@ref)()) to get more output. [`AVERROR_EOF`](@ref) if there will be no further output from the filter. Another negative [`AVERROR`](@ref) value if an error occurs.
+- 0 on success. - [`AVERROR`](@ref)(EAGAIN) if more packets need to be sent to the filter (using [`av_bsf_send_packet`](@ref)()) to get more output. - [`AVERROR_EOF`](@ref) if there will be no further output from the filter. - Another negative [`AVERROR`](@ref) value if an error occurs.
 """
 function av_bsf_receive_packet(ctx, pkt)
     ccall((:av_bsf_receive_packet, libavcodec), Cint, (Ptr{AVBSFContext}, Ptr{AVPacket}), ctx, pkt)
@@ -4805,10 +4495,8 @@ end
 Append bitstream filter to the list of bitstream filters.
 
 ### Parameters
-* `lst`: List to append to 
-
+* `lst`: List to append to
 * `bsf`: Filter context to be appended
-
 ### Returns
 >=0 on success, negative [`AVERROR`](@ref) in case of failure
 """
@@ -4822,12 +4510,9 @@ end
 Construct new bitstream filter context given it's name and options and append it to the list of bitstream filters.
 
 ### Parameters
-* `lst`: List to append to 
-
-* `bsf_name`: Name of the bitstream filter 
-
+* `lst`: List to append to
+* `bsf_name`: Name of the bitstream filter
 * `options`: Options for the bitstream filter, can be set to NULL
-
 ### Returns
 >=0 on success, negative [`AVERROR`](@ref) in case of failure
 """
@@ -4843,10 +4528,8 @@ Finalize list of bitstream filters.
 This function will transform AVBSFList to single AVBSFContext, so the whole chain of bitstream filters can be treated as single filter freshly allocated by [`av_bsf_alloc`](@ref)(). If the call is successful, AVBSFList structure is freed and lst will be set to NULL. In case of failure, caller is responsible for freeing the structure by [`av_bsf_list_free`](@ref)()
 
 ### Parameters
-* `lst`: Filter list structure to be transformed 
-
+* `lst`: Filter list structure to be transformed
 * `bsf`:\\[out\\] Pointer to be set to newly created AVBSFContext structure representing the chain of bitstream filters
-
 ### Returns
 >=0 on success, negative [`AVERROR`](@ref) in case of failure
 """
@@ -4860,10 +4543,8 @@ end
 Parse string describing list of bitstream filters and create single AVBSFContext describing the whole chain of bitstream filters. Resulting AVBSFContext can be treated as any other AVBSFContext freshly allocated by [`av_bsf_alloc`](@ref)().
 
 ### Parameters
-* `str`: String describing chain of bitstream filters in format `bsf1[=opt1=val1:opt2=val2][,bsf2]` 
-
+* `str`: String describing chain of bitstream filters in format `bsf1[=opt1=val1:opt2=val2][,bsf2]`
 * `bsf`:\\[out\\] Pointer to be set to newly created AVBSFContext structure representing the chain of bitstream filters
-
 ### Returns
 >=0 on success, negative [`AVERROR`](@ref) in case of failure
 """
@@ -4878,9 +4559,7 @@ Get null/pass-through bitstream filter.
 
 ### Parameters
 * `bsf`:\\[out\\] Pointer to be set to new instance of pass-through bitstream filter
-
 ### Returns
-
 """
 function av_bsf_get_null_filter(bsf)
     ccall((:av_bsf_get_null_filter, libavcodec), Cint, (Ptr{Ptr{AVBSFContext}},), bsf)
@@ -4893,7 +4572,6 @@ Iterate over all registered codecs.
 
 ### Parameters
 * `opaque`: a pointer where libavcodec will store the iteration state. Must point to NULL to start the iteration.
-
 ### Returns
 the next registered codec or NULL when the iteration is finished
 """
@@ -4907,8 +4585,7 @@ end
 Find a registered decoder with a matching codec ID.
 
 ### Parameters
-* `id`: [`AVCodecID`](@ref) of the requested decoder 
-
+* `id`: [`AVCodecID`](@ref) of the requested decoder
 ### Returns
 A decoder if one was found, NULL otherwise.
 """
@@ -4922,8 +4599,7 @@ end
 Find a registered decoder with the specified name.
 
 ### Parameters
-* `name`: name of the requested decoder 
-
+* `name`: name of the requested decoder
 ### Returns
 A decoder if one was found, NULL otherwise.
 """
@@ -4937,8 +4613,7 @@ end
 Find a registered encoder with a matching codec ID.
 
 ### Parameters
-* `id`: [`AVCodecID`](@ref) of the requested encoder 
-
+* `id`: [`AVCodecID`](@ref) of the requested encoder
 ### Returns
 An encoder if one was found, NULL otherwise.
 """
@@ -4952,8 +4627,7 @@ end
 Find a registered encoder with the specified name.
 
 ### Parameters
-* `name`: name of the requested encoder 
-
+* `name`: name of the requested encoder
 ### Returns
 An encoder if one was found, NULL otherwise.
 """
@@ -4981,6 +4655,21 @@ function av_codec_is_decoder(codec)
     ccall((:av_codec_is_decoder, libavcodec), Cint, (Ptr{AVCodec},), codec)
 end
 
+"""
+    av_get_profile_name(codec, profile::Integer)
+
+Return a name for the specified profile, if available.
+
+### Parameters
+* `codec`: the codec that is searched for the given profile
+* `profile`: the profile value for which a name is requested
+### Returns
+A name for the profile if found, NULL otherwise.
+"""
+function av_get_profile_name(codec, profile::Integer)
+    ccall((:av_get_profile_name, libavcodec), Cstring, (Ptr{AVCodec}, Cint), codec, profile)
+end
+
 const __JL_Ctag_95 = UInt32
 const AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = 1 % UInt32
 const AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = 2 % UInt32
@@ -5035,7 +4724,6 @@ Iterate over all codec descriptors known to libavcodec.
 
 ### Parameters
 * `prev`: previous descriptor. NULL to get the first descriptor.
-
 ### Returns
 next descriptor or NULL after the last descriptor
 """
@@ -5053,25 +4741,86 @@ function avcodec_descriptor_get_by_name(name)
     ccall((:avcodec_descriptor_get_by_name, libavcodec), Ptr{AVCodecDescriptor}, (Cstring,), name)
 end
 
-"""
-    avcodec_get_type(codec_id::AVCodecID)
+"""
+    avcodec_get_type(codec_id::AVCodecID)
+
+Get the type of the given codec.
+"""
+function avcodec_get_type(codec_id::AVCodecID)
+    ccall((:avcodec_get_type, libavcodec), AVMediaType, (AVCodecID,), codec_id)
+end
+
+"""
+    avcodec_get_name(id::AVCodecID)
+
+Get the name of a codec.
+
+### Returns
+a static string identifying the codec; never NULL
+"""
+function avcodec_get_name(id::AVCodecID)
+    ccall((:avcodec_get_name, libavcodec), Cstring, (AVCodecID,), id)
+end
+
+"""
+    av_get_bits_per_sample(codec_id::AVCodecID)
+
+Return codec bits per sample.
+
+### Parameters
+* `codec_id`:\\[in\\] the codec
+### Returns
+Number of bits per sample or zero if unknown for the given codec.
+"""
+function av_get_bits_per_sample(codec_id::AVCodecID)
+    ccall((:av_get_bits_per_sample, libavcodec), Cint, (AVCodecID,), codec_id)
+end
+
+"""
+    av_get_exact_bits_per_sample(codec_id::AVCodecID)
+
+Return codec bits per sample. Only return non-zero if the bits per sample is exactly correct, not an approximation.
+
+### Parameters
+* `codec_id`:\\[in\\] the codec
+### Returns
+Number of bits per sample or zero if unknown for the given codec.
+"""
+function av_get_exact_bits_per_sample(codec_id::AVCodecID)
+    ccall((:av_get_exact_bits_per_sample, libavcodec), Cint, (AVCodecID,), codec_id)
+end
+
+"""
+    avcodec_profile_name(codec_id::AVCodecID, profile::Integer)
+
+Return a name for the specified profile, if available.
+
+!!! note
 
-Get the type of the given codec.
+    unlike [`av_get_profile_name`](@ref)(), which searches a list of profiles supported by a specific decoder or encoder implementation, this function searches the list of profiles from the [`AVCodecDescriptor`](@ref)
+
+### Parameters
+* `codec_id`: the ID of the codec to which the requested profile belongs
+* `profile`: the profile value for which a name is requested
+### Returns
+A name for the profile if found, NULL otherwise.
 """
-function avcodec_get_type(codec_id::AVCodecID)
-    ccall((:avcodec_get_type, libavcodec), AVMediaType, (AVCodecID,), codec_id)
+function avcodec_profile_name(codec_id::AVCodecID, profile::Integer)
+    ccall((:avcodec_profile_name, libavcodec), Cstring, (AVCodecID, Cint), codec_id, profile)
 end
 
 """
-    avcodec_get_name(id::AVCodecID)
+    av_get_pcm_codec(fmt::AVSampleFormat, be::Integer)
 
-Get the name of a codec. 
+Return the PCM codec associated with a sample format.
 
+### Parameters
+* `be`: endianness, 0 for little, 1 for big, -1 (or anything else) for native
 ### Returns
-a static string identifying the codec; never NULL
+AV\\_CODEC\\_ID\\_PCM\\_* or AV\\_CODEC\\_ID\\_NONE
 """
-function avcodec_get_name(id::AVCodecID)
-    ccall((:avcodec_get_name, libavcodec), Cstring, (AVCodecID,), id)
+function av_get_pcm_codec(fmt::AVSampleFormat, be::Integer)
+    ccall((:av_get_pcm_codec, libavcodec), AVCodecID, (AVSampleFormat, Cint), fmt, be)
 end
 
 """
@@ -5104,6 +4853,15 @@ function avcodec_parameters_copy(dst, src)
     ccall((:avcodec_parameters_copy, libavcodec), Cint, (Ptr{AVCodecParameters}, Ptr{AVCodecParameters}), dst, src)
 end
 
+"""
+    av_get_audio_frame_duration2(par, frame_bytes::Integer)
+
+This function is the same as [`av_get_audio_frame_duration`](@ref)(), except it works with [`AVCodecParameters`](@ref) instead of an [`AVCodecContext`](@ref).
+"""
+function av_get_audio_frame_duration2(par, frame_bytes::Integer)
+    ccall((:av_get_audio_frame_duration2, libavcodec), Cint, (Ptr{AVCodecParameters}, Cint), par, frame_bytes)
+end
+
 struct AVD3D11VAContext
     decoder::Ptr{Cint}
     video_context::Ptr{Cint}
@@ -5127,6 +4885,70 @@ function av_d3d11va_alloc_context()
     ccall((:av_d3d11va_alloc_context, libavcodec), Ptr{AVD3D11VAContext}, ())
 end
 
+"""
+    AVPanScan
+
+Pan Scan area. This specifies the area which should be displayed. Note there may be multiple such areas for one frame.
+"""
+struct AVPanScan
+    id::Cint
+    width::Cint
+    height::Cint
+    position::NTuple{3, NTuple{2, Int16}}
+end
+
+"""
+    AVCPBProperties
+
+This structure describes the bitrate properties of an encoded bitstream. It roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD parameters for H.264/HEVC.
+"""
+struct AVCPBProperties
+    max_bitrate::Int64
+    min_bitrate::Int64
+    avg_bitrate::Int64
+    buffer_size::Int64
+    vbv_delay::UInt64
+end
+
+"""
+    av_cpb_properties_alloc(size)
+
+Allocate a CPB properties structure and initialize its fields to default values.
+
+### Parameters
+* `size`: if non-NULL, the size of the allocated struct will be written here. This is useful for embedding it in side data.
+### Returns
+the newly allocated struct or NULL on failure
+"""
+function av_cpb_properties_alloc(size)
+    ccall((:av_cpb_properties_alloc, libavcodec), Ptr{AVCPBProperties}, (Ptr{Csize_t},), size)
+end
+
+"""
+    AVProducerReferenceTime
+
+This structure supplies correlation between a packet timestamp and a wall clock production time. The definition follows the Producer Reference Time ('prft') as defined in ISO/IEC 14496-12
+"""
+struct AVProducerReferenceTime
+    wallclock::Int64
+    flags::Cint
+end
+
+"""
+    av_xiphlacing(s, v::Integer)
+
+Encode extradata length to a buffer. Used by xiph codecs.
+
+### Parameters
+* `s`: buffer to write to; must be at least (v/255+1) bytes long
+* `v`: size of extradata in bytes
+### Returns
+number of bytes written to the buffer.
+"""
+function av_xiphlacing(s, v::Integer)
+    ccall((:av_xiphlacing, libavcodec), Cuint, (Ptr{Cuchar}, Cuint), s, v)
+end
+
 """
     DiracParseCodes
 
@@ -5192,14 +5014,10 @@ end
 Parse a Dirac sequence header.
 
 ### Parameters
-* `dsh`: this function will allocate and fill an [`AVDiracSeqHeader`](@ref) struct and write it into this pointer. The caller must free it with [`av_free`](@ref)(). 
-
-* `buf`: the data buffer 
-
-* `buf_size`: the size of the data buffer in bytes 
-
-* `log_ctx`: if non-NULL, this function will log errors here 
-
+* `dsh`: this function will allocate and fill an [`AVDiracSeqHeader`](@ref) struct and write it into this pointer. The caller must free it with [`av_free`](@ref)().
+* `buf`: the data buffer
+* `buf_size`: the size of the data buffer in bytes
+* `log_ctx`: if non-NULL, this function will log errors here
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) code on failure
 """
@@ -5233,12 +5051,9 @@ end
 Get a DV profile for the provided compressed frame.
 
 ### Parameters
-* `sys`: the profile used for the previous frame, may be NULL 
-
-* `frame`: the compressed data buffer 
-
-* `buf_size`: size of the buffer in bytes 
-
+* `sys`: the profile used for the previous frame, may be NULL
+* `frame`: the compressed data buffer
+* `buf_size`: size of the buffer in bytes
 ### Returns
 the DV profile for the supplied data or NULL on failure
 """
@@ -5310,12 +5125,9 @@ end
 Convenience function that sets up the MediaCodec context.
 
 ### Parameters
-* `avctx`: codec context 
-
-* `ctx`: MediaCodec context to initialize 
-
-* `surface`: reference to an android/view/Surface 
-
+* `avctx`: codec context
+* `ctx`: MediaCodec context to initialize
+* `surface`: reference to an android/view/Surface
 ### Returns
 0 on success, < 0 otherwise
 """
@@ -5348,10 +5160,8 @@ const AVMediaCodecBuffer = MediaCodecBuffer
 Release a MediaCodec buffer and render it to the surface that is associated with the decoder. This function should only be called once on a given buffer, once released the underlying buffer returns to the codec, thus subsequent calls to this function will have no effect.
 
 ### Parameters
-* `buffer`: the buffer to render 
-
-* `render`: 1 to release and render the buffer to the surface or 0 to discard the buffer 
-
+* `buffer`: the buffer to render
+* `render`: 1 to release and render the buffer to the surface or 0 to discard the buffer
 ### Returns
 0 on success, < 0 otherwise
 """
@@ -5362,13 +5172,13 @@ end
 """
     av_mediacodec_render_buffer_at_time(buffer, time::Int64)
 
-Release a MediaCodec buffer and render it at the given time to the surface that is associated with the decoder. The timestamp must be within one second of the current java/lang/System#nanoTime() (which is implemented using CLOCK\\_MONOTONIC on Android). See the Android MediaCodec documentation of android/media/MediaCodec#releaseOutputBuffer(int,long) for more details.
-
-### Parameters
-* `buffer`: the buffer to render 
+Release a MediaCodec buffer and render it at the given time to the surface that is associated with the decoder. The timestamp must be within one second of the current `java/lang/System#nanoTime()` (which is implemented using `CLOCK_MONOTONIC` on Android). See the Android MediaCodec documentation of [`android/media/MediaCodec#releaseOutputBuffer(int,long)`][0] for more details.
 
-* `time`: timestamp in nanoseconds of when to render the buffer 
+[0]: https://developer.android.com/reference/android/media/MediaCodec#releaseOutputBuffer(int,20long)
 
+### Parameters
+* `buffer`: the buffer to render
+* `time`: timestamp in nanoseconds of when to render the buffer
 ### Returns
 0 on success, < 0 otherwise
 """
@@ -5376,6 +5186,90 @@ function av_mediacodec_render_buffer_at_time(buffer, time::Int64)
     ccall((:av_mediacodec_render_buffer_at_time, libavcodec), Cint, (Ptr{AVMediaCodecBuffer}, Int64), buffer, time)
 end
 
+"""
+    av_packet_side_data_new(psd, pnb_sd, type::AVPacketSideDataType, size::Csize_t, flags::Integer)
+
+Allocate a new packet side data.
+
+### Parameters
+* `sd`: pointer to an array of side data to which the side data should be added. *sd may be NULL, in which case the array will be initialized.
+* `nb_sd`: pointer to an integer containing the number of entries in the array. The integer value will be increased by 1 on success.
+* `type`: side data type
+* `size`: desired side data size
+* `flags`: currently unused. Must be zero
+### Returns
+pointer to freshly allocated side data on success, or NULL otherwise.
+"""
+function av_packet_side_data_new(psd, pnb_sd, type::AVPacketSideDataType, size::Csize_t, flags::Integer)
+    ccall((:av_packet_side_data_new, libavcodec), Ptr{AVPacketSideData}, (Ptr{Ptr{AVPacketSideData}}, Ptr{Cint}, AVPacketSideDataType, Csize_t, Cint), psd, pnb_sd, type, size, flags)
+end
+
+"""
+    av_packet_side_data_add(sd, nb_sd, type::AVPacketSideDataType, data, size::Csize_t, flags::Integer)
+
+Wrap existing data as packet side data.
+
+### Parameters
+* `sd`: pointer to an array of side data to which the side data should be added. *sd may be NULL, in which case the array will be initialized
+* `nb_sd`: pointer to an integer containing the number of entries in the array. The integer value will be increased by 1 on success.
+* `type`: side data type
+* `data`: a data array. It must be allocated with the [`av_malloc`](@ref)() family of functions. The ownership of the data is transferred to the side data array on success
+* `size`: size of the data array
+* `flags`: currently unused. Must be zero
+### Returns
+pointer to freshly allocated side data on success, or NULL otherwise On failure, the side data array is unchanged and the data remains owned by the caller.
+"""
+function av_packet_side_data_add(sd, nb_sd, type::AVPacketSideDataType, data, size::Csize_t, flags::Integer)
+    ccall((:av_packet_side_data_add, libavcodec), Ptr{AVPacketSideData}, (Ptr{Ptr{AVPacketSideData}}, Ptr{Cint}, AVPacketSideDataType, Ptr{Cvoid}, Csize_t, Cint), sd, nb_sd, type, data, size, flags)
+end
+
+"""
+    av_packet_side_data_get(sd, nb_sd::Integer, type::AVPacketSideDataType)
+
+Get side information from a side data array.
+
+### Parameters
+* `sd`: the array from which the side data should be fetched
+* `nb_sd`: value containing the number of entries in the array.
+* `type`: desired side information type
+### Returns
+pointer to side data if present or NULL otherwise
+"""
+function av_packet_side_data_get(sd, nb_sd::Integer, type::AVPacketSideDataType)
+    ccall((:av_packet_side_data_get, libavcodec), Ptr{AVPacketSideData}, (Ptr{AVPacketSideData}, Cint, AVPacketSideDataType), sd, nb_sd, type)
+end
+
+"""
+    av_packet_side_data_remove(sd, nb_sd, type::AVPacketSideDataType)
+
+Remove side data of the given type from a side data array.
+
+### Parameters
+* `sd`: the array from which the side data should be removed
+* `nb_sd`: pointer to an integer containing the number of entries in the array. Will be reduced by the amount of entries removed upon return
+* `type`: side information type
+"""
+function av_packet_side_data_remove(sd, nb_sd, type::AVPacketSideDataType)
+    ccall((:av_packet_side_data_remove, libavcodec), Cvoid, (Ptr{AVPacketSideData}, Ptr{Cint}, AVPacketSideDataType), sd, nb_sd, type)
+end
+
+"""
+    av_packet_side_data_free(sd, nb_sd)
+
+Convenience function to free all the side data stored in an array, and the array itself.
+
+### Parameters
+* `sd`: pointer to array of side data to free. Will be set to NULL upon return.
+* `nb_sd`: pointer to an integer containing the number of entries in the array. Will be set to 0 upon return.
+"""
+function av_packet_side_data_free(sd, nb_sd)
+    ccall((:av_packet_side_data_free, libavcodec), Cvoid, (Ptr{Ptr{AVPacketSideData}}, Ptr{Cint}), sd, nb_sd)
+end
+
+function av_packet_side_data_name(type::AVPacketSideDataType)
+    ccall((:av_packet_side_data_name, libavcodec), Cstring, (AVPacketSideDataType,), type)
+end
+
 struct AVPacketList
     pkt::AVPacket
     next::Ptr{AVPacketList}
@@ -5398,7 +5292,6 @@ Allocate an [`AVPacket`](@ref) and set its fields to default values. The resulti
 
 ### Returns
 An [`AVPacket`](@ref) filled with default values or NULL on failure.
-
 ### See also
 [`av_new_packet`](@ref)
 """
@@ -5415,7 +5308,6 @@ This is a shortcut for [`av_packet_alloc`](@ref)()+[`av_packet_ref`](@ref)().
 
 ### Returns
 newly created [`AVPacket`](@ref) on success, NULL on error.
-
 ### See also
 [`av_packet_alloc`](@ref), [`av_packet_ref`](@ref)
 """
@@ -5433,7 +5325,7 @@ Free the packet, if the packet is reference counted, it will be unreferenced fir
     passing NULL is a no-op.
 
 ### Parameters
-* `pkt`: packet to be freed. The pointer will be set to NULL. 
+* `pkt`: packet to be freed. The pointer will be set to NULL.
 """
 function av_packet_free(pkt)
     ccall((:av_packet_free, libavcodec), Cvoid, (Ptr{Ptr{AVPacket}},), pkt)
@@ -5450,7 +5342,6 @@ Note, this does not touch the data and size members, which have to be initialize
 
 ### Parameters
 * `pkt`: packet
-
 ### See also
 [`av_packet_alloc`](@ref), [`av_packet_unref`](@ref)
 """
@@ -5464,10 +5355,8 @@ end
 Allocate the payload of a packet and initialize its fields with default values.
 
 ### Parameters
-* `pkt`: packet 
-
-* `size`: wanted payload size 
-
+* `pkt`: packet
+* `size`: wanted payload size
 ### Returns
 0 if OK, AVERROR\\_xxx otherwise
 """
@@ -5481,8 +5370,7 @@ end
 Reduce packet size, correctly zeroing padding
 
 ### Parameters
-* `pkt`: packet 
-
+* `pkt`: packet
 * `size`: new size
 """
 function av_shrink_packet(pkt, size::Integer)
@@ -5495,8 +5383,7 @@ end
 Increase packet size, correctly zeroing padding
 
 ### Parameters
-* `pkt`: packet 
-
+* `pkt`: packet
 * `grow_by`: number of bytes by which to increase the size of the packet
 """
 function av_grow_packet(pkt, grow_by::Integer)
@@ -5509,12 +5396,9 @@ end
 Initialize a reference-counted packet from [`av_malloc`](@ref)()ed data.
 
 ### Parameters
-* `pkt`: packet to be initialized. This function will set the data, size, and buf fields, all others are left untouched. 
-
-* `data`: Data allocated by [`av_malloc`](@ref)() to be used as packet data. If this function returns successfully, the data is owned by the underlying [`AVBuffer`](@ref). The caller may not access the data through other means. 
-
+* `pkt`: packet to be initialized. This function will set the data, size, and buf fields, all others are left untouched.
+* `data`: Data allocated by [`av_malloc`](@ref)() to be used as packet data. If this function returns successfully, the data is owned by the underlying [`AVBuffer`](@ref). The caller may not access the data through other means.
 * `size`: size of data in bytes, without the padding. I.e. the full buffer size is assumed to be size + [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref).
-
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) on error
 """
@@ -5523,77 +5407,19 @@ function av_packet_from_data(pkt, data, size::Integer)
 end
 
 """
-    av_dup_packet(pkt)
-
-!!! warning
-
-    This is a hack - the packet memory allocation stuff is broken. The packet is allocated if it was not really allocated.
-
-\\deprecated Use [`av_packet_ref`](@ref) or [`av_packet_make_refcounted`](@ref)
-"""
-function av_dup_packet(pkt)
-    ccall((:av_dup_packet, libavcodec), Cint, (Ptr{AVPacket},), pkt)
-end
-
-"""
-    av_copy_packet(dst, src)
-
-Copy packet, including contents
-
-\\deprecated Use [`av_packet_ref`](@ref)
-
-### Returns
-0 on success, negative [`AVERROR`](@ref) on fail
-"""
-function av_copy_packet(dst, src)
-    ccall((:av_copy_packet, libavcodec), Cint, (Ptr{AVPacket}, Ptr{AVPacket}), dst, src)
-end
-
-"""
-    av_copy_packet_side_data(dst, src)
-
-Copy packet side data
-
-\\deprecated Use [`av_packet_copy_props`](@ref)
-
-### Returns
-0 on success, negative [`AVERROR`](@ref) on fail
-"""
-function av_copy_packet_side_data(dst, src)
-    ccall((:av_copy_packet_side_data, libavcodec), Cint, (Ptr{AVPacket}, Ptr{AVPacket}), dst, src)
-end
-
-"""
-    av_free_packet(pkt)
-
-Free a packet.
-
-\\deprecated Use [`av_packet_unref`](@ref)
-
-### Parameters
-* `pkt`: packet to free
-"""
-function av_free_packet(pkt)
-    ccall((:av_free_packet, libavcodec), Cvoid, (Ptr{AVPacket},), pkt)
-end
-
-"""
-    av_packet_new_side_data(pkt, type::AVPacketSideDataType, size::Integer)
+    av_packet_new_side_data(pkt, type::AVPacketSideDataType, size::Csize_t)
 
 Allocate new information of a packet.
 
 ### Parameters
-* `pkt`: packet 
-
-* `type`: side information type 
-
-* `size`: side information size 
-
+* `pkt`: packet
+* `type`: side information type
+* `size`: side information size
 ### Returns
 pointer to fresh allocated data or NULL otherwise
 """
-function av_packet_new_side_data(pkt, type::AVPacketSideDataType, size::Integer)
-    ccall((:av_packet_new_side_data, libavcodec), Ptr{UInt8}, (Ptr{AVPacket}, AVPacketSideDataType, Cint), pkt, type, size)
+function av_packet_new_side_data(pkt, type::AVPacketSideDataType, size::Csize_t)
+    ccall((:av_packet_new_side_data, libavcodec), Ptr{UInt8}, (Ptr{AVPacket}, AVPacketSideDataType, Csize_t), pkt, type, size)
 end
 
 """
@@ -5602,14 +5428,10 @@ end
 Wrap an existing array as a packet side data.
 
 ### Parameters
-* `pkt`: packet 
-
-* `type`: side information type 
-
-* `data`: the side data array. It must be allocated with the [`av_malloc`](@ref)() family of functions. The ownership of the data is transferred to pkt. 
-
-* `size`: side information size 
-
+* `pkt`: packet
+* `type`: side information type
+* `data`: the side data array. It must be allocated with the [`av_malloc`](@ref)() family of functions. The ownership of the data is transferred to pkt.
+* `size`: side information size
 ### Returns
 a non-negative number on success, a negative [`AVERROR`](@ref) code on failure. On failure, the packet is unchanged and the data remains owned by the caller.
 """
@@ -5618,22 +5440,19 @@ function av_packet_add_side_data(pkt, type::AVPacketSideDataType, data, size::Cs
 end
 
 """
-    av_packet_shrink_side_data(pkt, type::AVPacketSideDataType, size::Integer)
+    av_packet_shrink_side_data(pkt, type::AVPacketSideDataType, size::Csize_t)
 
 Shrink the already allocated side data buffer
 
 ### Parameters
-* `pkt`: packet 
-
-* `type`: side information type 
-
-* `size`: new side information size 
-
+* `pkt`: packet
+* `type`: side information type
+* `size`: new side information size
 ### Returns
 0 on success, < 0 on failure
 """
-function av_packet_shrink_side_data(pkt, type::AVPacketSideDataType, size::Integer)
-    ccall((:av_packet_shrink_side_data, libavcodec), Cint, (Ptr{AVPacket}, AVPacketSideDataType, Cint), pkt, type, size)
+function av_packet_shrink_side_data(pkt, type::AVPacketSideDataType, size::Csize_t)
+    ccall((:av_packet_shrink_side_data, libavcodec), Cint, (Ptr{AVPacket}, AVPacketSideDataType, Csize_t), pkt, type, size)
 end
 
 """
@@ -5642,37 +5461,45 @@ end
 Get side information from packet.
 
 ### Parameters
-* `pkt`: packet 
-
-* `type`: desired side information type 
-
-* `size`: If supplied, *size will be set to the size of the side data or to zero if the desired side data is not present. 
-
+* `pkt`: packet
+* `type`: desired side information type
+* `size`: If supplied, *size will be set to the size of the side data or to zero if the desired side data is not present.
 ### Returns
 pointer to data if present or NULL otherwise
 """
 function av_packet_get_side_data(pkt, type::AVPacketSideDataType, size)
-    ccall((:av_packet_get_side_data, libavcodec), Ptr{UInt8}, (Ptr{AVPacket}, AVPacketSideDataType, Ptr{Cint}), pkt, type, size)
-end
-
-function av_packet_merge_side_data(pkt)
-    ccall((:av_packet_merge_side_data, libavcodec), Cint, (Ptr{AVPacket},), pkt)
+    ccall((:av_packet_get_side_data, libavcodec), Ptr{UInt8}, (Ptr{AVPacket}, AVPacketSideDataType, Ptr{Csize_t}), pkt, type, size)
 end
 
-function av_packet_split_side_data(pkt)
-    ccall((:av_packet_split_side_data, libavcodec), Cint, (Ptr{AVPacket},), pkt)
-end
+"""
+    av_packet_pack_dictionary(dict, size)
 
-function av_packet_side_data_name(type::AVPacketSideDataType)
-    ccall((:av_packet_side_data_name, libavcodec), Cstring, (AVPacketSideDataType,), type)
-end
+Pack a dictionary for use in side\\_data.
 
+### Parameters
+* `dict`: The dictionary to pack.
+* `size`: pointer to store the size of the returned data
+### Returns
+pointer to data if successful, NULL otherwise
+"""
 function av_packet_pack_dictionary(dict, size)
-    ccall((:av_packet_pack_dictionary, libavcodec), Ptr{UInt8}, (Ptr{AVDictionary}, Ptr{Cint}), dict, size)
+    ccall((:av_packet_pack_dictionary, libavcodec), Ptr{UInt8}, (Ptr{AVDictionary}, Ptr{Csize_t}), dict, size)
 end
 
-function av_packet_unpack_dictionary(data, size::Integer, dict)
-    ccall((:av_packet_unpack_dictionary, libavcodec), Cint, (Ptr{UInt8}, Cint, Ptr{Ptr{AVDictionary}}), data, size, dict)
+"""
+    av_packet_unpack_dictionary(data, size::Csize_t, dict)
+
+Unpack a dictionary from side\\_data.
+
+### Parameters
+* `data`: data from side\\_data
+* `size`: size of the data
+* `dict`: the metadata storage dictionary
+### Returns
+0 on success, < 0 on failure
+"""
+function av_packet_unpack_dictionary(data, size::Csize_t, dict)
+    ccall((:av_packet_unpack_dictionary, libavcodec), Cint, (Ptr{UInt8}, Csize_t, Ptr{Ptr{AVDictionary}}), data, size, dict)
 end
 
 """
@@ -5697,13 +5524,10 @@ If src is reference-counted, setup dst as a new reference to the buffer in src.
 All the other fields are copied from src.
 
 ### Parameters
-* `dst`: Destination packet. Will be completely overwritten. 
-
+* `dst`: Destination packet. Will be completely overwritten.
 * `src`: Source packet
-
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) on error. On error, dst will be blank (as if returned by [`av_packet_alloc`](@ref)()).
-
 ### See also
 [`av_packet_unref`](@ref)
 """
@@ -5731,10 +5555,8 @@ end
 Move every field in src to dst and reset src.
 
 ### Parameters
-* `src`: Source packet, will be reset 
-
+* `src`: Source packet, will be reset
 * `dst`: Destination packet
-
 ### See also
 [`av_packet_unref`](@ref)
 """
@@ -5750,10 +5572,8 @@ Copy only "properties" fields from src to dst.
 Properties for the purpose of this function are all the fields beside those related to the packet data (buf, data, size)
 
 ### Parameters
-* `dst`: Destination packet 
-
+* `dst`: Destination packet
 * `src`: Source packet
-
 ### Returns
 0 on success [`AVERROR`](@ref) on failure.
 """
@@ -5772,10 +5592,8 @@ Ensure the data described by a given packet is reference counted.
 
 ### Parameters
 * `pkt`: packet whose data should be made reference counted.
-
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) on error. On failure, the packet is unchanged.
-
 ### See also
 [`av_packet_ref`](@ref), [`av_packet_make_writable`](@ref)
 """
@@ -5790,7 +5608,6 @@ Create a writable reference for the data described by a given packet, avoiding d
 
 ### Parameters
 * `pkt`: Packet whose data should be made writable.
-
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) on failure. On failure, the packet is unchanged.
 """
@@ -5804,10 +5621,8 @@ end
 Convert valid timing fields (timestamps / durations) in a packet from one timebase to another. Timestamps with unknown values ([`AV_NOPTS_VALUE`](@ref)) will be ignored.
 
 ### Parameters
-* `pkt`: packet on which the conversion will be performed 
-
-* `tb_src`: source timebase, in which the timing fields in pkt are expressed 
-
+* `pkt`: packet on which the conversion will be performed
+* `tb_src`: source timebase, in which the timing fields in pkt are expressed
 * `tb_dst`: destination timebase, to which the timing fields will be converted
 """
 function av_packet_rescale_ts(pkt, tb_src::AVRational, tb_dst::AVRational)
@@ -5836,35 +5651,6 @@ function av_qsv_alloc_context()
     ccall((:av_qsv_alloc_context, libavcodec), Ptr{AVQSVContext}, ())
 end
 
-"""
-    vaapi_context
-
-This structure is used to share data between the FFmpeg library and the client video application. This shall be zero-allocated and available as [`AVCodecContext`](@ref).hwaccel\\_context. All user members can be set once during initialization or through each [`AVCodecContext`](@ref).get\\_buffer() function call. In any case, they must be valid prior to calling decoding functions.
-
-Deprecated: use [`AVCodecContext`](@ref).hw\\_frames\\_ctx instead.
-"""
-struct vaapi_context
-    data::NTuple{16, UInt8}
-end
-
-function Base.getproperty(x::Ptr{vaapi_context}, f::Symbol)
-    f === :display && return Ptr{Ptr{Cvoid}}(x + 0)
-    f === :config_id && return Ptr{UInt32}(x + 8)
-    f === :context_id && return Ptr{UInt32}(x + 12)
-    return getfield(x, f)
-end
-
-function Base.getproperty(x::vaapi_context, f::Symbol)
-    r = Ref{vaapi_context}(x)
-    ptr = Base.unsafe_convert(Ptr{vaapi_context}, r)
-    fptr = getproperty(ptr, f)
-    GC.@preserve r unsafe_load(fptr)
-end
-
-function Base.setproperty!(x::Ptr{vaapi_context}, f::Symbol, v)
-    unsafe_store!(getproperty(x, f), v)
-end
-
 # typedef int ( * AVVDPAU_Render2 ) ( struct AVCodecContext * , struct AVFrame * , const VdpPictureInfo * , uint32_t , const VdpBitstreamBuffer * )
 const AVVDPAU_Render2 = Ptr{Cvoid}
 
@@ -5877,7 +5663,7 @@ The size of this structure is not a part of the public ABI and must not be used
 """
 struct AVVDPAUContext
     decoder::VdpDecoder
-    render::Ptr{Cvoid}
+    render::Ptr{VdpDecoderRender}
     render2::AVVDPAU_Render2
 end
 
@@ -5910,19 +5696,15 @@ Associate a VDPAU device with a codec context for hardware acceleration. This fu
     get\\_format() must return AV\\_PIX\\_FMT\\_VDPAU if this function completes successfully.
 
 ### Parameters
-* `avctx`: decoding context whose get\\_format() callback is invoked 
-
-* `device`: VDPAU device handle to use for hardware acceleration 
-
-* `get_proc_address`: VDPAU device driver 
-
+* `avctx`: decoding context whose get\\_format() callback is invoked
+* `device`: VDPAU device handle to use for hardware acceleration
+* `get_proc_address`: VDPAU device driver
 * `flags`: zero of more OR'd AV\\_HWACCEL\\_FLAG\\_* flags
-
 ### Returns
 0 on success, an [`AVERROR`](@ref) code on failure.
 """
 function av_vdpau_bind_context(avctx, device::VdpDevice, get_proc_address, flags::Integer)
-    ccall((:av_vdpau_bind_context, libavcodec), Cint, (Ptr{AVCodecContext}, VdpDevice, Ptr{Cvoid}, Cuint), avctx, device, get_proc_address, flags)
+    ccall((:av_vdpau_bind_context, libavcodec), Cint, (Ptr{AVCodecContext}, VdpDevice, Ptr{VdpGetProcAddress}, Cuint), avctx, device, get_proc_address, flags)
 end
 
 """
@@ -5935,14 +5717,10 @@ Gets the parameters to create an adequate VDPAU video surface for the codec cont
     Behavior is undefined if the context was not successfully bound to a VDPAU device using [`av_vdpau_bind_context`](@ref)().
 
 ### Parameters
-* `avctx`: the codec context being used for decoding the stream 
-
-* `type`: storage space for the VDPAU video surface chroma type (or NULL to ignore) 
-
-* `width`: storage space for the VDPAU video surface pixel width (or NULL to ignore) 
-
+* `avctx`: the codec context being used for decoding the stream
+* `type`: storage space for the VDPAU video surface chroma type (or NULL to ignore)
+* `width`: storage space for the VDPAU video surface pixel width (or NULL to ignore)
 * `height`: storage space for the VDPAU video surface pixel height (or NULL to ignore)
-
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) code on failure.
 """
@@ -5962,25 +5740,6 @@ function av_vdpau_alloc_context()
     ccall((:av_vdpau_alloc_context, libavcodec), Ptr{AVVDPAUContext}, ())
 end
 
-"""
-    av_vdpau_get_profile(avctx, profile)
-
-Get a decoder profile that should be used for initializing a VDPAU decoder. Should be called from the [`AVCodecContext`](@ref).get\\_format() callback.
-
-\\deprecated Use [`av_vdpau_bind_context`](@ref)() instead.
-
-### Parameters
-* `avctx`: the codec context being used for decoding the stream 
-
-* `profile`: a pointer into which the result will be written on success. The contents of profile are undefined if this function returns an error.
-
-### Returns
-0 on success (non-negative), a negative [`AVERROR`](@ref) on failure.
-"""
-function av_vdpau_get_profile(avctx, profile)
-    ccall((:av_vdpau_get_profile, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{VdpDecoderProfile}), avctx, profile)
-end
-
 struct AVVideotoolboxContext
     session::Cint
     output_callback::Cint
@@ -5998,6 +5757,8 @@ This function should be called from the get\\_format() callback when the caller
 
 When decoding with Videotoolbox is finished, the caller must destroy the decoder object and free the Videotoolbox context using [`av_free`](@ref)().
 
+\\deprecated Use [`AVCodecContext`](@ref).hw\\_frames\\_ctx or hw\\_device\\_ctx instead.
+
 ### Returns
 the newly allocated context or NULL on failure
 """
@@ -6010,9 +5771,10 @@ end
 
 This is a convenience function that creates and sets up the Videotoolbox context using an internal implementation.
 
+\\deprecated Use [`AVCodecContext`](@ref).hw\\_frames\\_ctx or hw\\_device\\_ctx instead.
+
 ### Parameters
 * `avctx`: the corresponding codec context
-
 ### Returns
 >= 0 on success, a negative [`AVERROR`](@ref) code on failure
 """
@@ -6025,11 +5787,11 @@ end
 
 This is a convenience function that creates and sets up the Videotoolbox context using an internal implementation.
 
-### Parameters
-* `avctx`: the corresponding codec context 
+\\deprecated Use [`AVCodecContext`](@ref).hw\\_frames\\_ctx or hw\\_device\\_ctx instead.
 
+### Parameters
+* `avctx`: the corresponding codec context
 * `vtctx`: the Videotoolbox context to use
-
 ### Returns
 >= 0 on success, a negative [`AVERROR`](@ref) code on failure
 """
@@ -6042,6 +5804,8 @@ end
 
 This function must be called to free the Videotoolbox context initialized with [`av_videotoolbox_default_init`](@ref)().
 
+\\deprecated Use [`AVCodecContext`](@ref).hw\\_frames\\_ctx or hw\\_device\\_ctx instead.
+
 ### Parameters
 * `avctx`: the corresponding codec context
 """
@@ -6077,12 +5841,9 @@ Get the duration for a Vorbis packet.
 If `flags` is `NULL`, special frames are considered invalid.
 
 ### Parameters
-* `s`: Vorbis parser context 
-
-* `buf`: buffer containing a Vorbis frame 
-
-* `buf_size`: size of the buffer 
-
+* `s`: Vorbis parser context
+* `buf`: buffer containing a Vorbis frame
+* `buf_size`: size of the buffer
 * `flags`: flags for special frames
 """
 function av_vorbis_parse_frame_flags(s, buf, buf_size::Integer, flags)
@@ -6095,10 +5856,8 @@ end
 Get the duration for a Vorbis packet.
 
 ### Parameters
-* `s`: Vorbis parser context 
-
-* `buf`: buffer containing a Vorbis frame 
-
+* `s`: Vorbis parser context
+* `buf`: buffer containing a Vorbis frame
 * `buf_size`: size of the buffer
 """
 function av_vorbis_parse_frame(s, buf, buf_size::Integer)
@@ -6199,9 +5958,9 @@ struct AVInputFormat
     codec_tag::Ptr{Ptr{AVCodecTag}}
     priv_class::Ptr{AVClass}
     mime_type::Cstring
-    next::Ptr{AVInputFormat}
     raw_codec_id::Cint
     priv_data_size::Cint
+    flags_internal::Cint
     read_probe::Ptr{Cvoid}
     read_header::Ptr{Cvoid}
     read_packet::Ptr{Cvoid}
@@ -6212,8 +5971,6 @@ struct AVInputFormat
     read_pause::Ptr{Cvoid}
     read_seek2::Ptr{Cvoid}
     get_device_list::Ptr{Cvoid}
-    create_device_capabilities::Ptr{Cvoid}
-    free_device_capabilities::Ptr{Cvoid}
 end
 
 """
@@ -6256,23 +6013,6 @@ struct AVOutputFormat
     flags::Cint
     codec_tag::Ptr{Ptr{AVCodecTag}}
     priv_class::Ptr{AVClass}
-    next::Ptr{AVOutputFormat}
-    priv_data_size::Cint
-    write_header::Ptr{Cvoid}
-    write_packet::Ptr{Cvoid}
-    write_trailer::Ptr{Cvoid}
-    interleave_packet::Ptr{Cvoid}
-    query_codec::Ptr{Cvoid}
-    get_output_timestamp::Ptr{Cvoid}
-    control_message::Ptr{Cvoid}
-    write_uncoded_frame::Ptr{Cvoid}
-    get_device_list::Ptr{Cvoid}
-    create_device_capabilities::Ptr{Cvoid}
-    free_device_capabilities::Ptr{Cvoid}
-    data_codec::AVCodecID
-    init::Ptr{Cvoid}
-    deinit::Ptr{Cvoid}
-    check_bitstream::Ptr{Cvoid}
 end
 
 """
@@ -6341,23 +6081,10 @@ const AV_DEV_TO_APP_BUFFER_WRITABLE = 1113018912 % UInt32
 const AV_DEV_TO_APP_MUTE_STATE_CHANGED = 1129141588 % UInt32
 const AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED = 1129729868 % UInt32
 
-"""
-    AVIODataMarkerType
-
-Different data types that can be returned via the AVIO write\\_data\\_type callback.
-"""
-const AVIODataMarkerType = UInt32
-const AVIO_DATA_MARKER_HEADER = 0 % UInt32
-const AVIO_DATA_MARKER_SYNC_POINT = 1 % UInt32
-const AVIO_DATA_MARKER_BOUNDARY_POINT = 2 % UInt32
-const AVIO_DATA_MARKER_UNKNOWN = 3 % UInt32
-const AVIO_DATA_MARKER_TRAILER = 4 % UInt32
-const AVIO_DATA_MARKER_FLUSH_POINT = 5 % UInt32
-
 """
     AVIOContext
 
-Bytestream IO Context. New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. sizeof([`AVIOContext`](@ref)) must not be used outside libav*.
+Bytestream IO Context. New public fields can be added with minor version bumps. Removal, reordering and changes to existing public fields require a major version bump. sizeof([`AVIOContext`](@ref)) must not be used outside libav*.
 
 !!! note
 
@@ -6375,168 +6102,56 @@ struct AVIOContext
     seek::Ptr{Cvoid}
     pos::Int64
     eof_reached::Cint
+    error::Cint
     write_flag::Cint
     max_packet_size::Cint
+    min_packet_size::Cint
     checksum::Culong
     checksum_ptr::Ptr{Cuchar}
     update_checksum::Ptr{Cvoid}
-    error::Cint
     read_pause::Ptr{Cvoid}
     read_seek::Ptr{Cvoid}
     seekable::Cint
-    maxsize::Int64
     direct::Cint
-    bytes_read::Int64
-    seek_count::Cint
-    writeout_count::Cint
-    orig_buffer_size::Cint
-    short_seek_threshold::Cint
     protocol_whitelist::Cstring
     protocol_blacklist::Cstring
     write_data_type::Ptr{Cvoid}
     ignore_boundary_point::Cint
-    current_type::AVIODataMarkerType
-    last_time::Int64
-    short_seek_get::Ptr{Cvoid}
-    written::Int64
     buf_ptr_max::Ptr{Cuchar}
-    min_packet_size::Cint
-end
-
-"""
-    AVStreamParseType
-
-@}
-"""
-const AVStreamParseType = UInt32
-const AVSTREAM_PARSE_NONE = 0 % UInt32
-const AVSTREAM_PARSE_FULL = 1 % UInt32
-const AVSTREAM_PARSE_HEADERS = 2 % UInt32
-const AVSTREAM_PARSE_TIMESTAMPS = 3 % UInt32
-const AVSTREAM_PARSE_FULL_ONCE = 4 % UInt32
-const AVSTREAM_PARSE_FULL_RAW = 5 % UInt32
-
-"""
-    AVProbeData
-
-This structure contains the data a format has to probe a file.
-"""
-struct AVProbeData
-    filename::Cstring
-    buf::Ptr{Cuchar}
-    buf_size::Cint
-    mime_type::Cstring
-end
-
-struct AVIndexEntry
-    data::NTuple{24, UInt8}
-end
-
-function Base.getproperty(x::Ptr{AVIndexEntry}, f::Symbol)
-    f === :pos && return Ptr{Int64}(x + 0)
-    f === :timestamp && return Ptr{Int64}(x + 8)
-    f === :flags && return (Ptr{Cint}(x + 16), 0, 2)
-    f === :size && return (Ptr{Cint}(x + 16), 2, 30)
-    f === :min_distance && return Ptr{Cint}(x + 20)
-    return getfield(x, f)
-end
-
-function Base.getproperty(x::AVIndexEntry, f::Symbol)
-    r = Ref{AVIndexEntry}(x)
-    ptr = Base.unsafe_convert(Ptr{AVIndexEntry}, r)
-    fptr = getproperty(ptr, f)
-    begin
-        if fptr isa Ptr
-            return GC.@preserve(r, unsafe_load(fptr))
-        else
-            (baseptr, offset, width) = fptr
-            ty = eltype(baseptr)
-            baseptr32 = convert(Ptr{UInt32}, baseptr)
-            u64 = GC.@preserve(r, unsafe_load(baseptr32))
-            if offset + width > 32
-                u64 |= GC.@preserve(r, unsafe_load(baseptr32 + 4)) << 32
-            end
-            u64 = u64 >> offset & (1 << width - 1)
-            return u64 % ty
-        end
-    end
-end
-
-function Base.setproperty!(x::Ptr{AVIndexEntry}, f::Symbol, v)
-    fptr = getproperty(x, f)
-    if fptr isa Ptr
-        unsafe_store!(getproperty(x, f), v)
-    else
-        (baseptr, offset, width) = fptr
-        baseptr32 = convert(Ptr{UInt32}, baseptr)
-        u64 = unsafe_load(baseptr32)
-        straddle = offset + width > 32
-        if straddle
-            u64 |= unsafe_load(baseptr32 + 4) << 32
-        end
-        mask = 1 << width - 1
-        u64 &= ~(mask << offset)
-        u64 |= (unsigned(v) & mask) << offset
-        unsafe_store!(baseptr32, u64 & typemax(UInt32))
-        if straddle
-            unsafe_store!(baseptr32 + 4, u64 >> 32)
-        end
-    end
+    bytes_read::Int64
+    bytes_written::Int64
 end
 
-mutable struct AVStreamInternal end
-
 """
     AVStream
 
 Stream structure. New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. sizeof([`AVStream`](@ref)) must not be used outside libav*.
 """
 struct AVStream
-    data::NTuple{496, UInt8}
+    data::NTuple{232, UInt8}
 end
 
 function Base.getproperty(x::Ptr{AVStream}, f::Symbol)
-    f === :index && return Ptr{Cint}(x + 0)
-    f === :id && return Ptr{Cint}(x + 4)
-    f === :codec && return Ptr{Ptr{AVCodecContext}}(x + 8)
-    f === :priv_data && return Ptr{Ptr{Cvoid}}(x + 16)
-    f === :time_base && return Ptr{AVRational}(x + 24)
-    f === :start_time && return Ptr{Int64}(x + 32)
-    f === :duration && return Ptr{Int64}(x + 40)
-    f === :nb_frames && return Ptr{Int64}(x + 48)
-    f === :disposition && return Ptr{Cint}(x + 56)
-    f === :discard && return Ptr{AVDiscard}(x + 60)
-    f === :sample_aspect_ratio && return Ptr{AVRational}(x + 64)
-    f === :metadata && return Ptr{Ptr{AVDictionary}}(x + 72)
-    f === :avg_frame_rate && return Ptr{AVRational}(x + 80)
-    f === :attached_pic && return Ptr{AVPacket}(x + 88)
-    f === :side_data && return Ptr{Ptr{AVPacketSideData}}(x + 176)
-    f === :nb_side_data && return Ptr{Cint}(x + 184)
-    f === :event_flags && return Ptr{Cint}(x + 188)
-    f === :r_frame_rate && return Ptr{AVRational}(x + 192)
-    f === :recommended_encoder_configuration && return Ptr{Cstring}(x + 200)
-    f === :codecpar && return Ptr{Ptr{AVCodecParameters}}(x + 208)
-    f === :unused && return Ptr{Ptr{Cvoid}}(x + 216)
+    f === :av_class && return Ptr{Ptr{AVClass}}(x + 0)
+    f === :index && return Ptr{Cint}(x + 8)
+    f === :id && return Ptr{Cint}(x + 12)
+    f === :codecpar && return Ptr{Ptr{AVCodecParameters}}(x + 16)
+    f === :priv_data && return Ptr{Ptr{Cvoid}}(x + 24)
+    f === :time_base && return Ptr{AVRational}(x + 32)
+    f === :start_time && return Ptr{Int64}(x + 40)
+    f === :duration && return Ptr{Int64}(x + 48)
+    f === :nb_frames && return Ptr{Int64}(x + 56)
+    f === :disposition && return Ptr{Cint}(x + 64)
+    f === :discard && return Ptr{AVDiscard}(x + 68)
+    f === :sample_aspect_ratio && return Ptr{AVRational}(x + 72)
+    f === :metadata && return Ptr{Ptr{AVDictionary}}(x + 80)
+    f === :avg_frame_rate && return Ptr{AVRational}(x + 88)
+    f === :attached_pic && return Ptr{AVPacket}(x + 96)
+    f === :side_data && return Ptr{Ptr{AVPacketSideData}}(x + 200)
+    f === :nb_side_data && return Ptr{Cint}(x + 208)
+    f === :event_flags && return Ptr{Cint}(x + 212)
+    f === :r_frame_rate && return Ptr{AVRational}(x + 216)
     f === :pts_wrap_bits && return Ptr{Cint}(x + 224)
-    f === :first_dts && return Ptr{Int64}(x + 232)
-    f === :cur_dts && return Ptr{Int64}(x + 240)
-    f === :last_IP_pts && return Ptr{Int64}(x + 248)
-    f === :last_IP_duration && return Ptr{Cint}(x + 256)
-    f === :probe_packets && return Ptr{Cint}(x + 260)
-    f === :codec_info_nb_frames && return Ptr{Cint}(x + 264)
-    f === :need_parsing && return Ptr{AVStreamParseType}(x + 268)
-    f === :parser && return Ptr{Ptr{AVCodecParserContext}}(x + 272)
-    f === :unused7 && return Ptr{Ptr{Cvoid}}(x + 280)
-    f === :unused6 && return Ptr{AVProbeData}(x + 288)
-    f === :unused5 && return Ptr{NTuple{17, Int64}}(x + 320)
-    f === :index_entries && return Ptr{Ptr{AVIndexEntry}}(x + 456)
-    f === :nb_index_entries && return Ptr{Cint}(x + 464)
-    f === :index_entries_allocated_size && return Ptr{Cuint}(x + 468)
-    f === :stream_identifier && return Ptr{Cint}(x + 472)
-    f === :unused8 && return Ptr{Cint}(x + 476)
-    f === :unused9 && return Ptr{Cint}(x + 480)
-    f === :unused10 && return Ptr{Cint}(x + 484)
-    f === :internal && return Ptr{Ptr{AVStreamInternal}}(x + 488)
     return getfield(x, f)
 end
 
@@ -6574,7 +6189,7 @@ struct AVProgram
 end
 
 struct AVChapter
-    id::Cint
+    id::Int64
     time_base::AVRational
     start::Int64
     _end::Int64
@@ -6603,8 +6218,6 @@ const AVFMT_DURATION_FROM_PTS = 0 % UInt32
 const AVFMT_DURATION_FROM_STREAM = 1 % UInt32
 const AVFMT_DURATION_FROM_BITRATE = 2 % UInt32
 
-mutable struct AVFormatInternal end
-
 # typedef int ( * av_format_control_message ) ( struct AVFormatContext * s , int type , void * data , size_t data_size )
 """
 Callback used by devices to communicate with application.
@@ -6619,7 +6232,7 @@ Format I/O context. New fields can be added to the end with minor version bumps.
 Fields can be accessed through AVOptions (av\\_opt*), the name string used matches the associated command line parameter name and can be found in libavformat/options\\_table.h. The [`AVOption`](@ref)/command line parameter names differ in some cases from the C structure field names for historic reasons or brevity.
 """
 struct AVFormatContext
-    data::NTuple{1504, UInt8}
+    data::NTuple{472, UInt8}
 end
 
 function Base.getproperty(x::Ptr{AVFormatContext}, f::Symbol)
@@ -6631,73 +6244,71 @@ function Base.getproperty(x::Ptr{AVFormatContext}, f::Symbol)
     f === :ctx_flags && return Ptr{Cint}(x + 40)
     f === :nb_streams && return Ptr{Cuint}(x + 44)
     f === :streams && return Ptr{Ptr{Ptr{AVStream}}}(x + 48)
-    f === :filename && return Ptr{NTuple{1024, Cchar}}(x + 56)
-    f === :url && return Ptr{Cstring}(x + 1080)
-    f === :start_time && return Ptr{Int64}(x + 1088)
-    f === :duration && return Ptr{Int64}(x + 1096)
-    f === :bit_rate && return Ptr{Int64}(x + 1104)
-    f === :packet_size && return Ptr{Cuint}(x + 1112)
-    f === :max_delay && return Ptr{Cint}(x + 1116)
-    f === :flags && return Ptr{Cint}(x + 1120)
-    f === :probesize && return Ptr{Int64}(x + 1128)
-    f === :max_analyze_duration && return Ptr{Int64}(x + 1136)
-    f === :key && return Ptr{Ptr{UInt8}}(x + 1144)
-    f === :keylen && return Ptr{Cint}(x + 1152)
-    f === :nb_programs && return Ptr{Cuint}(x + 1156)
-    f === :programs && return Ptr{Ptr{Ptr{AVProgram}}}(x + 1160)
-    f === :video_codec_id && return Ptr{AVCodecID}(x + 1168)
-    f === :audio_codec_id && return Ptr{AVCodecID}(x + 1172)
-    f === :subtitle_codec_id && return Ptr{AVCodecID}(x + 1176)
-    f === :max_index_size && return Ptr{Cuint}(x + 1180)
-    f === :max_picture_buffer && return Ptr{Cuint}(x + 1184)
-    f === :nb_chapters && return Ptr{Cuint}(x + 1188)
-    f === :chapters && return Ptr{Ptr{Ptr{AVChapter}}}(x + 1192)
-    f === :metadata && return Ptr{Ptr{AVDictionary}}(x + 1200)
-    f === :start_time_realtime && return Ptr{Int64}(x + 1208)
-    f === :fps_probe_size && return Ptr{Cint}(x + 1216)
-    f === :error_recognition && return Ptr{Cint}(x + 1220)
-    f === :interrupt_callback && return Ptr{AVIOInterruptCB}(x + 1224)
-    f === :debug && return Ptr{Cint}(x + 1240)
-    f === :max_interleave_delta && return Ptr{Int64}(x + 1248)
-    f === :strict_std_compliance && return Ptr{Cint}(x + 1256)
-    f === :event_flags && return Ptr{Cint}(x + 1260)
-    f === :max_ts_probe && return Ptr{Cint}(x + 1264)
-    f === :avoid_negative_ts && return Ptr{Cint}(x + 1268)
-    f === :ts_id && return Ptr{Cint}(x + 1272)
-    f === :audio_preload && return Ptr{Cint}(x + 1276)
-    f === :max_chunk_duration && return Ptr{Cint}(x + 1280)
-    f === :max_chunk_size && return Ptr{Cint}(x + 1284)
-    f === :use_wallclock_as_timestamps && return Ptr{Cint}(x + 1288)
-    f === :avio_flags && return Ptr{Cint}(x + 1292)
-    f === :duration_estimation_method && return Ptr{AVDurationEstimationMethod}(x + 1296)
-    f === :skip_initial_bytes && return Ptr{Int64}(x + 1304)
-    f === :correct_ts_overflow && return Ptr{Cuint}(x + 1312)
-    f === :seek2any && return Ptr{Cint}(x + 1316)
-    f === :flush_packets && return Ptr{Cint}(x + 1320)
-    f === :probe_score && return Ptr{Cint}(x + 1324)
-    f === :format_probesize && return Ptr{Cint}(x + 1328)
-    f === :codec_whitelist && return Ptr{Cstring}(x + 1336)
-    f === :format_whitelist && return Ptr{Cstring}(x + 1344)
-    f === :internal && return Ptr{Ptr{AVFormatInternal}}(x + 1352)
-    f === :io_repositioned && return Ptr{Cint}(x + 1360)
-    f === :video_codec && return Ptr{Ptr{AVCodec}}(x + 1368)
-    f === :audio_codec && return Ptr{Ptr{AVCodec}}(x + 1376)
-    f === :subtitle_codec && return Ptr{Ptr{AVCodec}}(x + 1384)
-    f === :data_codec && return Ptr{Ptr{AVCodec}}(x + 1392)
-    f === :metadata_header_padding && return Ptr{Cint}(x + 1400)
-    f === :opaque && return Ptr{Ptr{Cvoid}}(x + 1408)
-    f === :control_message_cb && return Ptr{av_format_control_message}(x + 1416)
-    f === :output_ts_offset && return Ptr{Int64}(x + 1424)
-    f === :dump_separator && return Ptr{Ptr{UInt8}}(x + 1432)
-    f === :data_codec_id && return Ptr{AVCodecID}(x + 1440)
-    f === :open_cb && return Ptr{Ptr{Cvoid}}(x + 1448)
-    f === :protocol_whitelist && return Ptr{Cstring}(x + 1456)
-    f === :io_open && return Ptr{Ptr{Cvoid}}(x + 1464)
-    f === :io_close && return Ptr{Ptr{Cvoid}}(x + 1472)
-    f === :protocol_blacklist && return Ptr{Cstring}(x + 1480)
-    f === :max_streams && return Ptr{Cint}(x + 1488)
-    f === :skip_estimate_duration_from_pts && return Ptr{Cint}(x + 1492)
-    f === :max_probe_packets && return Ptr{Cint}(x + 1496)
+    f === :url && return Ptr{Cstring}(x + 56)
+    f === :start_time && return Ptr{Int64}(x + 64)
+    f === :duration && return Ptr{Int64}(x + 72)
+    f === :bit_rate && return Ptr{Int64}(x + 80)
+    f === :packet_size && return Ptr{Cuint}(x + 88)
+    f === :max_delay && return Ptr{Cint}(x + 92)
+    f === :flags && return Ptr{Cint}(x + 96)
+    f === :probesize && return Ptr{Int64}(x + 104)
+    f === :max_analyze_duration && return Ptr{Int64}(x + 112)
+    f === :key && return Ptr{Ptr{UInt8}}(x + 120)
+    f === :keylen && return Ptr{Cint}(x + 128)
+    f === :nb_programs && return Ptr{Cuint}(x + 132)
+    f === :programs && return Ptr{Ptr{Ptr{AVProgram}}}(x + 136)
+    f === :video_codec_id && return Ptr{AVCodecID}(x + 144)
+    f === :audio_codec_id && return Ptr{AVCodecID}(x + 148)
+    f === :subtitle_codec_id && return Ptr{AVCodecID}(x + 152)
+    f === :max_index_size && return Ptr{Cuint}(x + 156)
+    f === :max_picture_buffer && return Ptr{Cuint}(x + 160)
+    f === :nb_chapters && return Ptr{Cuint}(x + 164)
+    f === :chapters && return Ptr{Ptr{Ptr{AVChapter}}}(x + 168)
+    f === :metadata && return Ptr{Ptr{AVDictionary}}(x + 176)
+    f === :start_time_realtime && return Ptr{Int64}(x + 184)
+    f === :fps_probe_size && return Ptr{Cint}(x + 192)
+    f === :error_recognition && return Ptr{Cint}(x + 196)
+    f === :interrupt_callback && return Ptr{AVIOInterruptCB}(x + 200)
+    f === :debug && return Ptr{Cint}(x + 216)
+    f === :max_interleave_delta && return Ptr{Int64}(x + 224)
+    f === :strict_std_compliance && return Ptr{Cint}(x + 232)
+    f === :event_flags && return Ptr{Cint}(x + 236)
+    f === :max_ts_probe && return Ptr{Cint}(x + 240)
+    f === :avoid_negative_ts && return Ptr{Cint}(x + 244)
+    f === :ts_id && return Ptr{Cint}(x + 248)
+    f === :audio_preload && return Ptr{Cint}(x + 252)
+    f === :max_chunk_duration && return Ptr{Cint}(x + 256)
+    f === :max_chunk_size && return Ptr{Cint}(x + 260)
+    f === :use_wallclock_as_timestamps && return Ptr{Cint}(x + 264)
+    f === :avio_flags && return Ptr{Cint}(x + 268)
+    f === :duration_estimation_method && return Ptr{AVDurationEstimationMethod}(x + 272)
+    f === :skip_initial_bytes && return Ptr{Int64}(x + 280)
+    f === :correct_ts_overflow && return Ptr{Cuint}(x + 288)
+    f === :seek2any && return Ptr{Cint}(x + 292)
+    f === :flush_packets && return Ptr{Cint}(x + 296)
+    f === :probe_score && return Ptr{Cint}(x + 300)
+    f === :format_probesize && return Ptr{Cint}(x + 304)
+    f === :codec_whitelist && return Ptr{Cstring}(x + 312)
+    f === :format_whitelist && return Ptr{Cstring}(x + 320)
+    f === :io_repositioned && return Ptr{Cint}(x + 328)
+    f === :video_codec && return Ptr{Ptr{AVCodec}}(x + 336)
+    f === :audio_codec && return Ptr{Ptr{AVCodec}}(x + 344)
+    f === :subtitle_codec && return Ptr{Ptr{AVCodec}}(x + 352)
+    f === :data_codec && return Ptr{Ptr{AVCodec}}(x + 360)
+    f === :metadata_header_padding && return Ptr{Cint}(x + 368)
+    f === :opaque && return Ptr{Ptr{Cvoid}}(x + 376)
+    f === :control_message_cb && return Ptr{av_format_control_message}(x + 384)
+    f === :output_ts_offset && return Ptr{Int64}(x + 392)
+    f === :dump_separator && return Ptr{Ptr{UInt8}}(x + 400)
+    f === :data_codec_id && return Ptr{AVCodecID}(x + 408)
+    f === :protocol_whitelist && return Ptr{Cstring}(x + 416)
+    f === :io_open && return Ptr{Ptr{Cvoid}}(x + 424)
+    f === :io_close && return Ptr{Ptr{Cvoid}}(x + 432)
+    f === :protocol_blacklist && return Ptr{Cstring}(x + 440)
+    f === :max_streams && return Ptr{Cint}(x + 448)
+    f === :skip_estimate_duration_from_pts && return Ptr{Cint}(x + 452)
+    f === :max_probe_packets && return Ptr{Cint}(x + 456)
+    f === :io_close2 && return Ptr{Ptr{Cvoid}}(x + 464)
     return getfield(x, f)
 end
 
@@ -6718,14 +6329,10 @@ end
 Send control message from application to device.
 
 ### Parameters
-* `s`: device context. 
-
-* `type`: message type. 
-
-* `data`: message data. Exact type depends on message type. 
-
-* `data_size`: size of message data. 
-
+* `s`: device context.
+* `type`: message type.
+* `data`: message data. Exact type depends on message type.
+* `data_size`: size of message data.
 ### Returns
 >= 0 on success, negative on error. [`AVERROR`](@ref)(ENOSYS) when device doesn't implement handler of the message.
 """
@@ -6739,14 +6346,10 @@ end
 Send control message from device to application.
 
 ### Parameters
-* `s`: device context. 
-
-* `type`: message type. 
-
-* `data`: message data. Can be NULL. 
-
-* `data_size`: size of message data. 
-
+* `s`: device context.
+* `type`: message type.
+* `data`: message data. Can be NULL.
+* `data_size`: size of message data.
 ### Returns
 >= 0 on success, negative on error. [`AVERROR`](@ref)(ENOSYS) when application doesn't implement handler of the message.
 """
@@ -6754,64 +6357,6 @@ function avdevice_dev_to_app_control_message(s, type::AVDevToAppMessageType, dat
     ccall((:avdevice_dev_to_app_control_message, libavdevice), Cint, (Ptr{AVFormatContext}, AVDevToAppMessageType, Ptr{Cvoid}, Csize_t), s, type, data, data_size)
 end
 
-"""
-    AVDeviceCapabilitiesQuery
-
-Structure describes device capabilities.
-
-It is used by devices in conjunction with av\\_device\\_capabilities [`AVOption`](@ref) table to implement capabilities probing API based on [`AVOption`](@ref) API. Should not be used directly.
-"""
-struct AVDeviceCapabilitiesQuery
-    av_class::Ptr{AVClass}
-    device_context::Ptr{AVFormatContext}
-    codec::AVCodecID
-    sample_format::AVSampleFormat
-    pixel_format::AVPixelFormat
-    sample_rate::Cint
-    channels::Cint
-    channel_layout::Int64
-    window_width::Cint
-    window_height::Cint
-    frame_width::Cint
-    frame_height::Cint
-    fps::AVRational
-end
-
-"""
-    avdevice_capabilities_create(caps, s, device_options)
-
-Initialize capabilities probing API based on [`AVOption`](@ref) API.
-
-[`avdevice_capabilities_free`](@ref)() must be called when query capabilities API is not used anymore.
-
-### Parameters
-* `caps`:\\[out\\] Device capabilities data. Pointer to a NULL pointer must be passed. 
-
-* `s`: Context of the device. 
-
-* `device_options`: An [`AVDictionary`](@ref) filled with device-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL. The same options must be passed later to [`avformat_write_header`](@ref)() for output devices or [`avformat_open_input`](@ref)() for input devices, or at any other place that affects device-private options.
-
-### Returns
->= 0 on success, negative otherwise.
-"""
-function avdevice_capabilities_create(caps, s, device_options)
-    ccall((:avdevice_capabilities_create, libavdevice), Cint, (Ptr{Ptr{AVDeviceCapabilitiesQuery}}, Ptr{AVFormatContext}, Ptr{Ptr{AVDictionary}}), caps, s, device_options)
-end
-
-"""
-    avdevice_capabilities_free(caps, s)
-
-Free resources created by [`avdevice_capabilities_create`](@ref)()
-
-### Parameters
-* `caps`: Device capabilities data to be freed. 
-
-* `s`: Context of the device.
-"""
-function avdevice_capabilities_free(caps, s)
-    ccall((:avdevice_capabilities_free, libavdevice), Cvoid, (Ptr{Ptr{AVDeviceCapabilitiesQuery}}, Ptr{AVFormatContext}), caps, s)
-end
-
 """
     AVDeviceInfo
 
@@ -6820,6 +6365,8 @@ Structure describes basic parameters of the device.
 struct AVDeviceInfo
     device_name::Cstring
     device_description::Cstring
+    media_types::Ptr{AVMediaType}
+    nb_media_types::Cint
 end
 
 """
@@ -6845,10 +6392,8 @@ Returns available device names and their parameters.
     : Some devices may accept system-dependent device names that cannot be autodetected. The list returned by this function cannot be assumed to be always completed.
 
 ### Parameters
-* `s`: device context. 
-
-* `device_list`:\\[out\\] list of autodetected devices. 
-
+* `s`: device context.
+* `device_list`:\\[out\\] list of autodetected devices.
 ### Returns
 count of autodetected devices, negative on error.
 """
@@ -6862,7 +6407,7 @@ end
 Convenient function to free result of [`avdevice_list_devices`](@ref)().
 
 ### Parameters
-* `devices`: device list to be freed.
+* `device_list`: device list to be freed.
 """
 function avdevice_free_list_devices(device_list)
     ccall((:avdevice_free_list_devices, libavdevice), Cvoid, (Ptr{Ptr{AVDeviceInfoList}},), device_list)
@@ -6880,16 +6425,12 @@ Returns available device names and their parameters. These are convinient wrappe
     device argument takes precedence over device\\_name when both are set.
 
 ### Parameters
-* `device`: device format. May be NULL if device name is set. 
-
-* `device_name`: device name. May be NULL if device format is set. 
-
-* `device_options`: An [`AVDictionary`](@ref) filled with device-private options. May be NULL. The same options must be passed later to [`avformat_write_header`](@ref)() for output devices or [`avformat_open_input`](@ref)() for input devices, or at any other place that affects device-private options. 
-
-* `device_list`:\\[out\\] list of autodetected devices 
-
+* `device`: device format. May be NULL if device name is set.
+* `device_name`: device name. May be NULL if device format is set.
+* `device_options`: An [`AVDictionary`](@ref) filled with device-private options. May be NULL. The same options must be passed later to [`avformat_write_header`](@ref)() for output devices or [`avformat_open_input`](@ref)() for input devices, or at any other place that affects device-private options.
+* `device_list`:\\[out\\] list of autodetected devices
 ### Returns
-count of autodetected devices, negative on error. 
+count of autodetected devices, negative on error.
 """
 function avdevice_list_input_sources(device, device_name, device_options, device_list)
     ccall((:avdevice_list_input_sources, libavdevice), Cint, (Ptr{AVInputFormat}, Cstring, Ptr{AVDictionary}, Ptr{Ptr{AVDeviceInfoList}}), device, device_name, device_options, device_list)
@@ -6928,48 +6469,76 @@ end
 
 mutable struct AVFilterPad end
 
-mutable struct AVFilterInternal end
+"""
+    __JL_Ctag_979
 
-mutable struct AVFilterCommand end
+The state of the following union is determined by formats\\_state. See the documentation of enum FilterFormatsState in internal.h.
+"""
+struct __JL_Ctag_979
+    data::NTuple{8, UInt8}
+end
+
+function Base.getproperty(x::Ptr{__JL_Ctag_979}, f::Symbol)
+    f === :query_func && return Ptr{Ptr{Cvoid}}(x + 0)
+    f === :pixels_list && return Ptr{Ptr{AVPixelFormat}}(x + 0)
+    f === :samples_list && return Ptr{Ptr{AVSampleFormat}}(x + 0)
+    f === :pix_fmt && return Ptr{AVPixelFormat}(x + 0)
+    f === :sample_fmt && return Ptr{AVSampleFormat}(x + 0)
+    return getfield(x, f)
+end
+
+function Base.getproperty(x::__JL_Ctag_979, f::Symbol)
+    r = Ref{__JL_Ctag_979}(x)
+    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_979}, r)
+    fptr = getproperty(ptr, f)
+    GC.@preserve r unsafe_load(fptr)
+end
+
+function Base.setproperty!(x::Ptr{__JL_Ctag_979}, f::Symbol, v)
+    unsafe_store!(getproperty(x, f), v)
+end
 
 """
-    AVFilterContext
+    AVFilter
 
-An instance of a filter 
+Filter definition. This defines the pads a filter contains, and all the callback functions used to interact with the filter.
 """
-struct AVFilterContext
-    av_class::Ptr{AVClass}
-    filter::Ptr{Cvoid} # filter::Ptr{AVFilter}
-    name::Cstring
-    input_pads::Ptr{AVFilterPad}
-    inputs::Ptr{Ptr{Cvoid}} # inputs::Ptr{Ptr{AVFilterLink}}
-    nb_inputs::Cuint
-    output_pads::Ptr{AVFilterPad}
-    outputs::Ptr{Ptr{Cvoid}} # outputs::Ptr{Ptr{AVFilterLink}}
-    nb_outputs::Cuint
-    priv::Ptr{Cvoid}
-    graph::Ptr{Cvoid} # graph::Ptr{AVFilterGraph}
-    thread_type::Cint
-    internal::Ptr{AVFilterInternal}
-    command_queue::Ptr{AVFilterCommand}
-    enable_str::Cstring
-    enable::Ptr{Cvoid}
-    var_values::Ptr{Cdouble}
-    is_disabled::Cint
-    hw_device_ctx::Ptr{AVBufferRef}
-    nb_threads::Cint
-    ready::Cuint
-    extra_hw_frames::Cint
+struct AVFilter
+    data::NTuple{104, UInt8}
 end
 
-function Base.getproperty(x::AVFilterContext, f::Symbol)
-    f === :filter && return Ptr{AVFilter}(getfield(x, f))
-    f === :inputs && return Ptr{Ptr{AVFilterLink}}(getfield(x, f))
-    f === :outputs && return Ptr{Ptr{AVFilterLink}}(getfield(x, f))
-    f === :graph && return Ptr{AVFilterGraph}(getfield(x, f))
+function Base.getproperty(x::Ptr{AVFilter}, f::Symbol)
+    f === :name && return Ptr{Cstring}(x + 0)
+    f === :description && return Ptr{Cstring}(x + 8)
+    f === :inputs && return Ptr{Ptr{AVFilterPad}}(x + 16)
+    f === :outputs && return Ptr{Ptr{AVFilterPad}}(x + 24)
+    f === :priv_class && return Ptr{Ptr{AVClass}}(x + 32)
+    f === :flags && return Ptr{Cint}(x + 40)
+    f === :nb_inputs && return Ptr{UInt8}(x + 44)
+    f === :nb_outputs && return Ptr{UInt8}(x + 45)
+    f === :formats_state && return Ptr{UInt8}(x + 46)
+    f === :preinit && return Ptr{Ptr{Cvoid}}(x + 48)
+    f === :init && return Ptr{Ptr{Cvoid}}(x + 56)
+    f === :uninit && return Ptr{Ptr{Cvoid}}(x + 64)
+    f === :formats && return Ptr{__JL_Ctag_979}(x + 72)
+    f === :priv_size && return Ptr{Cint}(x + 80)
+    f === :flags_internal && return Ptr{Cint}(x + 84)
+    f === :process_command && return Ptr{Ptr{Cvoid}}(x + 88)
+    f === :activate && return Ptr{Ptr{Cvoid}}(x + 96)
     return getfield(x, f)
 end
 
+function Base.getproperty(x::AVFilter, f::Symbol)
+    r = Ref{AVFilter}(x)
+    ptr = Base.unsafe_convert(Ptr{AVFilter}, r)
+    fptr = getproperty(ptr, f)
+    GC.@preserve r unsafe_load(fptr)
+end
+
+function Base.setproperty!(x::Ptr{AVFilter}, f::Symbol, v)
+    unsafe_store!(getproperty(x, f), v)
+end
+
 mutable struct AVFilterFormats end
 
 mutable struct AVFilterChannelLayouts end
@@ -6981,12 +6550,51 @@ Lists of formats / etc. supported by an end of a link.
 
 This structure is directly part of [`AVFilterLink`](@ref), in two copies: one for the source filter, one for the destination filter.
 
-These lists are used for negotiating the format to actually be used, which will be loaded into the format and channel\\_layout members of [`AVFilterLink`](@ref), when chosen.
-"""
-struct AVFilterFormatsConfig
-    formats::Ptr{AVFilterFormats}
-    samplerates::Ptr{AVFilterFormats}
-    channel_layouts::Ptr{AVFilterChannelLayouts}
+These lists are used for negotiating the format to actually be used, which will be loaded into the format and channel\\_layout members of [`AVFilterLink`](@ref), when chosen.
+"""
+struct AVFilterFormatsConfig
+    formats::Ptr{AVFilterFormats}
+    samplerates::Ptr{AVFilterFormats}
+    channel_layouts::Ptr{AVFilterChannelLayouts}
+end
+
+mutable struct AVFilterGraphInternal end
+
+# typedef int ( avfilter_execute_func ) ( AVFilterContext * ctx , avfilter_action_func * func , void * arg , int * ret , int nb_jobs )
+"""
+A function executing multiple jobs, possibly in parallel.
+
+### Parameters
+* `ctx`: the filter context to which the jobs belong
+* `func`: the function to be called multiple times
+* `arg`: the argument to be passed to func
+* `ret`: a nb\\_jobs-sized array to be filled with return values from each invocation of func
+* `nb_jobs`: the number of jobs to execute
+### Returns
+0 on success, a negative [`AVERROR`](@ref) on error
+"""
+const avfilter_execute_func = Cvoid
+
+struct AVFilterGraph
+    av_class::Ptr{AVClass}
+    filters::Ptr{Ptr{Cvoid}} # filters::Ptr{Ptr{AVFilterContext}}
+    nb_filters::Cuint
+    scale_sws_opts::Cstring
+    thread_type::Cint
+    nb_threads::Cint
+    internal::Ptr{AVFilterGraphInternal}
+    opaque::Ptr{Cvoid}
+    execute::Ptr{avfilter_execute_func}
+    aresample_swr_opts::Cstring
+    sink_links::Ptr{Ptr{Cvoid}} # sink_links::Ptr{Ptr{AVFilterLink}}
+    sink_links_count::Cint
+    disable_auto_convert::Cuint
+end
+
+function Base.getproperty(x::AVFilterGraph, f::Symbol)
+    f === :filters && return Ptr{Ptr{AVFilterContext}}(getfield(x, f))
+    f === :sink_links && return Ptr{Ptr{AVFilterLink}}(getfield(x, f))
+    return getfield(x, f)
 end
 
 """
@@ -6997,7 +6605,7 @@ A link between two filters. This contains pointers to the source and destination
 Applications must not normally access the link structure directly. Use the buffersrc and buffersink API instead. In the future, access to the header may be reserved for filters implementation.
 """
 struct AVFilterLink
-    data::NTuple{61680, UInt8}
+    data::NTuple{61704, UInt8}
 end
 
 function Base.getproperty(x::Ptr{AVFilterLink}, f::Symbol)
@@ -7013,25 +6621,25 @@ function Base.getproperty(x::Ptr{AVFilterLink}, f::Symbol)
     f === :sample_rate && return Ptr{Cint}(x + 64)
     f === :format && return Ptr{Cint}(x + 68)
     f === :time_base && return Ptr{AVRational}(x + 72)
-    f === :incfg && return Ptr{AVFilterFormatsConfig}(x + 80)
-    f === :outcfg && return Ptr{AVFilterFormatsConfig}(x + 104)
-    f === :init_state && return Ptr{Cvoid}(x + 128)
-    f === :graph && return Ptr{Ptr{AVFilterGraph}}(x + 136)
-    f === :current_pts && return Ptr{Int64}(x + 144)
-    f === :current_pts_us && return Ptr{Int64}(x + 152)
-    f === :age_index && return Ptr{Cint}(x + 160)
-    f === :frame_rate && return Ptr{AVRational}(x + 164)
-    f === :partial_buf && return Ptr{Ptr{AVFrame}}(x + 176)
-    f === :partial_buf_size && return Ptr{Cint}(x + 184)
-    f === :min_samples && return Ptr{Cint}(x + 188)
-    f === :max_samples && return Ptr{Cint}(x + 192)
-    f === :channels && return Ptr{Cint}(x + 196)
-    f === :frame_count_in && return Ptr{Int64}(x + 200)
-    f === :frame_count_out && return Ptr{Int64}(x + 208)
-    f === :frame_pool && return Ptr{Ptr{Cvoid}}(x + 216)
-    f === :frame_wanted_out && return Ptr{Cint}(x + 224)
-    f === :hw_frames_ctx && return Ptr{Ptr{AVBufferRef}}(x + 232)
-    f === :reserved && return Ptr{NTuple{61440, Cchar}}(x + 240)
+    f === :ch_layout && return Ptr{AVChannelLayout}(x + 80)
+    f === :incfg && return Ptr{AVFilterFormatsConfig}(x + 104)
+    f === :outcfg && return Ptr{AVFilterFormatsConfig}(x + 128)
+    f === :init_state && return Ptr{Cvoid}(x + 152)
+    f === :graph && return Ptr{Ptr{AVFilterGraph}}(x + 160)
+    f === :current_pts && return Ptr{Int64}(x + 168)
+    f === :current_pts_us && return Ptr{Int64}(x + 176)
+    f === :age_index && return Ptr{Cint}(x + 184)
+    f === :frame_rate && return Ptr{AVRational}(x + 188)
+    f === :min_samples && return Ptr{Cint}(x + 196)
+    f === :max_samples && return Ptr{Cint}(x + 200)
+    f === :frame_count_in && return Ptr{Int64}(x + 208)
+    f === :frame_count_out && return Ptr{Int64}(x + 216)
+    f === :sample_count_in && return Ptr{Int64}(x + 224)
+    f === :sample_count_out && return Ptr{Int64}(x + 232)
+    f === :frame_pool && return Ptr{Ptr{Cvoid}}(x + 240)
+    f === :frame_wanted_out && return Ptr{Cint}(x + 248)
+    f === :hw_frames_ctx && return Ptr{Ptr{AVBufferRef}}(x + 256)
+    f === :reserved && return Ptr{NTuple{61440, Cchar}}(x + 264)
     return getfield(x, f)
 end
 
@@ -7046,13 +6654,38 @@ function Base.setproperty!(x::Ptr{AVFilterLink}, f::Symbol, v)
     unsafe_store!(getproperty(x, f), v)
 end
 
+mutable struct AVFilterInternal end
+
+mutable struct AVFilterCommand end
+
 """
-    avfilter_pad_count(pads)
+    AVFilterContext
 
-Get the number of elements in a NULL-terminated array of AVFilterPads (e.g. [`AVFilter`](@ref).inputs/outputs).
+An instance of a filter
 """
-function avfilter_pad_count(pads)
-    ccall((:avfilter_pad_count, libavfilter), Cint, (Ptr{AVFilterPad},), pads)
+struct AVFilterContext
+    av_class::Ptr{AVClass}
+    filter::Ptr{AVFilter}
+    name::Cstring
+    input_pads::Ptr{AVFilterPad}
+    inputs::Ptr{Ptr{AVFilterLink}}
+    nb_inputs::Cuint
+    output_pads::Ptr{AVFilterPad}
+    outputs::Ptr{Ptr{AVFilterLink}}
+    nb_outputs::Cuint
+    priv::Ptr{Cvoid}
+    graph::Ptr{AVFilterGraph}
+    thread_type::Cint
+    internal::Ptr{AVFilterInternal}
+    command_queue::Ptr{AVFilterCommand}
+    enable_str::Cstring
+    enable::Ptr{Cvoid}
+    var_values::Ptr{Cdouble}
+    is_disabled::Cint
+    hw_device_ctx::Ptr{AVBufferRef}
+    nb_threads::Cint
+    ready::Cuint
+    extra_hw_frames::Cint
 end
 
 """
@@ -7061,10 +6694,8 @@ end
 Get the name of an [`AVFilterPad`](@ref).
 
 ### Parameters
-* `pads`: an array of AVFilterPads 
-
+* `pads`: an array of AVFilterPads
 * `pad_idx`: index of the pad in the array; it is the caller's responsibility to ensure the index is valid
-
 ### Returns
 name of the pad\\_idx'th pad in pads
 """
@@ -7078,10 +6709,8 @@ end
 Get the type of an [`AVFilterPad`](@ref).
 
 ### Parameters
-* `pads`: an array of AVFilterPads 
-
+* `pads`: an array of AVFilterPads
 * `pad_idx`: index of the pad in the array; it is the caller's responsibility to ensure the index is valid
-
 ### Returns
 type of the pad\\_idx'th pad in pads
 """
@@ -7090,28 +6719,12 @@ function avfilter_pad_get_type(pads, pad_idx::Integer)
 end
 
 """
-    AVFilter
+    avfilter_filter_pad_count(filter, is_output::Integer)
 
-Filter definition. This defines the pads a filter contains, and all the callback functions used to interact with the filter.
+Get the number of elements in an [`AVFilter`](@ref)'s inputs or outputs array.
 """
-struct AVFilter
-    name::Cstring
-    description::Cstring
-    inputs::Ptr{AVFilterPad}
-    outputs::Ptr{AVFilterPad}
-    priv_class::Ptr{AVClass}
-    flags::Cint
-    preinit::Ptr{Cvoid}
-    init::Ptr{Cvoid}
-    init_dict::Ptr{Cvoid}
-    uninit::Ptr{Cvoid}
-    query_formats::Ptr{Cvoid}
-    priv_size::Cint
-    flags_internal::Cint
-    next::Ptr{AVFilter}
-    process_command::Ptr{Cvoid}
-    init_opaque::Ptr{Cvoid}
-    activate::Ptr{Cvoid}
+function avfilter_filter_pad_count(filter, is_output::Integer)
+    ccall((:avfilter_filter_pad_count, libavfilter), Cuint, (Ptr{AVFilter}, Cint), filter, is_output)
 end
 
 """
@@ -7120,14 +6733,10 @@ end
 Link two filters together.
 
 ### Parameters
-* `src`: the source filter 
-
-* `srcpad`: index of the output pad on the source filter 
-
-* `dst`: the destination filter 
-
-* `dstpad`: index of the input pad on the destination filter 
-
+* `src`: the source filter
+* `srcpad`: index of the output pad on the source filter
+* `dst`: the destination filter
+* `dstpad`: index of the input pad on the destination filter
 ### Returns
 zero on success
 """
@@ -7144,36 +6753,13 @@ function avfilter_link_free(link)
     ccall((:avfilter_link_free, libavfilter), Cvoid, (Ptr{Ptr{AVFilterLink}},), link)
 end
 
-"""
-    avfilter_link_get_channels(link)
-
-Get the number of channels of a link. 
-
-\\deprecated Use [`av_buffersink_get_channels`](@ref)()
-"""
-function avfilter_link_get_channels(link)
-    ccall((:avfilter_link_get_channels, libavfilter), Cint, (Ptr{AVFilterLink},), link)
-end
-
-"""
-    avfilter_link_set_closed(link, closed::Integer)
-
-Set the closed field of a link. 
-
-\\deprecated applications are not supposed to mess with links, they should close the sinks.
-"""
-function avfilter_link_set_closed(link, closed::Integer)
-    ccall((:avfilter_link_set_closed, libavfilter), Cvoid, (Ptr{AVFilterLink}, Cint), link, closed)
-end
-
 """
     avfilter_config_links(filter)
 
 Negotiate the media format, dimensions, etc of all inputs to a filter.
 
 ### Parameters
-* `filter`: the filter to negotiate the properties for its inputs 
-
+* `filter`: the filter to negotiate the properties for its inputs
 ### Returns
 zero on successful negotiation
 """
@@ -7197,7 +6783,6 @@ Iterate over all registered filters.
 
 ### Parameters
 * `opaque`: a pointer where libavfilter will store the iteration state. Must point to NULL to start the iteration.
-
 ### Returns
 the next registered filter or NULL when the iteration is finished
 """
@@ -7205,50 +6790,13 @@ function av_filter_iterate(opaque)
     ccall((:av_filter_iterate, libavfilter), Ptr{AVFilter}, (Ptr{Ptr{Cvoid}},), opaque)
 end
 
-"""
-    avfilter_register_all()
-
-Initialize the filter system. Register all builtin filters. 
-"""
-function avfilter_register_all()
-    ccall((:avfilter_register_all, libavfilter), Cvoid, ())
-end
-
-"""
-    avfilter_register(filter)
-
-Register a filter. This is only needed if you plan to use [`avfilter_get_by_name`](@ref) later to lookup the [`AVFilter`](@ref) structure by name. A filter can still by instantiated with [`avfilter_graph_alloc_filter`](@ref) even if it is not registered.
-
-### Parameters
-* `filter`: the filter to register 
-
-### Returns
-0 if the registration was successful, a negative value otherwise
-"""
-function avfilter_register(filter)
-    ccall((:avfilter_register, libavfilter), Cint, (Ptr{AVFilter},), filter)
-end
-
-"""
-    avfilter_next(prev)
-
-Iterate over all registered filters. 
-
-### Returns
-If prev is non-NULL, next registered filter after prev or NULL if prev is the last filter. If prev is NULL, return the first registered filter.
-"""
-function avfilter_next(prev)
-    ccall((:avfilter_next, libavfilter), Ptr{AVFilter}, (Ptr{AVFilter},), prev)
-end
-
 """
     avfilter_get_by_name(name)
 
 Get a filter definition matching the given name.
 
 ### Parameters
-* `name`: the filter name to find 
-
+* `name`: the filter name to find
 ### Returns
 the filter definition, if any matching one is registered. NULL if none found.
 """
@@ -7262,10 +6810,8 @@ end
 Initialize a filter with the supplied parameters.
 
 ### Parameters
-* `ctx`: uninitialized filter context to initialize 
-
-* `args`: Options to initialize the filter with. This must be a ':'-separated list of options in the 'key=value' form. May be NULL if the options have been set directly using the AVOptions API or there are no options that need to be set. 
-
+* `ctx`: uninitialized filter context to initialize
+* `args`: Options to initialize the filter with. This must be a ':'-separated list of options in the 'key=value' form. May be NULL if the options have been set directly using the AVOptions API or there are no options that need to be set.
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) on failure
 """
@@ -7283,10 +6829,8 @@ Initialize a filter with the supplied dictionary of options.
     This function and [`avfilter_init_str`](@ref)() do essentially the same thing, the difference is in manner in which the options are passed. It is up to the calling code to choose whichever is more preferable. The two functions also behave differently when some of the provided options are not declared as supported by the filter. In such a case, [`avfilter_init_str`](@ref)() will fail, but this function will leave those extra options in the options [`AVDictionary`](@ref) and continue as usual.
 
 ### Parameters
-* `ctx`: uninitialized filter context to initialize 
-
-* `options`: An [`AVDictionary`](@ref) filled with options for this filter. On return this parameter will be destroyed and replaced with a dict containing options that were not found. This dictionary must be freed by the caller. May be NULL, then this function is equivalent to [`avfilter_init_str`](@ref)() with the second parameter set to NULL. 
-
+* `ctx`: uninitialized filter context to initialize
+* `options`: An [`AVDictionary`](@ref) filled with options for this filter. On return this parameter will be destroyed and replaced with a dict containing options that were not found. This dictionary must be freed by the caller. May be NULL, then this function is equivalent to [`avfilter_init_str`](@ref)() with the second parameter set to NULL.
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) on failure
 """
@@ -7312,14 +6856,10 @@ end
 Insert a filter in the middle of an existing link.
 
 ### Parameters
-* `link`: the link into which the filter should be inserted 
-
-* `filt`: the filter to be inserted 
-
-* `filt_srcpad_idx`: the input pad on the filter to connect 
-
-* `filt_dstpad_idx`: the output pad on the filter to connect 
-
+* `link`: the link into which the filter should be inserted
+* `filt`: the filter to be inserted
+* `filt_srcpad_idx`: the input pad on the filter to connect
+* `filt_dstpad_idx`: the output pad on the filter to connect
 ### Returns
 zero on success
 """
@@ -7332,7 +6872,6 @@ end
 
 ### Returns
 [`AVClass`](@ref) for [`AVFilterContext`](@ref).
-
 ### See also
 [`av_opt_find`](@ref)().
 """
@@ -7340,79 +6879,20 @@ function avfilter_get_class()
     ccall((:avfilter_get_class, libavfilter), Ptr{AVClass}, ())
 end
 
-mutable struct AVFilterGraphInternal end
-
 # typedef int ( avfilter_action_func ) ( AVFilterContext * ctx , void * arg , int jobnr , int nb_jobs )
 """
 A function pointer passed to the AVFilterGraph.execute callback to be executed multiple times, possibly in parallel.
 
 ### Parameters
-* `ctx`: the filter context the job belongs to 
-
-* `arg`: an opaque parameter passed through from AVFilterGraph.execute 
-
-* `jobnr`: the index of the job being executed 
-
+* `ctx`: the filter context the job belongs to
+* `arg`: an opaque parameter passed through from AVFilterGraph.execute
+* `jobnr`: the index of the job being executed
 * `nb_jobs`: the total number of jobs
-
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) on error
 """
 const avfilter_action_func = Cvoid
 
-# typedef int ( avfilter_execute_func ) ( AVFilterContext * ctx , avfilter_action_func * func , void * arg , int * ret , int nb_jobs )
-"""
-A function executing multiple jobs, possibly in parallel.
-
-### Parameters
-* `ctx`: the filter context to which the jobs belong 
-
-* `func`: the function to be called multiple times 
-
-* `arg`: the argument to be passed to func 
-
-* `ret`: a nb\\_jobs-sized array to be filled with return values from each invocation of func 
-
-* `nb_jobs`: the number of jobs to execute
-
-### Returns
-0 on success, a negative [`AVERROR`](@ref) on error
-"""
-const avfilter_execute_func = Cvoid
-
-struct AVFilterGraph
-    data::NTuple{96, UInt8}
-end
-
-function Base.getproperty(x::Ptr{AVFilterGraph}, f::Symbol)
-    f === :av_class && return Ptr{Ptr{AVClass}}(x + 0)
-    f === :filters && return Ptr{Ptr{Ptr{AVFilterContext}}}(x + 8)
-    f === :nb_filters && return Ptr{Cuint}(x + 16)
-    f === :scale_sws_opts && return Ptr{Cstring}(x + 24)
-    f === :resample_lavr_opts && return Ptr{Cstring}(x + 32)
-    f === :thread_type && return Ptr{Cint}(x + 40)
-    f === :nb_threads && return Ptr{Cint}(x + 44)
-    f === :internal && return Ptr{Ptr{AVFilterGraphInternal}}(x + 48)
-    f === :opaque && return Ptr{Ptr{Cvoid}}(x + 56)
-    f === :execute && return Ptr{Ptr{Cvoid}}(x + 64)
-    f === :aresample_swr_opts && return Ptr{Cstring}(x + 72)
-    f === :sink_links && return Ptr{Ptr{Ptr{AVFilterLink}}}(x + 80)
-    f === :sink_links_count && return Ptr{Cint}(x + 88)
-    f === :disable_auto_convert && return Ptr{Cuint}(x + 92)
-    return getfield(x, f)
-end
-
-function Base.getproperty(x::AVFilterGraph, f::Symbol)
-    r = Ref{AVFilterGraph}(x)
-    ptr = Base.unsafe_convert(Ptr{AVFilterGraph}, r)
-    fptr = getproperty(ptr, f)
-    GC.@preserve r unsafe_load(fptr)
-end
-
-function Base.setproperty!(x::Ptr{AVFilterGraph}, f::Symbol, v)
-    unsafe_store!(getproperty(x, f), v)
-end
-
 """
     avfilter_graph_alloc()
 
@@ -7431,12 +6911,9 @@ end
 Create a new filter instance in a filter graph.
 
 ### Parameters
-* `graph`: graph in which the new filter will be used 
-
-* `filter`: the filter to create an instance of 
-
+* `graph`: graph in which the new filter will be used
+* `filter`: the filter to create an instance of
 * `name`: Name to give to the new instance (will be copied to [`AVFilterContext`](@ref).name). This may be used by the caller to identify different filters, libavfilter itself assigns no semantics to this parameter. May be NULL.
-
 ### Returns
 the context of the newly created filter instance (note that it is also retrievable directly through [`AVFilterGraph`](@ref).filters or with [`avfilter_graph_get_filter`](@ref)()) on success or NULL on failure.
 """
@@ -7450,10 +6927,8 @@ end
 Get a filter instance identified by instance name from graph.
 
 ### Parameters
-* `graph`: filter graph to search through. 
-
-* `name`: filter instance name (should be unique in the graph). 
-
+* `graph`: filter graph to search through.
+* `name`: filter instance name (should be unique in the graph).
 ### Returns
 the pointer to the found filter instance or NULL if it cannot be found.
 """
@@ -7469,10 +6944,8 @@ Create and add a filter instance into an existing graph. The filter instance is
 In case of success put in *filt\\_ctx the pointer to the created filter instance, otherwise set *filt\\_ctx to NULL.
 
 ### Parameters
-* `name`: the instance name to give to the created filter instance 
-
-* `graph_ctx`: the filter graph 
-
+* `name`: the instance name to give to the created filter instance
+* `graph_ctx`: the filter graph
 ### Returns
 a negative [`AVERROR`](@ref) error code in case of failure, a non negative value otherwise
 """
@@ -7494,150 +6967,367 @@ function avfilter_graph_set_auto_convert(graph, flags::Integer)
     ccall((:avfilter_graph_set_auto_convert, libavfilter), Cvoid, (Ptr{AVFilterGraph}, Cuint), graph, flags)
 end
 
-const __JL_Ctag_374 = Int32
+const __JL_Ctag_346 = Int32
 const AVFILTER_AUTO_CONVERT_ALL = 0 % Int32
 const AVFILTER_AUTO_CONVERT_NONE = -1 % Int32
 
 """
-    avfilter_graph_config(graphctx, log_ctx)
-
-Check validity and configure all the links and formats in the graph.
+    avfilter_graph_config(graphctx, log_ctx)
+
+Check validity and configure all the links and formats in the graph.
+
+### Parameters
+* `graphctx`: the filter graph
+* `log_ctx`: context used for logging
+### Returns
+>= 0 in case of success, a negative [`AVERROR`](@ref) code otherwise
+"""
+function avfilter_graph_config(graphctx, log_ctx)
+    ccall((:avfilter_graph_config, libavfilter), Cint, (Ptr{AVFilterGraph}, Ptr{Cvoid}), graphctx, log_ctx)
+end
+
+"""
+    avfilter_graph_free(graph)
+
+Free a graph, destroy its links, and set *graph to NULL. If *graph is NULL, do nothing.
+"""
+function avfilter_graph_free(graph)
+    ccall((:avfilter_graph_free, libavfilter), Cvoid, (Ptr{Ptr{AVFilterGraph}},), graph)
+end
+
+"""
+    AVFilterInOut
+
+A linked-list of the inputs/outputs of the filter chain.
+
+This is mainly useful for [`avfilter_graph_parse`](@ref)() / [`avfilter_graph_parse2`](@ref)(), where it is used to communicate open (unlinked) inputs and outputs from and to the caller. This struct specifies, per each not connected pad contained in the graph, the filter context and the pad index required for establishing a link.
+"""
+struct AVFilterInOut
+    name::Cstring
+    filter_ctx::Ptr{AVFilterContext}
+    pad_idx::Cint
+    next::Ptr{AVFilterInOut}
+end
+
+"""
+    avfilter_inout_alloc()
+
+Allocate a single [`AVFilterInOut`](@ref) entry. Must be freed with [`avfilter_inout_free`](@ref)().
+
+### Returns
+allocated [`AVFilterInOut`](@ref) on success, NULL on failure.
+"""
+function avfilter_inout_alloc()
+    ccall((:avfilter_inout_alloc, libavfilter), Ptr{AVFilterInOut}, ())
+end
+
+"""
+    avfilter_inout_free(inout)
+
+Free the supplied list of [`AVFilterInOut`](@ref) and set *inout to NULL. If *inout is NULL, do nothing.
+"""
+function avfilter_inout_free(inout)
+    ccall((:avfilter_inout_free, libavfilter), Cvoid, (Ptr{Ptr{AVFilterInOut}},), inout)
+end
+
+"""
+    avfilter_graph_parse(graph, filters, inputs, outputs, log_ctx)
+
+Add a graph described by a string to a graph.
+
+!!! note
+
+    The caller must provide the lists of inputs and outputs, which therefore must be known before calling the function.
+
+!!! note
+
+    The inputs parameter describes inputs of the already existing part of the graph; i.e. from the point of view of the newly created part, they are outputs. Similarly the outputs parameter describes outputs of the already existing filters, which are provided as inputs to the parsed filters.
+
+### Parameters
+* `graph`: the filter graph where to link the parsed graph context
+* `filters`: string to be parsed
+* `inputs`: linked list to the inputs of the graph
+* `outputs`: linked list to the outputs of the graph
+### Returns
+zero on success, a negative [`AVERROR`](@ref) code on error
+"""
+function avfilter_graph_parse(graph, filters, inputs, outputs, log_ctx)
+    ccall((:avfilter_graph_parse, libavfilter), Cint, (Ptr{AVFilterGraph}, Cstring, Ptr{AVFilterInOut}, Ptr{AVFilterInOut}, Ptr{Cvoid}), graph, filters, inputs, outputs, log_ctx)
+end
+
+"""
+    avfilter_graph_parse_ptr(graph, filters, inputs, outputs, log_ctx)
+
+Add a graph described by a string to a graph.
+
+In the graph filters description, if the input label of the first filter is not specified, "in" is assumed; if the output label of the last filter is not specified, "out" is assumed.
+
+### Parameters
+* `graph`: the filter graph where to link the parsed graph context
+* `filters`: string to be parsed
+* `inputs`: pointer to a linked list to the inputs of the graph, may be NULL. If non-NULL, *inputs is updated to contain the list of open inputs after the parsing, should be freed with [`avfilter_inout_free`](@ref)().
+* `outputs`: pointer to a linked list to the outputs of the graph, may be NULL. If non-NULL, *outputs is updated to contain the list of open outputs after the parsing, should be freed with [`avfilter_inout_free`](@ref)().
+### Returns
+non negative on success, a negative [`AVERROR`](@ref) code on error
+"""
+function avfilter_graph_parse_ptr(graph, filters, inputs, outputs, log_ctx)
+    ccall((:avfilter_graph_parse_ptr, libavfilter), Cint, (Ptr{AVFilterGraph}, Cstring, Ptr{Ptr{AVFilterInOut}}, Ptr{Ptr{AVFilterInOut}}, Ptr{Cvoid}), graph, filters, inputs, outputs, log_ctx)
+end
+
+"""
+    avfilter_graph_parse2(graph, filters, inputs, outputs)
+
+Add a graph described by a string to a graph.
+
+!!! note
+
+    This function returns the inputs and outputs that are left unlinked after parsing the graph and the caller then deals with them.
+
+!!! note
+
+    This function makes no reference whatsoever to already existing parts of the graph and the inputs parameter will on return contain inputs of the newly parsed part of the graph. Analogously the outputs parameter will contain outputs of the newly created filters.
+
+### Parameters
+* `graph`:\\[in\\] the filter graph where to link the parsed graph context
+* `filters`:\\[in\\] string to be parsed
+* `inputs`:\\[out\\] a linked list of all free (unlinked) inputs of the parsed graph will be returned here. It is to be freed by the caller using [`avfilter_inout_free`](@ref)().
+* `outputs`:\\[out\\] a linked list of all free (unlinked) outputs of the parsed graph will be returned here. It is to be freed by the caller using [`avfilter_inout_free`](@ref)().
+### Returns
+zero on success, a negative [`AVERROR`](@ref) code on error
+"""
+function avfilter_graph_parse2(graph, filters, inputs, outputs)
+    ccall((:avfilter_graph_parse2, libavfilter), Cint, (Ptr{AVFilterGraph}, Cstring, Ptr{Ptr{AVFilterInOut}}, Ptr{Ptr{AVFilterInOut}}), graph, filters, inputs, outputs)
+end
+
+"""
+    AVFilterPadParams
+
+Parameters of a filter's input or output pad.
+
+Created as a child of [`AVFilterParams`](@ref) by [`avfilter_graph_segment_parse`](@ref)(). Freed in [`avfilter_graph_segment_free`](@ref)().
+"""
+struct AVFilterPadParams
+    label::Cstring
+end
 
-### Parameters
-* `graphctx`: the filter graph 
+"""
+    AVFilterParams
 
-* `log_ctx`: context used for logging 
+Parameters describing a filter to be created in a filtergraph.
 
-### Returns
->= 0 in case of success, a negative [`AVERROR`](@ref) code otherwise
+Created as a child of [`AVFilterGraphSegment`](@ref) by [`avfilter_graph_segment_parse`](@ref)(). Freed in [`avfilter_graph_segment_free`](@ref)().
 """
-function avfilter_graph_config(graphctx, log_ctx)
-    ccall((:avfilter_graph_config, libavfilter), Cint, (Ptr{AVFilterGraph}, Ptr{Cvoid}), graphctx, log_ctx)
+struct AVFilterParams
+    filter::Ptr{AVFilterContext}
+    filter_name::Cstring
+    instance_name::Cstring
+    opts::Ptr{AVDictionary}
+    inputs::Ptr{Ptr{AVFilterPadParams}}
+    nb_inputs::Cuint
+    outputs::Ptr{Ptr{AVFilterPadParams}}
+    nb_outputs::Cuint
 end
 
 """
-    avfilter_graph_free(graph)
+    AVFilterChain
 
-Free a graph, destroy its links, and set *graph to NULL. If *graph is NULL, do nothing.
+A filterchain is a list of filter specifications.
+
+Created as a child of [`AVFilterGraphSegment`](@ref) by [`avfilter_graph_segment_parse`](@ref)(). Freed in [`avfilter_graph_segment_free`](@ref)().
 """
-function avfilter_graph_free(graph)
-    ccall((:avfilter_graph_free, libavfilter), Cvoid, (Ptr{Ptr{AVFilterGraph}},), graph)
+struct AVFilterChain
+    filters::Ptr{Ptr{AVFilterParams}}
+    nb_filters::Csize_t
 end
 
 """
-    AVFilterInOut
+    AVFilterGraphSegment
 
-A linked-list of the inputs/outputs of the filter chain.
+A parsed representation of a filtergraph segment.
 
-This is mainly useful for [`avfilter_graph_parse`](@ref)() / [`avfilter_graph_parse2`](@ref)(), where it is used to communicate open (unlinked) inputs and outputs from and to the caller. This struct specifies, per each not connected pad contained in the graph, the filter context and the pad index required for establishing a link.
+A filtergraph segment is conceptually a list of filterchains, with some supplementary information (e.g. format conversion flags).
+
+Created by [`avfilter_graph_segment_parse`](@ref)(). Must be freed with [`avfilter_graph_segment_free`](@ref)().
 """
-struct AVFilterInOut
-    name::Cstring
-    filter_ctx::Ptr{AVFilterContext}
-    pad_idx::Cint
-    next::Ptr{AVFilterInOut}
+struct AVFilterGraphSegment
+    graph::Ptr{AVFilterGraph}
+    chains::Ptr{Ptr{AVFilterChain}}
+    nb_chains::Csize_t
+    scale_sws_opts::Cstring
 end
 
 """
-    avfilter_inout_alloc()
+    avfilter_graph_segment_parse(graph, graph_str, flags::Integer, seg)
 
-Allocate a single [`AVFilterInOut`](@ref) entry. Must be freed with [`avfilter_inout_free`](@ref)(). 
+Parse a textual filtergraph description into an intermediate form.
 
-### Returns
-allocated [`AVFilterInOut`](@ref) on success, NULL on failure.
+This intermediate representation is intended to be modified by the caller as described in the documentation of [`AVFilterGraphSegment`](@ref) and its children, and then applied to the graph either manually or with other avfilter\\_graph\\_segment\\_*() functions. See the documentation for [`avfilter_graph_segment_apply`](@ref)() for the canonical way to apply [`AVFilterGraphSegment`](@ref).
+
+\\retval"non-negative number" success
+
+\\retval"negative error code" failure
+
+### Parameters
+* `graph`: Filter graph the parsed segment is associated with. Will only be used for logging and similar auxiliary purposes. The graph will not be actually modified by this function - the parsing results are instead stored in seg for further processing.
+* `graph_str`: a string describing the filtergraph segment
+* `flags`: reserved for future use, caller must set to 0 for now
+* `seg`: A pointer to the newly-created [`AVFilterGraphSegment`](@ref) is written here on success. The graph segment is owned by the caller and must be freed with [`avfilter_graph_segment_free`](@ref)() before graph itself is freed.
 """
-function avfilter_inout_alloc()
-    ccall((:avfilter_inout_alloc, libavfilter), Ptr{AVFilterInOut}, ())
+function avfilter_graph_segment_parse(graph, graph_str, flags::Integer, seg)
+    ccall((:avfilter_graph_segment_parse, libavfilter), Cint, (Ptr{AVFilterGraph}, Cstring, Cint, Ptr{Ptr{AVFilterGraphSegment}}), graph, graph_str, flags, seg)
 end
 
 """
-    avfilter_inout_free(inout)
+    avfilter_graph_segment_create_filters(seg, flags::Integer)
 
-Free the supplied list of [`AVFilterInOut`](@ref) and set *inout to NULL. If *inout is NULL, do nothing.
+Create filters specified in a graph segment.
+
+Walk through the creation-pending [`AVFilterParams`](@ref) in the segment and create new filter instances for them. Creation-pending params are those where [`AVFilterParams`](@ref).filter\\_name is non-NULL (and hence [`AVFilterParams`](@ref).filter is NULL). All other [`AVFilterParams`](@ref) instances are ignored.
+
+For any filter created by this function, the corresponding [`AVFilterParams`](@ref).filter is set to the newly-created filter context, [`AVFilterParams`](@ref).filter\\_name and [`AVFilterParams`](@ref).instance\\_name are freed and set to NULL.
+
+\\retval"non-negative number" Success, all creation-pending filters were successfully created
+
+\\retvalAVERROR_FILTER_NOT_FOUND some filter's name did not correspond to a known filter
+
+\\retval"another negative error code" other failures
+
+!!! note
+
+    Calling this function multiple times is safe, as it is idempotent.
+
+### Parameters
+* `seg`: the filtergraph segment to process
+* `flags`: reserved for future use, caller must set to 0 for now
 """
-function avfilter_inout_free(inout)
-    ccall((:avfilter_inout_free, libavfilter), Cvoid, (Ptr{Ptr{AVFilterInOut}},), inout)
+function avfilter_graph_segment_create_filters(seg, flags::Integer)
+    ccall((:avfilter_graph_segment_create_filters, libavfilter), Cint, (Ptr{AVFilterGraphSegment}, Cint), seg, flags)
 end
 
 """
-    avfilter_graph_parse(graph, filters, inputs, outputs, log_ctx)
+    avfilter_graph_segment_apply_opts(seg, flags::Integer)
 
-Add a graph described by a string to a graph.
+Apply parsed options to filter instances in a graph segment.
 
-!!! note
+Walk through all filter instances in the graph segment that have option dictionaries associated with them and apply those options with [`av_opt_set_dict2`](@ref)(..., [`AV_OPT_SEARCH_CHILDREN`](@ref)). [`AVFilterParams`](@ref).opts is replaced by the dictionary output by [`av_opt_set_dict2`](@ref)(), which should be empty (NULL) if all options were successfully applied.
 
-    The caller must provide the lists of inputs and outputs, which therefore must be known before calling the function.
+If any options could not be found, this function will continue processing all other filters and finally return [`AVERROR_OPTION_NOT_FOUND`](@ref) (unless another error happens). The calling program may then deal with unapplied options as it wishes.
+
+Any creation-pending filters (see [`avfilter_graph_segment_create_filters`](@ref)()) present in the segment will cause this function to fail. [`AVFilterParams`](@ref) with no associated filter context are simply skipped.
+
+\\retval"non-negative number" Success, all options were successfully applied.
+
+\\retvalAVERROR_OPTION_NOT_FOUND some options were not found in a filter
+
+\\retval"another negative error code" other failures
 
 !!! note
 
-    The inputs parameter describes inputs of the already existing part of the graph; i.e. from the point of view of the newly created part, they are outputs. Similarly the outputs parameter describes outputs of the already existing filters, which are provided as inputs to the parsed filters.
+    Calling this function multiple times is safe, as it is idempotent.
 
 ### Parameters
-* `graph`: the filter graph where to link the parsed graph context 
+* `seg`: the filtergraph segment to process
+* `flags`: reserved for future use, caller must set to 0 for now
+"""
+function avfilter_graph_segment_apply_opts(seg, flags::Integer)
+    ccall((:avfilter_graph_segment_apply_opts, libavfilter), Cint, (Ptr{AVFilterGraphSegment}, Cint), seg, flags)
+end
 
-* `filters`: string to be parsed 
+"""
+    avfilter_graph_segment_init(seg, flags::Integer)
 
-* `inputs`: linked list to the inputs of the graph 
+Initialize all filter instances in a graph segment.
 
-* `outputs`: linked list to the outputs of the graph 
+Walk through all filter instances in the graph segment and call [`avfilter_init_dict`](@ref)(..., NULL) on those that have not been initialized yet.
 
-### Returns
-zero on success, a negative [`AVERROR`](@ref) code on error
+Any creation-pending filters (see [`avfilter_graph_segment_create_filters`](@ref)()) present in the segment will cause this function to fail. [`AVFilterParams`](@ref) with no associated filter context or whose filter context is already initialized, are simply skipped.
+
+\\retval"non-negative number" Success, all filter instances were successfully initialized
+
+\\retval"negative error code" failure
+
+!!! note
+
+    Calling this function multiple times is safe, as it is idempotent.
+
+### Parameters
+* `seg`: the filtergraph segment to process
+* `flags`: reserved for future use, caller must set to 0 for now
 """
-function avfilter_graph_parse(graph, filters, inputs, outputs, log_ctx)
-    ccall((:avfilter_graph_parse, libavfilter), Cint, (Ptr{AVFilterGraph}, Cstring, Ptr{AVFilterInOut}, Ptr{AVFilterInOut}, Ptr{Cvoid}), graph, filters, inputs, outputs, log_ctx)
+function avfilter_graph_segment_init(seg, flags::Integer)
+    ccall((:avfilter_graph_segment_init, libavfilter), Cint, (Ptr{AVFilterGraphSegment}, Cint), seg, flags)
 end
 
 """
-    avfilter_graph_parse_ptr(graph, filters, inputs, outputs, log_ctx)
+    avfilter_graph_segment_link(seg, flags::Integer, inputs, outputs)
 
-Add a graph described by a string to a graph.
+Link filters in a graph segment.
 
-In the graph filters description, if the input label of the first filter is not specified, "in" is assumed; if the output label of the last filter is not specified, "out" is assumed.
+Walk through all filter instances in the graph segment and try to link all unlinked input and output pads. Any creation-pending filters (see [`avfilter_graph_segment_create_filters`](@ref)()) present in the segment will cause this function to fail. Disabled filters and already linked pads are skipped.
 
-### Parameters
-* `graph`: the filter graph where to link the parsed graph context 
+Every filter output pad that has a corresponding [`AVFilterPadParams`](@ref) with a non-NULL label is - linked to the input with the matching label, if one exists; - exported in the outputs linked list otherwise, with the label preserved. Unlabeled outputs are - linked to the first unlinked unlabeled input in the next non-disabled filter in the chain, if one exists - exported in the ouputs linked list otherwise, with NULL label
 
-* `filters`: string to be parsed 
+Similarly, unlinked input pads are exported in the inputs linked list.
 
-* `inputs`: pointer to a linked list to the inputs of the graph, may be NULL. If non-NULL, *inputs is updated to contain the list of open inputs after the parsing, should be freed with [`avfilter_inout_free`](@ref)(). 
+\\retval"non-negative number" success
 
-* `outputs`: pointer to a linked list to the outputs of the graph, may be NULL. If non-NULL, *outputs is updated to contain the list of open outputs after the parsing, should be freed with [`avfilter_inout_free`](@ref)(). 
+\\retval"negative error code" failure
 
-### Returns
-non negative on success, a negative [`AVERROR`](@ref) code on error
+!!! note
+
+    Calling this function multiple times is safe, as it is idempotent.
+
+### Parameters
+* `seg`: the filtergraph segment to process
+* `flags`: reserved for future use, caller must set to 0 for now
+* `inputs`:\\[out\\] a linked list of all free (unlinked) inputs of the filters in this graph segment will be returned here. It is to be freed by the caller using [`avfilter_inout_free`](@ref)().
+* `outputs`:\\[out\\] a linked list of all free (unlinked) outputs of the filters in this graph segment will be returned here. It is to be freed by the caller using [`avfilter_inout_free`](@ref)().
 """
-function avfilter_graph_parse_ptr(graph, filters, inputs, outputs, log_ctx)
-    ccall((:avfilter_graph_parse_ptr, libavfilter), Cint, (Ptr{AVFilterGraph}, Cstring, Ptr{Ptr{AVFilterInOut}}, Ptr{Ptr{AVFilterInOut}}, Ptr{Cvoid}), graph, filters, inputs, outputs, log_ctx)
+function avfilter_graph_segment_link(seg, flags::Integer, inputs, outputs)
+    ccall((:avfilter_graph_segment_link, libavfilter), Cint, (Ptr{AVFilterGraphSegment}, Cint, Ptr{Ptr{AVFilterInOut}}, Ptr{Ptr{AVFilterInOut}}), seg, flags, inputs, outputs)
 end
 
 """
-    avfilter_graph_parse2(graph, filters, inputs, outputs)
+    avfilter_graph_segment_apply(seg, flags::Integer, inputs, outputs)
 
-Add a graph described by a string to a graph.
+Apply all filter/link descriptions from a graph segment to the associated filtergraph.
 
-!!! note
+This functions is currently equivalent to calling the following in sequence: - [`avfilter_graph_segment_create_filters`](@ref)(); - [`avfilter_graph_segment_apply_opts`](@ref)(); - [`avfilter_graph_segment_init`](@ref)(); - [`avfilter_graph_segment_link`](@ref)(); failing if any of them fails. This list may be extended in the future.
+
+Since the above functions are idempotent, the caller may call some of them manually, then do some custom processing on the filtergraph, then call this function to do the rest.
 
-    This function returns the inputs and outputs that are left unlinked after parsing the graph and the caller then deals with them. 
+\\retval"non-negative number" success
+
+\\retval"negative error code" failure
 
 !!! note
 
-    This function makes no reference whatsoever to already existing parts of the graph and the inputs parameter will on return contain inputs of the newly parsed part of the graph. Analogously the outputs parameter will contain outputs of the newly created filters.
+    Calling this function multiple times is safe, as it is idempotent.
 
 ### Parameters
-* `graph`:\\[in\\] the filter graph where to link the parsed graph context 
+* `seg`: the filtergraph segment to process
+* `flags`: reserved for future use, caller must set to 0 for now
+* `inputs`:\\[out\\] passed to [`avfilter_graph_segment_link`](@ref)()
+* `outputs`:\\[out\\] passed to [`avfilter_graph_segment_link`](@ref)()
+"""
+function avfilter_graph_segment_apply(seg, flags::Integer, inputs, outputs)
+    ccall((:avfilter_graph_segment_apply, libavfilter), Cint, (Ptr{AVFilterGraphSegment}, Cint, Ptr{Ptr{AVFilterInOut}}, Ptr{Ptr{AVFilterInOut}}), seg, flags, inputs, outputs)
+end
 
-* `filters`:\\[in\\] string to be parsed 
+"""
+    avfilter_graph_segment_free(seg)
 
-* `inputs`:\\[out\\] a linked list of all free (unlinked) inputs of the parsed graph will be returned here. It is to be freed by the caller using [`avfilter_inout_free`](@ref)(). 
+Free the provided [`AVFilterGraphSegment`](@ref) and everything associated with it.
 
-* `outputs`:\\[out\\] a linked list of all free (unlinked) outputs of the parsed graph will be returned here. It is to be freed by the caller using [`avfilter_inout_free`](@ref)(). 
+!!! note
 
-### Returns
-zero on success, a negative [`AVERROR`](@ref) code on error
+    The filter contexts ([`AVFilterParams`](@ref).filter) are owned by [`AVFilterGraph`](@ref) rather than [`AVFilterGraphSegment`](@ref), so they are not freed.
+
+### Parameters
+* `seg`: double pointer to the [`AVFilterGraphSegment`](@ref) to be freed. NULL will be written to this pointer on exit from this function.
 """
-function avfilter_graph_parse2(graph, filters, inputs, outputs)
-    ccall((:avfilter_graph_parse2, libavfilter), Cint, (Ptr{AVFilterGraph}, Cstring, Ptr{Ptr{AVFilterInOut}}, Ptr{Ptr{AVFilterInOut}}), graph, filters, inputs, outputs)
+function avfilter_graph_segment_free(seg)
+    ccall((:avfilter_graph_segment_free, libavfilter), Cvoid, (Ptr{Ptr{AVFilterGraphSegment}},), seg)
 end
 
 """
@@ -7646,16 +7336,11 @@ end
 Send a command to one or more filter instances.
 
 ### Parameters
-* `graph`: the filter graph 
-
-* `target`: the filter(s) to which the command should be sent "all" sends to all filters otherwise it can be a filter or filter instance name which will send the command to all matching filters. 
-
-* `cmd`: the command to send, for handling simplicity all commands must be alphanumeric only 
-
-* `arg`: the argument for the command 
-
+* `graph`: the filter graph
+* `target`: the filter(s) to which the command should be sent "all" sends to all filters otherwise it can be a filter or filter instance name which will send the command to all matching filters.
+* `cmd`: the command to send, for handling simplicity all commands must be alphanumeric only
+* `arg`: the argument for the command
 * `res`: a buffer with size res\\_size where the filter(s) can return a response.
-
 ### Returns
 >=0 on success otherwise an error code. [`AVERROR`](@ref)(ENOSYS) on unsupported commands
 """
@@ -7673,14 +7358,10 @@ Queue a command for one or more filter instances.
     As this executes commands after this function returns, no return code from the filter is provided, also [`AVFILTER_CMD_FLAG_ONE`](@ref) is not supported.
 
 ### Parameters
-* `graph`: the filter graph 
-
-* `target`: the filter(s) to which the command should be sent "all" sends to all filters otherwise it can be a filter or filter instance name which will send the command to all matching filters. 
-
-* `cmd`: the command to sent, for handling simplicity all commands must be alphanumeric only 
-
-* `arg`: the argument for the command 
-
+* `graph`: the filter graph
+* `target`: the filter(s) to which the command should be sent "all" sends to all filters otherwise it can be a filter or filter instance name which will send the command to all matching filters.
+* `cmd`: the command to sent, for handling simplicity all commands must be alphanumeric only
+* `arg`: the argument for the command
 * `ts`: time at which the command should be sent to the filter
 """
 function avfilter_graph_queue_command(graph, target, cmd, arg, flags::Integer, ts::Cdouble)
@@ -7693,10 +7374,8 @@ end
 Dump a graph into a human-readable string representation.
 
 ### Parameters
-* `graph`: the graph to dump 
-
-* `options`: formatting options; currently ignored 
-
+* `graph`: the graph to dump
+* `options`: formatting options; currently ignored
 ### Returns
 a string, or NULL in case of memory allocation failure; the string must be freed using [`av_free`](@ref)
 """
@@ -7728,12 +7407,9 @@ end
 Get a frame with filtered data from sink and put it in frame.
 
 ### Parameters
-* `ctx`: pointer to a buffersink or abuffersink filter context. 
-
-* `frame`: pointer to an allocated frame that will be filled with data. The data must be freed using [`av_frame_unref`](@ref)() / [`av_frame_free`](@ref)() 
-
+* `ctx`: pointer to a buffersink or abuffersink filter context.
+* `frame`: pointer to an allocated frame that will be filled with data. The data must be freed using [`av_frame_unref`](@ref)() / [`av_frame_free`](@ref)()
 * `flags`: a combination of AV\\_BUFFERSINK\\_FLAG\\_* flags
-
 ### Returns
 >= 0 in for success, a negative [`AVERROR`](@ref) code for failure.
 """
@@ -7741,50 +7417,6 @@ function av_buffersink_get_frame_flags(ctx, frame, flags::Integer)
     ccall((:av_buffersink_get_frame_flags, libavfilter), Cint, (Ptr{AVFilterContext}, Ptr{AVFrame}, Cint), ctx, frame, flags)
 end
 
-"""
-    AVBufferSinkParams
-
-Deprecated and unused struct to use for initializing a buffersink context.
-"""
-struct AVBufferSinkParams
-    pixel_fmts::Ptr{AVPixelFormat}
-end
-
-"""
-    av_buffersink_params_alloc()
-
-Create an [`AVBufferSinkParams`](@ref) structure.
-
-Must be freed with [`av_free`](@ref)().
-"""
-function av_buffersink_params_alloc()
-    ccall((:av_buffersink_params_alloc, libavfilter), Ptr{AVBufferSinkParams}, ())
-end
-
-"""
-    AVABufferSinkParams
-
-Deprecated and unused struct to use for initializing an abuffersink context.
-"""
-struct AVABufferSinkParams
-    sample_fmts::Ptr{AVSampleFormat}
-    channel_layouts::Ptr{Int64}
-    channel_counts::Ptr{Cint}
-    all_channel_counts::Cint
-    sample_rates::Ptr{Cint}
-end
-
-"""
-    av_abuffersink_params_alloc()
-
-Create an [`AVABufferSinkParams`](@ref) structure.
-
-Must be freed with [`av_free`](@ref)().
-"""
-function av_abuffersink_params_alloc()
-    ccall((:av_abuffersink_params_alloc, libavfilter), Ptr{AVABufferSinkParams}, ())
-end
-
 """
     av_buffersink_set_frame_size(ctx, frame_size::Integer)
 
@@ -7839,6 +7471,10 @@ function av_buffersink_get_channel_layout(ctx)
     ccall((:av_buffersink_get_channel_layout, libavfilter), UInt64, (Ptr{AVFilterContext},), ctx)
 end
 
+function av_buffersink_get_ch_layout(ctx, ch_layout)
+    ccall((:av_buffersink_get_ch_layout, libavfilter), Cint, (Ptr{AVFilterContext}, Ptr{AVChannelLayout}), ctx, ch_layout)
+end
+
 function av_buffersink_get_sample_rate(ctx)
     ccall((:av_buffersink_get_sample_rate, libavfilter), Cint, (Ptr{AVFilterContext},), ctx)
 end
@@ -7853,10 +7489,8 @@ end
 Get a frame with filtered data from sink and put it in frame.
 
 ### Parameters
-* `ctx`: pointer to a context of a buffersink or abuffersink [`AVFilter`](@ref). 
-
+* `ctx`: pointer to a context of a buffersink or abuffersink [`AVFilter`](@ref).
 * `frame`: pointer to an allocated frame that will be filled with data. The data must be freed using [`av_frame_unref`](@ref)() / [`av_frame_free`](@ref)()
-
 ### Returns
 - >= 0 if a frame was successfully returned. - [`AVERROR`](@ref)(EAGAIN) if no frames are available at this point; more input frames must be added to the filtergraph to get more output. - [`AVERROR_EOF`](@ref) if there will be no more output frames on this sink. - A different negative [`AVERROR`](@ref) code in other failure cases.
 """
@@ -7874,10 +7508,8 @@ Same as [`av_buffersink_get_frame`](@ref)(), but with the ability to specify the
     do not mix this function with [`av_buffersink_get_frame`](@ref)(). Use only one or the other with a single sink, not both.
 
 ### Parameters
-* `ctx`: pointer to a context of the abuffersink [`AVFilter`](@ref). 
-
+* `ctx`: pointer to a context of the abuffersink [`AVFilter`](@ref).
 * `frame`: pointer to an allocated frame that will be filled with data. The data must be freed using [`av_frame_unref`](@ref)() / [`av_frame_free`](@ref)() frame will contain exactly nb\\_samples audio samples, except at the end of stream, when it can contain less than nb\\_samples.
-
 ### Returns
 The return codes have the same meaning as for [`av_buffersink_get_frame`](@ref)().
 """
@@ -7886,7 +7518,7 @@ function av_buffersink_get_samples(ctx, frame, nb_samples::Integer)
 end
 
 """
-    __JL_Ctag_421
+    __JL_Ctag_393
 
 ` lavfi_buffersrc Buffer source API`
 
@@ -7894,7 +7526,7 @@ end
 
 @{
 """
-const __JL_Ctag_421 = UInt32
+const __JL_Ctag_393 = UInt32
 const AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1 % UInt32
 const AV_BUFFERSRC_FLAG_PUSH = 4 % UInt32
 const AV_BUFFERSRC_FLAG_KEEP_REF = 8 % UInt32
@@ -7918,15 +7550,32 @@ This structure contains the parameters describing the frames that will be passed
 It should be allocated with [`av_buffersrc_parameters_alloc`](@ref)() and freed with [`av_free`](@ref)(). All the allocated fields in it remain owned by the caller.
 """
 struct AVBufferSrcParameters
-    format::Cint
-    time_base::AVRational
-    width::Cint
-    height::Cint
-    sample_aspect_ratio::AVRational
-    frame_rate::AVRational
-    hw_frames_ctx::Ptr{AVBufferRef}
-    sample_rate::Cint
-    channel_layout::UInt64
+    data::NTuple{88, UInt8}
+end
+
+function Base.getproperty(x::Ptr{AVBufferSrcParameters}, f::Symbol)
+    f === :format && return Ptr{Cint}(x + 0)
+    f === :time_base && return Ptr{AVRational}(x + 4)
+    f === :width && return Ptr{Cint}(x + 12)
+    f === :height && return Ptr{Cint}(x + 16)
+    f === :sample_aspect_ratio && return Ptr{AVRational}(x + 20)
+    f === :frame_rate && return Ptr{AVRational}(x + 28)
+    f === :hw_frames_ctx && return Ptr{Ptr{AVBufferRef}}(x + 40)
+    f === :sample_rate && return Ptr{Cint}(x + 48)
+    f === :channel_layout && return Ptr{UInt64}(x + 56)
+    f === :ch_layout && return Ptr{AVChannelLayout}(x + 64)
+    return getfield(x, f)
+end
+
+function Base.getproperty(x::AVBufferSrcParameters, f::Symbol)
+    r = Ref{AVBufferSrcParameters}(x)
+    ptr = Base.unsafe_convert(Ptr{AVBufferSrcParameters}, r)
+    fptr = getproperty(ptr, f)
+    GC.@preserve r unsafe_load(fptr)
+end
+
+function Base.setproperty!(x::Ptr{AVBufferSrcParameters}, f::Symbol, v)
+    unsafe_store!(getproperty(x, f), v)
 end
 
 """
@@ -7944,10 +7593,8 @@ end
 Initialize the buffersrc or abuffersrc filter with the provided parameters. This function may be called multiple times, the later calls override the previous ones. Some of the parameters may also be set through AVOptions, then whatever method is used last takes precedence.
 
 ### Parameters
-* `ctx`: an instance of the buffersrc or abuffersrc filter 
-
-* `param`: the stream parameters. The frames later passed to this filter must conform to those parameters. All the allocated fields in param remain owned by the caller, libavfilter will make internal copies or references when necessary. 
-
+* `ctx`: an instance of the buffersrc or abuffersrc filter
+* `param`: the stream parameters. The frames later passed to this filter must conform to those parameters. All the allocated fields in param remain owned by the caller, libavfilter will make internal copies or references when necessary.
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) code on failure.
 """
@@ -7963,10 +7610,8 @@ Add a frame to the buffer source.
 This function is equivalent to [`av_buffersrc_add_frame_flags`](@ref)() with the AV\\_BUFFERSRC\\_FLAG\\_KEEP\\_REF flag.
 
 ### Parameters
-* `ctx`: an instance of the buffersrc filter 
-
+* `ctx`: an instance of the buffersrc filter
 * `frame`: frame to be added. If the frame is reference counted, this function will make a new reference to it. Otherwise the frame data will be copied.
-
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) on error
 """
@@ -7986,10 +7631,8 @@ Add a frame to the buffer source.
 This function is equivalent to [`av_buffersrc_add_frame_flags`](@ref)() without the AV\\_BUFFERSRC\\_FLAG\\_KEEP\\_REF flag.
 
 ### Parameters
-* `ctx`: an instance of the buffersrc filter 
-
+* `ctx`: an instance of the buffersrc filter
 * `frame`: frame to be added. If the frame is reference counted, this function will take ownership of the reference(s) and reset the frame. Otherwise the frame data will be copied. If this function returns an error, the input frame is not touched.
-
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) on error.
 """
@@ -8007,12 +7650,9 @@ By default, if the frame is reference-counted, this function will take ownership
 If this function returns an error, the input frame is not touched.
 
 ### Parameters
-* `buffer_src`: pointer to a buffer source context 
-
-* `frame`: a frame, or NULL to mark EOF 
-
-* `flags`: a combination of AV\\_BUFFERSRC\\_FLAG\\_* 
-
+* `buffer_src`: pointer to a buffer source context
+* `frame`: a frame, or NULL to mark EOF
+* `flags`: a combination of AV\\_BUFFERSRC\\_FLAG\\_*
 ### Returns
 >= 0 in case of success, a negative [`AVERROR`](@ref) code in case of failure
 """
@@ -8037,12 +7677,9 @@ end
 Allocate and read the payload of a packet and initialize its fields with default values.
 
 ### Parameters
-* `s`: associated IO context 
-
-* `pkt`: packet 
-
-* `size`: desired payload size 
-
+* `s`: associated IO context
+* `pkt`: packet
+* `size`: desired payload size
 ### Returns
 >0 (read size) if OK, AVERROR\\_xxx otherwise
 """
@@ -8056,12 +7693,9 @@ end
 Read data and append it to the current content of the [`AVPacket`](@ref). If pkt->size is 0 this is identical to [`av_get_packet`](@ref). Note that this uses [`av_grow_packet`](@ref) and thus involves a realloc which is inefficient. Thus this function should only be used when there is no reasonable way to know (an upper bound of) the final size.
 
 ### Parameters
-* `s`: associated IO context 
-
-* `pkt`: packet 
-
-* `size`: amount of data to read 
-
+* `s`: associated IO context
+* `pkt`: packet
+* `size`: amount of data to read
 ### Returns
 >0 (read size) if OK, AVERROR\\_xxx otherwise, previous data will not be lost even if an error occurs.
 """
@@ -8070,24 +7704,106 @@ function av_append_packet(s, pkt, size::Integer)
 end
 
 """
-    av_stream_get_r_frame_rate(s)
+    AVProbeData
+
+This structure contains the data a format has to probe a file.
+"""
+struct AVProbeData
+    filename::Cstring
+    buf::Ptr{Cuchar}
+    buf_size::Cint
+    mime_type::Cstring
+end
+
+"""
+    AVStreamParseType
 
-Accessors for some [`AVStream`](@ref) fields. These used to be provided for ABI compatibility, and do not need to be used anymore.
+@}
 """
-function av_stream_get_r_frame_rate(s)
-    ccall((:av_stream_get_r_frame_rate, libavformat), AVRational, (Ptr{AVStream},), s)
+const AVStreamParseType = UInt32
+const AVSTREAM_PARSE_NONE = 0 % UInt32
+const AVSTREAM_PARSE_FULL = 1 % UInt32
+const AVSTREAM_PARSE_HEADERS = 2 % UInt32
+const AVSTREAM_PARSE_TIMESTAMPS = 3 % UInt32
+const AVSTREAM_PARSE_FULL_ONCE = 4 % UInt32
+const AVSTREAM_PARSE_FULL_RAW = 5 % UInt32
+
+struct AVIndexEntry
+    data::NTuple{24, UInt8}
+end
+
+function Base.getproperty(x::Ptr{AVIndexEntry}, f::Symbol)
+    f === :pos && return Ptr{Int64}(x + 0)
+    f === :timestamp && return Ptr{Int64}(x + 8)
+    f === :flags && return (Ptr{Cint}(x + 16), 0, 2)
+    f === :size && return (Ptr{Cint}(x + 16), 2, 30)
+    f === :min_distance && return Ptr{Cint}(x + 20)
+    return getfield(x, f)
+end
+
+function Base.getproperty(x::AVIndexEntry, f::Symbol)
+    r = Ref{AVIndexEntry}(x)
+    ptr = Base.unsafe_convert(Ptr{AVIndexEntry}, r)
+    fptr = getproperty(ptr, f)
+    begin
+        if fptr isa Ptr
+            return GC.@preserve(r, unsafe_load(fptr))
+        else
+            (baseptr, offset, width) = fptr
+            ty = eltype(baseptr)
+            baseptr32 = convert(Ptr{UInt32}, baseptr)
+            u64 = GC.@preserve(r, unsafe_load(baseptr32))
+            if offset + width > 32
+                u64 |= GC.@preserve(r, unsafe_load(baseptr32 + 4)) << 32
+            end
+            u64 = u64 >> offset & (1 << width - 1)
+            return u64 % ty
+        end
+    end
 end
 
-function av_stream_set_r_frame_rate(s, r::AVRational)
-    ccall((:av_stream_set_r_frame_rate, libavformat), Cvoid, (Ptr{AVStream}, AVRational), s, r)
+function Base.setproperty!(x::Ptr{AVIndexEntry}, f::Symbol, v)
+    fptr = getproperty(x, f)
+    if fptr isa Ptr
+        unsafe_store!(getproperty(x, f), v)
+    else
+        (baseptr, offset, width) = fptr
+        baseptr32 = convert(Ptr{UInt32}, baseptr)
+        u64 = unsafe_load(baseptr32)
+        straddle = offset + width > 32
+        if straddle
+            u64 |= unsafe_load(baseptr32 + 4) << 32
+        end
+        mask = 1 << width - 1
+        u64 &= ~(mask << offset)
+        u64 |= (unsigned(v) & mask) << offset
+        unsafe_store!(baseptr32, u64 & typemax(UInt32))
+        if straddle
+            unsafe_store!(baseptr32 + 4, u64 >> 32)
+        end
+    end
 end
 
-function av_stream_get_recommended_encoder_configuration(s)
-    ccall((:av_stream_get_recommended_encoder_configuration, libavformat), Cstring, (Ptr{AVStream},), s)
+"""
+    av_disposition_from_string(disp)
+
+### Returns
+The AV\\_DISPOSITION\\_* flag corresponding to disp or a negative error code if disp does not correspond to a known stream disposition.
+"""
+function av_disposition_from_string(disp)
+    ccall((:av_disposition_from_string, libavformat), Cint, (Cstring,), disp)
 end
 
-function av_stream_set_recommended_encoder_configuration(s, configuration)
-    ccall((:av_stream_set_recommended_encoder_configuration, libavformat), Cvoid, (Ptr{AVStream}, Cstring), s, configuration)
+"""
+    av_disposition_to_string(disposition::Integer)
+
+### Parameters
+* `disposition`: a combination of AV\\_DISPOSITION\\_* values
+### Returns
+The string description corresponding to the lowest set bit in disposition. NULL when the lowest set bit does not correspond to a known disposition or when disposition is 0.
+"""
+function av_disposition_to_string(disposition::Integer)
+    ccall((:av_disposition_to_string, libavformat), Cstring, (Cint,), disposition)
 end
 
 function av_stream_get_parser(s)
@@ -8109,82 +7825,16 @@ end
 const AVOpenCallback = Ptr{Cvoid}
 
 """
-    av_format_get_probe_score(s)
-
-Accessors for some [`AVFormatContext`](@ref) fields. These used to be provided for ABI compatibility, and do not need to be used anymore.
-"""
-function av_format_get_probe_score(s)
-    ccall((:av_format_get_probe_score, libavformat), Cint, (Ptr{AVFormatContext},), s)
-end
-
-function av_format_get_video_codec(s)
-    ccall((:av_format_get_video_codec, libavformat), Ptr{AVCodec}, (Ptr{AVFormatContext},), s)
-end
-
-function av_format_set_video_codec(s, c)
-    ccall((:av_format_set_video_codec, libavformat), Cvoid, (Ptr{AVFormatContext}, Ptr{AVCodec}), s, c)
-end
-
-function av_format_get_audio_codec(s)
-    ccall((:av_format_get_audio_codec, libavformat), Ptr{AVCodec}, (Ptr{AVFormatContext},), s)
-end
-
-function av_format_set_audio_codec(s, c)
-    ccall((:av_format_set_audio_codec, libavformat), Cvoid, (Ptr{AVFormatContext}, Ptr{AVCodec}), s, c)
-end
-
-function av_format_get_subtitle_codec(s)
-    ccall((:av_format_get_subtitle_codec, libavformat), Ptr{AVCodec}, (Ptr{AVFormatContext},), s)
-end
-
-function av_format_set_subtitle_codec(s, c)
-    ccall((:av_format_set_subtitle_codec, libavformat), Cvoid, (Ptr{AVFormatContext}, Ptr{AVCodec}), s, c)
-end
-
-function av_format_get_data_codec(s)
-    ccall((:av_format_get_data_codec, libavformat), Ptr{AVCodec}, (Ptr{AVFormatContext},), s)
-end
-
-function av_format_set_data_codec(s, c)
-    ccall((:av_format_set_data_codec, libavformat), Cvoid, (Ptr{AVFormatContext}, Ptr{AVCodec}), s, c)
-end
-
-function av_format_get_metadata_header_padding(s)
-    ccall((:av_format_get_metadata_header_padding, libavformat), Cint, (Ptr{AVFormatContext},), s)
-end
-
-function av_format_set_metadata_header_padding(s, c::Integer)
-    ccall((:av_format_set_metadata_header_padding, libavformat), Cvoid, (Ptr{AVFormatContext}, Cint), s, c)
-end
-
-function av_format_get_opaque(s)
-    ccall((:av_format_get_opaque, libavformat), Ptr{Cvoid}, (Ptr{AVFormatContext},), s)
-end
-
-function av_format_set_opaque(s, opaque)
-    ccall((:av_format_set_opaque, libavformat), Cvoid, (Ptr{AVFormatContext}, Ptr{Cvoid}), s, opaque)
-end
-
-function av_format_get_control_message_cb(s)
-    ccall((:av_format_get_control_message_cb, libavformat), av_format_control_message, (Ptr{AVFormatContext},), s)
-end
-
-function av_format_set_control_message_cb(s, callback::av_format_control_message)
-    ccall((:av_format_set_control_message_cb, libavformat), Cvoid, (Ptr{AVFormatContext}, av_format_control_message), s, callback)
-end
+    av_format_inject_global_side_data(s)
 
-function av_format_get_open_cb(s)
-    ccall((:av_format_get_open_cb, libavformat), AVOpenCallback, (Ptr{AVFormatContext},), s)
-end
+This function will cause global side data to be injected in the next packet of each stream as well as after any subsequent seek.
 
-function av_format_set_open_cb(s, callback::AVOpenCallback)
-    ccall((:av_format_set_open_cb, libavformat), Cvoid, (Ptr{AVFormatContext}, AVOpenCallback), s, callback)
-end
+!!! note
 
-"""
-    av_format_inject_global_side_data(s)
+    global side data is always available in every [`AVStream`](@ref)'s AVCodecParameters.coded_side_data "codecpar side data" array, and in a AVCodecContext.coded_side_data "decoder's side data" array if initialized with said stream's codecpar.
 
-This function will cause global side data to be injected in the next packet of each stream as well as after any subsequent seek.
+### See also
+[`av_packet_side_data_get`](@ref)()
 """
 function av_format_inject_global_side_data(s)
     ccall((:av_format_inject_global_side_data, libavformat), Cvoid, (Ptr{AVFormatContext},), s)
@@ -8229,26 +7879,6 @@ function avformat_license()
     ccall((:avformat_license, libavformat), Cstring, ())
 end
 
-"""
-    av_register_all()
-
-Initialize libavformat and register all the muxers, demuxers and protocols. If you do not call this function, then you can select exactly which formats you want to support.
-
-### See also
-[`av_register_input_format`](@ref)(), [`av_register_output_format`](@ref)()
-"""
-function av_register_all()
-    ccall((:av_register_all, libavformat), Cvoid, ())
-end
-
-function av_register_input_format(format)
-    ccall((:av_register_input_format, libavformat), Cvoid, (Ptr{AVInputFormat},), format)
-end
-
-function av_register_output_format(format)
-    ccall((:av_register_output_format, libavformat), Cvoid, (Ptr{AVOutputFormat},), format)
-end
-
 """
     avformat_network_init()
 
@@ -8271,24 +7901,6 @@ function avformat_network_deinit()
     ccall((:avformat_network_deinit, libavformat), Cint, ())
 end
 
-"""
-    av_iformat_next(f)
-
-If f is NULL, returns the first registered input format, if f is non-NULL, returns the next registered input format after f or NULL if f is the last one.
-"""
-function av_iformat_next(f)
-    ccall((:av_iformat_next, libavformat), Ptr{AVInputFormat}, (Ptr{AVInputFormat},), f)
-end
-
-"""
-    av_oformat_next(f)
-
-If f is NULL, returns the first registered output format, if f is non-NULL, returns the next registered output format after f or NULL if f is the last one.
-"""
-function av_oformat_next(f)
-    ccall((:av_oformat_next, libavformat), Ptr{AVOutputFormat}, (Ptr{AVOutputFormat},), f)
-end
-
 """
     av_muxer_iterate(opaque)
 
@@ -8296,7 +7908,6 @@ Iterate over all registered muxers.
 
 ### Parameters
 * `opaque`: a pointer where libavformat will store the iteration state. Must point to NULL to start the iteration.
-
 ### Returns
 the next registered muxer or NULL when the iteration is finished
 """
@@ -8311,7 +7922,6 @@ Iterate over all registered demuxers.
 
 ### Parameters
 * `opaque`: a pointer where libavformat will store the iteration state. Must point to NULL to start the iteration.
-
 ### Returns
 the next registered demuxer or NULL when the iteration is finished
 """
@@ -8331,7 +7941,7 @@ end
 """
     avformat_free_context(s)
 
-Free an [`AVFormatContext`](@ref) and all its streams. 
+Free an [`AVFormatContext`](@ref) and all its streams.
 
 ### Parameters
 * `s`: context to free
@@ -8352,6 +7962,18 @@ function avformat_get_class()
     ccall((:avformat_get_class, libavformat), Ptr{AVClass}, ())
 end
 
+"""
+    av_stream_get_class()
+
+Get the [`AVClass`](@ref) for [`AVStream`](@ref). It can be used in combination with [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) for examining options.
+
+### See also
+[`av_opt_find`](@ref)().
+"""
+function av_stream_get_class()
+    ccall((:av_stream_get_class, libavformat), Ptr{AVClass}, ())
+end
+
 """
     avformat_new_stream(s, c)
 
@@ -8361,13 +7983,11 @@ When demuxing, it is called by the demuxer in read\\_header(). If the flag [`AVF
 
 When muxing, should be called by the user before [`avformat_write_header`](@ref)().
 
-User is required to call [`avcodec_close`](@ref)() and [`avformat_free_context`](@ref)() to clean up the allocation by [`avformat_new_stream`](@ref)().
+User is required to call [`avformat_free_context`](@ref)() to clean up the allocation by [`avformat_new_stream`](@ref)().
 
 ### Parameters
-* `s`: media file handle 
-
-* `c`: If non-NULL, the [`AVCodecContext`](@ref) corresponding to the new stream will be initialized to use this codec. This is needed for e.g. codec-specific defaults to be set, so codec should be provided if it is known.
-
+* `s`: media file handle
+* `c`: unused, does nothing
 ### Returns
 newly created stream or NULL on error.
 """
@@ -8380,15 +8000,13 @@ end
 
 Wrap an existing array as stream side data.
 
-### Parameters
-* `st`: stream 
-
-* `type`: side information type 
-
-* `data`: the side data array. It must be allocated with the [`av_malloc`](@ref)() family of functions. The ownership of the data is transferred to st. 
-
-* `size`: side information size 
+\\deprecated use [`av_packet_side_data_add`](@ref)() with the stream's AVCodecParameters.coded_side_data "codecpar side data"
 
+### Parameters
+* `st`: stream
+* `type`: side information type
+* `data`: the side data array. It must be allocated with the [`av_malloc`](@ref)() family of functions. The ownership of the data is transferred to st.
+* `size`: side information size
 ### Returns
 zero on success, a negative [`AVERROR`](@ref) code on failure. On failure, the stream is unchanged and the data remains owned by the caller.
 """
@@ -8397,22 +8015,21 @@ function av_stream_add_side_data(st, type::AVPacketSideDataType, data, size::Csi
 end
 
 """
-    av_stream_new_side_data(stream, type::AVPacketSideDataType, size::Integer)
+    av_stream_new_side_data(stream, type::AVPacketSideDataType, size::Csize_t)
 
 Allocate new information from stream.
 
-### Parameters
-* `stream`: stream 
-
-* `type`: desired side information type 
-
-* `size`: side information size 
+\\deprecated use [`av_packet_side_data_new`](@ref)() with the stream's AVCodecParameters.coded_side_data "codecpar side data"
 
+### Parameters
+* `stream`: stream
+* `type`: desired side information type
+* `size`: side information size
 ### Returns
 pointer to fresh allocated data or NULL otherwise
 """
-function av_stream_new_side_data(stream, type::AVPacketSideDataType, size::Integer)
-    ccall((:av_stream_new_side_data, libavformat), Ptr{UInt8}, (Ptr{AVStream}, AVPacketSideDataType, Cint), stream, type, size)
+function av_stream_new_side_data(stream, type::AVPacketSideDataType, size::Csize_t)
+    ccall((:av_stream_new_side_data, libavformat), Ptr{UInt8}, (Ptr{AVStream}, AVPacketSideDataType, Csize_t), stream, type, size)
 end
 
 """
@@ -8420,18 +8037,17 @@ end
 
 Get side information from stream.
 
-### Parameters
-* `stream`: stream 
-
-* `type`: desired side information type 
-
-* `size`: If supplied, *size will be set to the size of the side data or to zero if the desired side data is not present. 
+\\deprecated use [`av_packet_side_data_get`](@ref)() with the stream's AVCodecParameters.coded_side_data "codecpar side data"
 
+### Parameters
+* `stream`: stream
+* `type`: desired side information type
+* `size`: If supplied, *size will be set to the size of the side data or to zero if the desired side data is not present.
 ### Returns
 pointer to data if present or NULL otherwise
 """
 function av_stream_get_side_data(stream, type::AVPacketSideDataType, size)
-    ccall((:av_stream_get_side_data, libavformat), Ptr{UInt8}, (Ptr{AVStream}, AVPacketSideDataType, Ptr{Cint}), stream, type, size)
+    ccall((:av_stream_get_side_data, libavformat), Ptr{UInt8}, (Ptr{AVStream}, AVPacketSideDataType, Ptr{Csize_t}), stream, type, size)
 end
 
 function av_new_program(s, id::Integer)
@@ -8444,14 +8060,10 @@ end
 Allocate an [`AVFormatContext`](@ref) for an output format. [`avformat_free_context`](@ref)() can be used to free the context and everything allocated by the framework within it.
 
 ### Parameters
-* `*ctx`: is set to the created format context, or to NULL in case of failure 
-
-* `oformat`: format to use for allocating the context, if NULL format\\_name and filename are used instead 
-
-* `format_name`: the name of output format to use for allocating the context, if NULL filename is used instead 
-
-* `filename`: the name of the filename to use for allocating the context, may be NULL 
-
+* `ctx`: pointee is set to the created format context, or to NULL in case of failure
+* `oformat`: format to use for allocating the context, if NULL format\\_name and filename are used instead
+* `format_name`: the name of output format to use for allocating the context, if NULL filename is used instead
+* `filename`: the name of the filename to use for allocating the context, may be NULL
 ### Returns
 >= 0 in case of success, a negative [`AVERROR`](@ref) code in case of failure
 """
@@ -8474,8 +8086,7 @@ end
 Guess the file format.
 
 ### Parameters
-* `pd`: data to be probed 
-
+* `pd`: data to be probed
 * `is_opened`: Whether the file is already opened; determines whether demuxers with or without [`AVFMT_NOFILE`](@ref) are probed.
 """
 function av_probe_input_format(pd, is_opened::Integer)
@@ -8488,10 +8099,8 @@ end
 Guess the file format.
 
 ### Parameters
-* `pd`: data to be probed 
-
-* `is_opened`: Whether the file is already opened; determines whether demuxers with or without [`AVFMT_NOFILE`](@ref) are probed. 
-
+* `pd`: data to be probed
+* `is_opened`: Whether the file is already opened; determines whether demuxers with or without [`AVFMT_NOFILE`](@ref) are probed.
 * `score_max`: A probe score larger that this is required to accept a detection, the variable is set to the actual detection score afterwards. If the score is <= [`AVPROBE_SCORE_MAX`](@ref) / 4 it is recommended to retry with a larger probe buffer.
 """
 function av_probe_input_format2(pd, is_opened::Integer, score_max)
@@ -8504,8 +8113,7 @@ end
 Guess the file format.
 
 ### Parameters
-* `is_opened`: Whether the file is already opened; determines whether demuxers with or without [`AVFMT_NOFILE`](@ref) are probed. 
-
+* `is_opened`: Whether the file is already opened; determines whether demuxers with or without [`AVFMT_NOFILE`](@ref) are probed.
 * `score_ret`: The score of the best detection.
 """
 function av_probe_input_format3(pd, is_opened::Integer, score_ret)
@@ -8518,18 +8126,12 @@ end
 Probe a bytestream to determine the input format. Each time a probe returns with a score that is too low, the probe buffer size is increased and another attempt is made. When the maximum probe size is reached, the input format with the highest score is returned.
 
 ### Parameters
-* `pb`: the bytestream to probe 
-
-* `fmt`: the input format is put here 
-
-* `url`: the url of the stream 
-
-* `logctx`: the log context 
-
-* `offset`: the offset within the bytestream to probe from 
-
-* `max_probe_size`: the maximum probe buffer size (zero for default) 
-
+* `pb`: the bytestream to probe
+* `fmt`: the input format is put here
+* `url`: the url of the stream
+* `logctx`: the log context
+* `offset`: the offset within the bytestream to probe from
+* `max_probe_size`: the maximum probe buffer size (zero for default)
 ### Returns
 the score in case of success, a negative value corresponding to an the maximal score is [`AVPROBE_SCORE_MAX`](@ref) [`AVERROR`](@ref) code otherwise
 """
@@ -8556,14 +8158,10 @@ Open an input stream and read the header. The codecs are not opened. The stream
     If you want to use custom IO, preallocate the format context and set its pb field.
 
 ### Parameters
-* `ps`: Pointer to user-supplied [`AVFormatContext`](@ref) (allocated by [`avformat_alloc_context`](@ref)). May be a pointer to NULL, in which case an [`AVFormatContext`](@ref) is allocated by this function and written into ps. Note that a user-supplied [`AVFormatContext`](@ref) will be freed on failure. 
-
-* `url`: URL of the stream to open. 
-
-* `fmt`: If non-NULL, this parameter forces a specific input format. Otherwise the format is autodetected. 
-
+* `ps`: Pointer to user-supplied [`AVFormatContext`](@ref) (allocated by [`avformat_alloc_context`](@ref)). May be a pointer to NULL, in which case an [`AVFormatContext`](@ref) is allocated by this function and written into ps. Note that a user-supplied [`AVFormatContext`](@ref) will be freed on failure.
+* `url`: URL of the stream to open.
+* `fmt`: If non-NULL, this parameter forces a specific input format. Otherwise the format is autodetected.
 * `options`: A dictionary filled with [`AVFormatContext`](@ref) and demuxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.
-
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) on failure.
 """
@@ -8571,15 +8169,6 @@ function avformat_open_input(ps, url, fmt, options)
     ccall((:avformat_open_input, libavformat), Cint, (Ptr{Ptr{AVFormatContext}}, Cstring, Ptr{AVInputFormat}, Ptr{Ptr{AVDictionary}}), ps, url, fmt, options)
 end
 
-"""
-    av_demuxer_open(ic)
-
-\\deprecated Use an [`AVDictionary`](@ref) to pass options to a demuxer.
-"""
-function av_demuxer_open(ic)
-    ccall((:av_demuxer_open, libavformat), Cint, (Ptr{AVFormatContext},), ic)
-end
-
 """
     avformat_find_stream_info(ic, options)
 
@@ -8592,10 +8181,8 @@ Read packets of a media file to get stream information. This is useful for file
 \\todo Let the user decide somehow what information is needed so that we do not waste time getting stuff the user does not need.
 
 ### Parameters
-* `ic`: media file handle 
-
-* `options`: If non-NULL, an ic.nb\\_streams long array of pointers to dictionaries, where i-th member contains options for codec corresponding to i-th stream. On return each dictionary will be filled with options that were not found. 
-
+* `ic`: media file handle
+* `options`: If non-NULL, an ic.nb\\_streams long array of pointers to dictionaries, where i-th member contains options for codec corresponding to i-th stream. On return each dictionary will be filled with options that were not found.
 ### Returns
 >=0 if OK, AVERROR\\_xxx on error
 """
@@ -8609,12 +8196,9 @@ end
 Find the programs which belong to a given stream.
 
 ### Parameters
-* `ic`: media file handle 
-
-* `last`: the last found program, the search will start after this program, or from the beginning if it is NULL 
-
-* `s`: stream index 
-
+* `ic`: media file handle
+* `last`: the last found program, the search will start after this program, or from the beginning if it is NULL
+* `s`: stream index
 ### Returns
 the next program which belongs to s, NULL if no program is found or the last program is not among the programs of ic.
 """
@@ -8636,20 +8220,14 @@ Find the "best" stream in the file. The best stream is determined according to v
     If [`av_find_best_stream`](@ref) returns successfully and decoder\\_ret is not NULL, then *decoder\\_ret is guaranteed to be set to a valid [`AVCodec`](@ref).
 
 ### Parameters
-* `ic`: media file handle 
-
-* `type`: stream type: video, audio, subtitles, etc. 
-
-* `wanted_stream_nb`: user-requested stream number, or -1 for automatic selection 
-
-* `related_stream`: try to find a stream related (eg. in the same program) to this one, or -1 if none 
-
-* `decoder_ret`: if non-NULL, returns the decoder for the selected stream 
-
-* `flags`: flags; none are currently defined 
-
+* `ic`: media file handle
+* `type`: stream type: video, audio, subtitles, etc.
+* `wanted_stream_nb`: user-requested stream number, or -1 for automatic selection
+* `related_stream`: try to find a stream related (eg. in the same program) to this one, or -1 if none
+* `decoder_ret`: if non-NULL, returns the decoder for the selected stream
+* `flags`: flags; none are currently defined
 ### Returns
-the non-negative stream number in case of success, [`AVERROR_STREAM_NOT_FOUND`](@ref) if no stream with the requested type could be found, [`AVERROR_DECODER_NOT_FOUND`](@ref) if streams were found but no decoder 
+the non-negative stream number in case of success, [`AVERROR_STREAM_NOT_FOUND`](@ref) if no stream with the requested type could be found, [`AVERROR_DECODER_NOT_FOUND`](@ref) if streams were found but no decoder
 """
 function av_find_best_stream(ic, type::AVMediaType, wanted_stream_nb::Integer, related_stream::Integer, decoder_ret, flags::Integer)
     ccall((:av_find_best_stream, libavformat), Cint, (Ptr{AVFormatContext}, AVMediaType, Cint, Cint, Ptr{Ptr{AVCodec}}, Cint), ic, type, wanted_stream_nb, related_stream, decoder_ret, flags)
@@ -8681,14 +8259,10 @@ end
 Seek to the keyframe at timestamp. 'timestamp' in 'stream\\_index'.
 
 ### Parameters
-* `s`: media file handle 
-
-* `stream_index`: If stream\\_index is (-1), a default stream is selected, and timestamp is automatically converted from [`AV_TIME_BASE`](@ref) units to the stream specific time\\_base. 
-
-* `timestamp`: Timestamp in [`AVStream`](@ref).time\\_base units or, if no stream is specified, in [`AV_TIME_BASE`](@ref) units. 
-
-* `flags`: flags which select direction and seeking mode 
-
+* `s`: media file handle
+* `stream_index`: If stream\\_index is (-1), a default stream is selected, and timestamp is automatically converted from [`AV_TIME_BASE`](@ref) units to the stream specific time\\_base.
+* `timestamp`: Timestamp in [`AVStream`](@ref).time\\_base units or, if no stream is specified, in [`AV_TIME_BASE`](@ref) units.
+* `flags`: flags which select direction and seeking mode
 ### Returns
 >= 0 on success
 """
@@ -8708,18 +8282,12 @@ If flags contain [`AVSEEK_FLAG_BYTE`](@ref), then all timestamps are in bytes an
     This is part of the new seek API which is still under construction.
 
 ### Parameters
-* `s`: media file handle 
-
-* `stream_index`: index of the stream which is used as time base reference 
-
-* `min_ts`: smallest acceptable timestamp 
-
-* `ts`: target timestamp 
-
-* `max_ts`: largest acceptable timestamp 
-
-* `flags`: flags 
-
+* `s`: media file handle
+* `stream_index`: index of the stream which is used as time base reference
+* `min_ts`: smallest acceptable timestamp
+* `ts`: target timestamp
+* `max_ts`: largest acceptable timestamp
+* `flags`: flags
 ### Returns
 >=0 on success, error code otherwise
 """
@@ -8737,8 +8305,7 @@ The set of streams, the detected duration, stream parameters and codecs do not c
 This does not flush the [`AVIOContext`](@ref) (s->pb). If necessary, call [`avio_flush`](@ref)(s->pb) before calling this function.
 
 ### Parameters
-* `s`: media file handle 
-
+* `s`: media file handle
 ### Returns
 >=0 on success, error code otherwise
 """
@@ -8780,16 +8347,17 @@ end
 
 Allocate the stream private data and write the stream header to an output media file.
 
-### Parameters
-* `s`: Media file handle, must be allocated with [`avformat_alloc_context`](@ref)(). Its oformat field must be set to the desired output format; Its pb field must be set to an already opened [`AVIOContext`](@ref). 
+\\retvalAVSTREAM_INIT_IN_WRITE_HEADER On success, if the codec had not already been fully initialized in [`avformat_init_output`](@ref)().
 
-* `options`: An [`AVDictionary`](@ref) filled with [`AVFormatContext`](@ref) and muxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.
+\\retvalAVSTREAM_INIT_IN_INIT_OUTPUT On success, if the codec had already been fully initialized in [`avformat_init_output`](@ref)().
 
-### Returns
-[`AVSTREAM_INIT_IN_WRITE_HEADER`](@ref) on success if the codec had not already been fully initialized in avformat\\_init, [`AVSTREAM_INIT_IN_INIT_OUTPUT`](@ref) on success if the codec had already been fully initialized in avformat\\_init, negative [`AVERROR`](@ref) on failure.
+\\retvalAVERROR A negative [`AVERROR`](@ref) on failure.
 
+### Parameters
+* `s`: Media file handle, must be allocated with [`avformat_alloc_context`](@ref)(). Its AVFormatContext.oformat "oformat" field must be set to the desired output format; Its AVFormatContext.pb "pb" field must be set to an already opened ::[`AVIOContext`](@ref).
+* `options`: An ::[`AVDictionary`](@ref) filled with [`AVFormatContext`](@ref) and muxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.
 ### See also
-[`av_opt_find`](@ref), [`av_dict_set`](@ref), [`avio_open`](@ref), [`av_oformat_next`](@ref), [`avformat_init_output`](@ref).
+[`av_opt_find`](@ref), [`av_dict_set`](@ref), [`avio_open`](@ref), av\\_oformat\\_next, [`avformat_init_output`](@ref).
 """
 function avformat_write_header(s, options)
     ccall((:avformat_write_header, libavformat), Cint, (Ptr{AVFormatContext}, Ptr{Ptr{AVDictionary}}), s, options)
@@ -8798,18 +8366,19 @@ end
 """
     avformat_init_output(s, options)
 
-Allocate the stream private data and initialize the codec, but do not write the header. May optionally be used before [`avformat_write_header`](@ref) to initialize stream parameters before actually writing the header. If using this function, do not pass the same options to [`avformat_write_header`](@ref).
+Allocate the stream private data and initialize the codec, but do not write the header. May optionally be used before [`avformat_write_header`](@ref)() to initialize stream parameters before actually writing the header. If using this function, do not pass the same options to [`avformat_write_header`](@ref)().
 
-### Parameters
-* `s`: Media file handle, must be allocated with [`avformat_alloc_context`](@ref)(). Its oformat field must be set to the desired output format; Its pb field must be set to an already opened [`AVIOContext`](@ref). 
+\\retvalAVSTREAM_INIT_IN_WRITE_HEADER On success, if the codec requires [`avformat_write_header`](@ref) to fully initialize.
 
-* `options`: An [`AVDictionary`](@ref) filled with [`AVFormatContext`](@ref) and muxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.
+\\retvalAVSTREAM_INIT_IN_INIT_OUTPUT On success, if the codec has been fully initialized.
 
-### Returns
-[`AVSTREAM_INIT_IN_WRITE_HEADER`](@ref) on success if the codec requires [`avformat_write_header`](@ref) to fully initialize, [`AVSTREAM_INIT_IN_INIT_OUTPUT`](@ref) on success if the codec has been fully initialized, negative [`AVERROR`](@ref) on failure.
+\\retvalAVERROR Anegative [`AVERROR`](@ref) on failure.
 
+### Parameters
+* `s`: Media file handle, must be allocated with [`avformat_alloc_context`](@ref)(). Its AVFormatContext.oformat "oformat" field must be set to the desired output format; Its AVFormatContext.pb "pb" field must be set to an already opened ::[`AVIOContext`](@ref).
+* `options`: An ::[`AVDictionary`](@ref) filled with [`AVFormatContext`](@ref) and muxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.
 ### See also
-[`av_opt_find`](@ref), [`av_dict_set`](@ref), [`avio_open`](@ref), [`av_oformat_next`](@ref), [`avformat_write_header`](@ref).
+[`av_opt_find`](@ref), [`av_dict_set`](@ref), [`avio_open`](@ref), av\\_oformat\\_next, [`avformat_write_header`](@ref).
 """
 function avformat_init_output(s, options)
     ccall((:avformat_init_output, libavformat), Cint, (Ptr{AVFormatContext}, Ptr{Ptr{AVDictionary}}), s, options)
@@ -8823,13 +8392,10 @@ Write a packet to an output media file.
 This function passes the packet directly to the muxer, without any buffering or reordering. The caller is responsible for correctly interleaving the packets if the format requires it. Callers that want libavformat to handle the interleaving should call [`av_interleaved_write_frame`](@ref)() instead of this function.
 
 ### Parameters
-* `s`: media file handle 
-
-* `pkt`: The packet containing the data to be written. Note that unlike [`av_interleaved_write_frame`](@ref)(), this function does not take ownership of the packet passed to it (though some muxers may make an internal reference to the input packet). <br> This parameter can be NULL (at any time, not just at the end), in order to immediately flush data buffered within the muxer, for muxers that buffer up data internally before writing it to the output. <br> Packet's AVPacket.stream_index "stream\\_index" field must be set to the index of the corresponding stream in AVFormatContext.streams "s->streams". <br> The timestamps (AVPacket.pts "pts", AVPacket.dts "dts") must be set to correct values in the stream's timebase (unless the output format is flagged with the [`AVFMT_NOTIMESTAMPS`](@ref) flag, then they can be set to [`AV_NOPTS_VALUE`](@ref)). The dts for subsequent packets passed to this function must be strictly increasing when compared in their respective timebases (unless the output format is flagged with the [`AVFMT_TS_NONSTRICT`](@ref), then they merely have to be nondecreasing). AVPacket.duration "duration") should also be set if known. 
-
+* `s`: media file handle
+* `pkt`: The packet containing the data to be written. Note that unlike [`av_interleaved_write_frame`](@ref)(), this function does not take ownership of the packet passed to it (though some muxers may make an internal reference to the input packet). <br> This parameter can be NULL (at any time, not just at the end), in order to immediately flush data buffered within the muxer, for muxers that buffer up data internally before writing it to the output. <br> Packet's AVPacket.stream_index "stream\\_index" field must be set to the index of the corresponding stream in AVFormatContext.streams "s->streams". <br> The timestamps (AVPacket.pts "pts", AVPacket.dts "dts") must be set to correct values in the stream's timebase (unless the output format is flagged with the [`AVFMT_NOTIMESTAMPS`](@ref) flag, then they can be set to [`AV_NOPTS_VALUE`](@ref)). The dts for subsequent packets passed to this function must be strictly increasing when compared in their respective timebases (unless the output format is flagged with the [`AVFMT_TS_NONSTRICT`](@ref), then they merely have to be nondecreasing). AVPacket.duration "duration") should also be set if known.
 ### Returns
 < 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush
-
 ### See also
 [`av_interleaved_write_frame`](@ref)()
 """
@@ -8842,18 +8408,15 @@ end
 
 Write a packet to an output media file ensuring correct interleaving.
 
-This function will buffer the packets internally as needed to make sure the packets in the output file are properly interleaved in the order of increasing dts. Callers doing their own interleaving should call [`av_write_frame`](@ref)() instead of this function.
+This function will buffer the packets internally as needed to make sure the packets in the output file are properly interleaved, usually ordered by increasing dts. Callers doing their own interleaving should call [`av_write_frame`](@ref)() instead of this function.
 
 Using this function instead of [`av_write_frame`](@ref)() can give muxers advance knowledge of future packets, improving e.g. the behaviour of the mp4 muxer for VFR content in fragmenting mode.
 
 ### Parameters
-* `s`: media file handle 
-
-* `pkt`: The packet containing the data to be written. <br> If the packet is reference-counted, this function will take ownership of this reference and unreference it later when it sees fit. The caller must not access the data through this reference after this function returns. If the packet is not reference-counted, libavformat will make a copy. <br> This parameter can be NULL (at any time, not just at the end), to flush the interleaving queues. <br> Packet's AVPacket.stream_index "stream\\_index" field must be set to the index of the corresponding stream in AVFormatContext.streams "s->streams". <br> The timestamps (AVPacket.pts "pts", AVPacket.dts "dts") must be set to correct values in the stream's timebase (unless the output format is flagged with the [`AVFMT_NOTIMESTAMPS`](@ref) flag, then they can be set to [`AV_NOPTS_VALUE`](@ref)). The dts for subsequent packets in one stream must be strictly increasing (unless the output format is flagged with the [`AVFMT_TS_NONSTRICT`](@ref), then they merely have to be nondecreasing). AVPacket.duration "duration") should also be set if known.
-
+* `s`: media file handle
+* `pkt`: The packet containing the data to be written. <br> If the packet is reference-counted, this function will take ownership of this reference and unreference it later when it sees fit. If the packet is not reference-counted, libavformat will make a copy. The returned packet will be blank (as if returned from [`av_packet_alloc`](@ref)()), even on error. <br> This parameter can be NULL (at any time, not just at the end), to flush the interleaving queues. <br> Packet's AVPacket.stream_index "stream\\_index" field must be set to the index of the corresponding stream in AVFormatContext.streams "s->streams". <br> The timestamps (AVPacket.pts "pts", AVPacket.dts "dts") must be set to correct values in the stream's timebase (unless the output format is flagged with the [`AVFMT_NOTIMESTAMPS`](@ref) flag, then they can be set to [`AV_NOPTS_VALUE`](@ref)). The dts for subsequent packets in one stream must be strictly increasing (unless the output format is flagged with the [`AVFMT_TS_NONSTRICT`](@ref), then they merely have to be nondecreasing). AVPacket.duration "duration" should also be set if known.
 ### Returns
-0 on success, a negative [`AVERROR`](@ref) on error. Libavformat will always take care of freeing the packet, even if this function fails.
-
+0 on success, a negative [`AVERROR`](@ref) on error.
 ### See also
 [`av_write_frame`](@ref)(), [`AVFormatContext`](@ref).max\\_interleave\\_delta
 """
@@ -8912,8 +8475,7 @@ Write the stream trailer to an output media file and free the file private data.
 May only be called after a successful call to [`avformat_write_header`](@ref).
 
 ### Parameters
-* `s`: media file handle 
-
+* `s`: media file handle
 ### Returns
 0 if OK, AVERROR\\_xxx on error
 """
@@ -8927,10 +8489,8 @@ end
 Return the output format in the list of registered output formats which best matches the provided parameters, or return NULL if there is no match.
 
 ### Parameters
-* `short_name`: if non-NULL checks if short\\_name matches with the names of the registered formats 
-
-* `filename`: if non-NULL checks if filename terminates with the extensions of the registered formats 
-
+* `short_name`: if non-NULL checks if short\\_name matches with the names of the registered formats
+* `filename`: if non-NULL checks if filename terminates with the extensions of the registered formats
 * `mime_type`: if non-NULL checks if mime\\_type matches with the MIME type of the registered formats
 """
 function av_guess_format(short_name, filename, mime_type)
@@ -8949,19 +8509,21 @@ end
 """
     av_get_output_timestamp(s, stream::Integer, dts, wall)
 
-Get timing information for the data currently output. The exact meaning of "currently output" depends on the format. It is mostly relevant for devices that have an internal buffer and/or work in real time. 
+Get timing information for the data currently output. The exact meaning of "currently output" depends on the format. It is mostly relevant for devices that have an internal buffer and/or work in real time.
 
-### Parameters
-* `s`: media file handle 
+\\retval0 Success
 
-* `stream`: stream in the media file 
+\\retvalAVERROR(ENOSYS) The format does not support it
 
-* `dts`:\\[out\\] DTS of the last packet output for the stream, in stream time\\_base units 
+!!! note
 
-* `wall`:\\[out\\] absolute time when that packet whas output, in microsecond 
+    Some formats or devices may not allow to measure dts and wall atomically.
 
-### Returns
-0 if OK, [`AVERROR`](@ref)(ENOSYS) if the format does not support it Note: some formats or devices may not allow to measure dts and wall atomically.
+### Parameters
+* `s`: media file handle
+* `stream`: stream in the media file
+* `dts`:\\[out\\] DTS of the last packet output for the stream, in stream time\\_base units
+* `wall`:\\[out\\] absolute time when that packet whas output, in microsecond
 """
 function av_get_output_timestamp(s, stream::Integer, dts, wall)
     ccall((:av_get_output_timestamp, libavformat), Cint, (Ptr{AVFormatContext}, Cint, Ptr{Int64}, Ptr{Int64}), s, stream, dts, wall)
@@ -8973,12 +8535,9 @@ end
 Send a nice hexadecimal dump of a buffer to the specified file stream.
 
 ### Parameters
-* `f`: The file stream pointer where the dump should be sent to. 
-
-* `buf`: buffer 
-
+* `f`: The file stream pointer where the dump should be sent to.
+* `buf`: buffer
 * `size`: buffer size
-
 ### See also
 [`av_hex_dump_log`](@ref), [`av_pkt_dump2`](@ref), [`av_pkt_dump_log2`](@ref)
 """
@@ -8992,14 +8551,10 @@ end
 Send a nice hexadecimal dump of a buffer to the log.
 
 ### Parameters
-* `avcl`: A pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct. 
-
-* `level`: The importance level of the message, lower values signifying higher importance. 
-
-* `buf`: buffer 
-
+* `avcl`: A pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct.
+* `level`: The importance level of the message, lower values signifying higher importance.
+* `buf`: buffer
 * `size`: buffer size
-
 ### See also
 [`av_hex_dump`](@ref), [`av_pkt_dump2`](@ref), [`av_pkt_dump_log2`](@ref)
 """
@@ -9013,12 +8568,9 @@ end
 Send a nice dump of a packet to the specified file stream.
 
 ### Parameters
-* `f`: The file stream pointer where the dump should be sent to. 
-
-* `pkt`: packet to dump 
-
-* `dump_payload`: True if the payload must be displayed, too. 
-
+* `f`: The file stream pointer where the dump should be sent to.
+* `pkt`: packet to dump
+* `dump_payload`: True if the payload must be displayed, too.
 * `st`: [`AVStream`](@ref) that the packet belongs to
 """
 function av_pkt_dump2(f, pkt, dump_payload::Integer, st)
@@ -9031,14 +8583,10 @@ end
 Send a nice dump of a packet to the log.
 
 ### Parameters
-* `avcl`: A pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct. 
-
-* `level`: The importance level of the message, lower values signifying higher importance. 
-
-* `pkt`: packet to dump 
-
-* `dump_payload`: True if the payload must be displayed, too. 
-
+* `avcl`: A pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct.
+* `level`: The importance level of the message, lower values signifying higher importance.
+* `pkt`: packet to dump
+* `dump_payload`: True if the payload must be displayed, too.
 * `st`: [`AVStream`](@ref) that the packet belongs to
 """
 function av_pkt_dump_log2(avcl, level::Integer, pkt, dump_payload::Integer, st)
@@ -9051,8 +8599,7 @@ end
 Get the [`AVCodecID`](@ref) for the given codec tag tag. If no codec id is found returns AV\\_CODEC\\_ID\\_NONE.
 
 ### Parameters
-* `tags`: list of supported codec\\_id-codec\\_tag pairs, as stored in [`AVInputFormat`](@ref).codec\\_tag and [`AVOutputFormat`](@ref).codec\\_tag 
-
+* `tags`: list of supported codec\\_id-codec\\_tag pairs, as stored in [`AVInputFormat`](@ref).codec\\_tag and [`AVOutputFormat`](@ref).codec\\_tag
 * `tag`: codec tag to match to a codec ID
 """
 function av_codec_get_id(tags, tag::Integer)
@@ -9065,8 +8612,7 @@ end
 Get the codec tag for the given codec id id. If no codec tag is found returns 0.
 
 ### Parameters
-* `tags`: list of supported codec\\_id-codec\\_tag pairs, as stored in [`AVInputFormat`](@ref).codec\\_tag and [`AVOutputFormat`](@ref).codec\\_tag 
-
+* `tags`: list of supported codec\\_id-codec\\_tag pairs, as stored in [`AVInputFormat`](@ref).codec\\_tag and [`AVOutputFormat`](@ref).codec\\_tag
 * `id`: codec ID to match to a codec tag
 """
 function av_codec_get_tag(tags, id::AVCodecID)
@@ -9079,12 +8625,9 @@ end
 Get the codec tag for the given codec id.
 
 ### Parameters
-* `tags`: list of supported codec\\_id - codec\\_tag pairs, as stored in [`AVInputFormat`](@ref).codec\\_tag and [`AVOutputFormat`](@ref).codec\\_tag 
-
-* `id`: codec id that should be searched for in the list 
-
-* `tag`: A pointer to the found tag 
-
+* `tags`: list of supported codec\\_id - codec\\_tag pairs, as stored in [`AVInputFormat`](@ref).codec\\_tag and [`AVOutputFormat`](@ref).codec\\_tag
+* `id`: codec id that should be searched for in the list
+* `tag`: A pointer to the found tag
 ### Returns
 0 if id was not found in tags, > 0 if it was found
 """
@@ -9102,12 +8645,9 @@ end
 Get the index for a specific timestamp.
 
 ### Parameters
-* `st`: stream that the timestamp belongs to 
-
-* `timestamp`: timestamp to retrieve the index for 
-
-* `flags`: if [`AVSEEK_FLAG_BACKWARD`](@ref) then the returned index will correspond to the timestamp which is <= the requested one, if backward is 0, then it will be >= if [`AVSEEK_FLAG_ANY`](@ref) seek to any frame, only keyframes otherwise 
-
+* `st`: stream that the timestamp belongs to
+* `timestamp`: timestamp to retrieve the index for
+* `flags`: if [`AVSEEK_FLAG_BACKWARD`](@ref) then the returned index will correspond to the timestamp which is <= the requested one, if backward is 0, then it will be >= if [`AVSEEK_FLAG_ANY`](@ref) seek to any frame, only keyframes otherwise
 ### Returns
 < 0 if no such timestamp could be found
 """
@@ -9116,43 +8656,87 @@ function av_index_search_timestamp(st, timestamp::Int64, flags::Integer)
 end
 
 """
-    av_add_index_entry(st, pos::Int64, timestamp::Int64, size::Integer, distance::Integer, flags::Integer)
+    avformat_index_get_entries_count(st)
 
-Add an index entry into a sorted list. Update the entry if the list already contains it.
+Get the index entry count for the given [`AVStream`](@ref).
 
 ### Parameters
-* `timestamp`: timestamp in the time base of the given stream
+* `st`: stream
+### Returns
+the number of index entries in the stream
 """
-function av_add_index_entry(st, pos::Int64, timestamp::Int64, size::Integer, distance::Integer, flags::Integer)
-    ccall((:av_add_index_entry, libavformat), Cint, (Ptr{AVStream}, Int64, Int64, Cint, Cint, Cint), st, pos, timestamp, size, distance, flags)
+function avformat_index_get_entries_count(st)
+    ccall((:avformat_index_get_entries_count, libavformat), Cint, (Ptr{AVStream},), st)
 end
 
 """
-    av_url_split(proto, proto_size::Integer, authorization, authorization_size::Integer, hostname, hostname_size::Integer, port_ptr, path, path_size::Integer, url)
+    avformat_index_get_entry(st, idx::Integer)
 
-Split a URL string into components.
+Get the [`AVIndexEntry`](@ref) corresponding to the given index.
 
-The pointers to buffers for storing individual components may be null, in order to ignore that component. Buffers for components not found are set to empty strings. If the port is not found, it is set to a negative value.
+!!! note
+
+    The pointer returned by this function is only guaranteed to be valid until any function that takes the stream or the parent [`AVFormatContext`](@ref) as input argument is called.
 
 ### Parameters
-* `proto`: the buffer for the protocol 
+* `st`: Stream containing the requested [`AVIndexEntry`](@ref).
+* `idx`: The desired index.
+### Returns
+A pointer to the requested [`AVIndexEntry`](@ref) if it exists, NULL otherwise.
+"""
+function avformat_index_get_entry(st, idx::Integer)
+    ccall((:avformat_index_get_entry, libavformat), Ptr{AVIndexEntry}, (Ptr{AVStream}, Cint), st, idx)
+end
+
+"""
+    avformat_index_get_entry_from_timestamp(st, wanted_timestamp::Int64, flags::Integer)
+
+Get the [`AVIndexEntry`](@ref) corresponding to the given timestamp.
 
-* `proto_size`: the size of the proto buffer 
+!!! note
+
+    The pointer returned by this function is only guaranteed to be valid until any function that takes the stream or the parent [`AVFormatContext`](@ref) as input argument is called.
 
-* `authorization`: the buffer for the authorization 
+### Parameters
+* `st`: Stream containing the requested [`AVIndexEntry`](@ref).
+* `wanted_timestamp`: Timestamp to retrieve the index entry for.
+* `flags`: If [`AVSEEK_FLAG_BACKWARD`](@ref) then the returned entry will correspond to the timestamp which is <= the requested one, if backward is 0, then it will be >= if [`AVSEEK_FLAG_ANY`](@ref) seek to any frame, only keyframes otherwise.
+### Returns
+A pointer to the requested [`AVIndexEntry`](@ref) if it exists, NULL otherwise.
+"""
+function avformat_index_get_entry_from_timestamp(st, wanted_timestamp::Int64, flags::Integer)
+    ccall((:avformat_index_get_entry_from_timestamp, libavformat), Ptr{AVIndexEntry}, (Ptr{AVStream}, Int64, Cint), st, wanted_timestamp, flags)
+end
 
-* `authorization_size`: the size of the authorization buffer 
+"""
+    av_add_index_entry(st, pos::Int64, timestamp::Int64, size::Integer, distance::Integer, flags::Integer)
 
-* `hostname`: the buffer for the host name 
+Add an index entry into a sorted list. Update the entry if the list already contains it.
 
-* `hostname_size`: the size of the hostname buffer 
+### Parameters
+* `timestamp`: timestamp in the time base of the given stream
+"""
+function av_add_index_entry(st, pos::Int64, timestamp::Int64, size::Integer, distance::Integer, flags::Integer)
+    ccall((:av_add_index_entry, libavformat), Cint, (Ptr{AVStream}, Int64, Int64, Cint, Cint, Cint), st, pos, timestamp, size, distance, flags)
+end
 
-* `port_ptr`: a pointer to store the port number in 
+"""
+    av_url_split(proto, proto_size::Integer, authorization, authorization_size::Integer, hostname, hostname_size::Integer, port_ptr, path, path_size::Integer, url)
 
-* `path`: the buffer for the path 
+Split a URL string into components.
 
-* `path_size`: the size of the path buffer 
+The pointers to buffers for storing individual components may be null, in order to ignore that component. Buffers for components not found are set to empty strings. If the port is not found, it is set to a negative value.
 
+### Parameters
+* `proto`: the buffer for the protocol
+* `proto_size`: the size of the proto buffer
+* `authorization`: the buffer for the authorization
+* `authorization_size`: the size of the authorization buffer
+* `hostname`: the buffer for the host name
+* `hostname_size`: the size of the hostname buffer
+* `port_ptr`: a pointer to store the port number in
+* `path`: the buffer for the path
+* `path_size`: the size of the path buffer
 * `url`: the URL to split
 """
 function av_url_split(proto, proto_size::Integer, authorization, authorization_size::Integer, hostname, hostname_size::Integer, port_ptr, path, path_size::Integer, url)
@@ -9165,12 +8749,9 @@ end
 Print detailed information about the input or output format, such as duration, bitrate, streams, container, programs, metadata, side data, codec and time base.
 
 ### Parameters
-* `ic`: the context to analyze 
-
-* `index`: index of the stream to dump information about 
-
-* `url`: the URL to print, such as source or destination file 
-
+* `ic`: the context to analyze
+* `index`: index of the stream to dump information about
+* `url`: the URL to print, such as source or destination file
 * `is_output`: Select whether the specified context is an input(0) or output(1)
 """
 function av_dump_format(ic, index::Integer, url, is_output::Integer)
@@ -9185,16 +8766,11 @@ Return in 'buf' the path with 'd' replaced by a number.
 Also handles the '0nd' format where 'n' is the total number of digits and '%%'.
 
 ### Parameters
-* `buf`: destination buffer 
-
-* `buf_size`: destination buffer size 
-
-* `path`: numbered sequence string 
-
-* `number`: frame number 
-
-* `flags`: AV\\_FRAME\\_FILENAME\\_FLAGS\\_* 
-
+* `buf`: destination buffer
+* `buf_size`: destination buffer size
+* `path`: numbered sequence string
+* `number`: frame number
+* `flags`: AV\\_FRAME\\_FILENAME\\_FLAGS\\_*
 ### Returns
 0 if OK, -1 on format error
 """
@@ -9212,8 +8788,7 @@ end
 Check whether filename actually is a numbered sequence generator.
 
 ### Parameters
-* `filename`: possible numbered sequence string 
-
+* `filename`: possible numbered sequence string
 ### Returns
 1 if a valid numbered sequence string, 0 otherwise
 """
@@ -9229,14 +8804,10 @@ Generate an SDP for an RTP session.
 Note, this overwrites the id values of AVStreams in the muxer contexts for getting unique dynamic payload types.
 
 ### Parameters
-* `ac`: array of AVFormatContexts describing the RTP streams. If the array is composed by only one context, such context can contain multiple AVStreams (one [`AVStream`](@ref) per RTP stream). Otherwise, all the contexts in the array (an [`AVCodecContext`](@ref) per RTP stream) must contain only one [`AVStream`](@ref). 
-
-* `n_files`: number of AVCodecContexts contained in ac 
-
-* `buf`: buffer where the SDP will be stored (must be allocated by the caller) 
-
-* `size`: the size of the buffer 
-
+* `ac`: array of AVFormatContexts describing the RTP streams. If the array is composed by only one context, such context can contain multiple AVStreams (one [`AVStream`](@ref) per RTP stream). Otherwise, all the contexts in the array (an [`AVCodecContext`](@ref) per RTP stream) must contain only one [`AVStream`](@ref).
+* `n_files`: number of AVCodecContexts contained in ac
+* `buf`: buffer where the SDP will be stored (must be allocated by the caller)
+* `size`: the size of the buffer
 ### Returns
 0 if OK, AVERROR\\_xxx on error
 """
@@ -9250,8 +8821,7 @@ end
 Return a positive value if the given filename has one of the given extensions, 0 otherwise.
 
 ### Parameters
-* `filename`: file name to check against the given extensions 
-
+* `filename`: file name to check against the given extensions
 * `extensions`: a comma-separated list of filename extensions
 """
 function av_match_ext(filename, extensions)
@@ -9264,12 +8834,9 @@ end
 Test if the given container can store a codec.
 
 ### Parameters
-* `ofmt`: container to check for compatibility 
-
-* `codec_id`: codec to potentially store in container 
-
+* `ofmt`: container to check for compatibility
+* `codec_id`: codec to potentially store in container
 * `std_compliance`: standards compliance level, one of FF\\_COMPLIANCE\\_*
-
 ### Returns
 1 if codec with ID codec\\_id can be stored in ofmt, 0 if it cannot. A negative number if this information is not available.
 """
@@ -9282,7 +8849,7 @@ end
 
 ` riff_fourcc RIFF FourCCs`
 
-@{ Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are meant to be passed to [`av_codec_get_id`](@ref)()/[`av_codec_get_tag`](@ref)() as in the following code: 
+@{ Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are meant to be passed to [`av_codec_get_id`](@ref)()/[`av_codec_get_tag`](@ref)() as in the following code:
 
 ```c++
  uint32_t tag = MKTAG('H', '2', '6', '4');
@@ -9337,12 +8904,9 @@ Since the frame aspect ratio is set by the codec but the stream aspect ratio is
 Basic logic is to use the stream aspect ratio if it is set to something sane otherwise use the frame aspect ratio. This way a container setting, which is usually easy to modify can override the coded value in the frames.
 
 ### Parameters
-* `format`: the format context which the stream is part of 
-
-* `stream`: the stream which the frame is part of 
-
-* `frame`: the frame with the aspect ratio to be determined 
-
+* `format`: the format context which the stream is part of
+* `stream`: the stream which the frame is part of
+* `frame`: the frame with the aspect ratio to be determined
 ### Returns
 the guessed (valid) sample\\_aspect\\_ratio, 0/1 if no idea
 """
@@ -9356,12 +8920,9 @@ end
 Guess the frame rate, based on both the container and codec information.
 
 ### Parameters
-* `ctx`: the format context which the stream is part of 
-
-* `stream`: the stream which the frame is part of 
-
-* `frame`: the frame for which the frame rate should be determined, may be NULL 
-
+* `ctx`: the format context which the stream is part of
+* `stream`: the stream which the frame is part of
+* `frame`: the frame for which the frame rate should be determined, may be NULL
 ### Returns
 the guessed (valid) frame rate, 0/1 if no idea
 """
@@ -9383,31 +8944,12 @@ See the "stream specifiers" chapter in the documentation for the syntax of spec.
 ### Returns
 >0 if st is matched by spec; 0 if st is not matched by spec; [`AVERROR`](@ref) code if spec is invalid
 """
-function avformat_match_stream_specifier(s, st, spec)
-    ccall((:avformat_match_stream_specifier, libavformat), Cint, (Ptr{AVFormatContext}, Ptr{AVStream}, Cstring), s, st, spec)
-end
-
-function avformat_queue_attached_pictures(s)
-    ccall((:avformat_queue_attached_pictures, libavformat), Cint, (Ptr{AVFormatContext},), s)
-end
-
-"""
-    av_apply_bitstream_filters(codec, pkt, bsfc)
-
-Apply a list of bitstream filters to a packet.
-
-### Parameters
-* `codec`: [`AVCodecContext`](@ref), usually from an [`AVStream`](@ref) 
-
-* `pkt`: the packet to apply filters to. If, on success, the returned packet has size == 0 and side\\_data\\_elems == 0, it indicates that the packet should be dropped 
-
-* `bsfc`: a NULL-terminated list of filters to apply 
-
-### Returns
->=0 on success; [`AVERROR`](@ref) code on failure
-"""
-function av_apply_bitstream_filters(codec, pkt, bsfc)
-    ccall((:av_apply_bitstream_filters, libavformat), Cint, (Ptr{AVCodecContext}, Ptr{AVPacket}, Ptr{AVBitStreamFilterContext}), codec, pkt, bsfc)
+function avformat_match_stream_specifier(s, st, spec)
+    ccall((:avformat_match_stream_specifier, libavformat), Cint, (Ptr{AVFormatContext}, Ptr{AVStream}, Cstring), s, st, spec)
+end
+
+function avformat_queue_attached_pictures(s)
+    ccall((:avformat_queue_attached_pictures, libavformat), Cint, (Ptr{AVFormatContext},), s)
 end
 
 const AVTimebaseSource = Int32
@@ -9424,12 +8966,9 @@ Transfer internal timing information from one stream to another.
 This function is useful when doing stream copy.
 
 ### Parameters
-* `ofmt`: target output format for ost 
-
-* `ost`: output stream which needs timings copy and adjustments 
-
-* `ist`: reference input stream to copy timings from 
-
+* `ofmt`: target output format for ost
+* `ost`: output stream which needs timings copy and adjustments
+* `ist`: reference input stream to copy timings from
 * `copy_tb`: define from where the stream codec timebase needs to be imported
 """
 function avformat_transfer_internal_stream_timing_info(ofmt, ost, ist, copy_tb::AVTimebaseSource)
@@ -9501,6 +9040,19 @@ struct AVIODirContext
     url_context::Ptr{URLContext}
 end
 
+"""
+    AVIODataMarkerType
+
+Different data types that can be returned via the AVIO write\\_data\\_type callback.
+"""
+const AVIODataMarkerType = UInt32
+const AVIO_DATA_MARKER_HEADER = 0 % UInt32
+const AVIO_DATA_MARKER_SYNC_POINT = 1 % UInt32
+const AVIO_DATA_MARKER_BOUNDARY_POINT = 2 % UInt32
+const AVIO_DATA_MARKER_UNKNOWN = 3 % UInt32
+const AVIO_DATA_MARKER_TRAILER = 4 % UInt32
+const AVIO_DATA_MARKER_FLUSH_POINT = 5 % UInt32
+
 """
     avio_find_protocol_name(url)
 
@@ -9528,54 +9080,15 @@ function avio_check(url, flags::Integer)
     ccall((:avio_check, libavformat), Cint, (Cstring, Cint), url, flags)
 end
 
-"""
-    avpriv_io_move(url_src, url_dst)
-
-Move or rename a resource.
-
-!!! note
-
-    url\\_src and url\\_dst should share the same protocol and authority.
-
-### Parameters
-* `url_src`: url to resource to be moved 
-
-* `url_dst`: new url to resource if the operation succeeded 
-
-### Returns
->=0 on success or negative on error.
-"""
-function avpriv_io_move(url_src, url_dst)
-    ccall((:avpriv_io_move, libavformat), Cint, (Cstring, Cstring), url_src, url_dst)
-end
-
-"""
-    avpriv_io_delete(url)
-
-Delete a resource.
-
-### Parameters
-* `url`: resource to be deleted. 
-
-### Returns
->=0 on success or negative on error.
-"""
-function avpriv_io_delete(url)
-    ccall((:avpriv_io_delete, libavformat), Cint, (Cstring,), url)
-end
-
 """
     avio_open_dir(s, url, options)
 
 Open directory for reading.
 
 ### Parameters
-* `s`: directory read context. Pointer to a NULL pointer must be passed. 
-
-* `url`: directory to be listed. 
-
-* `options`: A dictionary filled with protocol-private options. On return this parameter will be destroyed and replaced with a dictionary containing options that were not found. May be NULL. 
-
+* `s`: directory read context. Pointer to a NULL pointer must be passed.
+* `url`: directory to be listed.
+* `options`: A dictionary filled with protocol-private options. On return this parameter will be destroyed and replaced with a dictionary containing options that were not found. May be NULL.
 ### Returns
 >=0 on success or negative on error.
 """
@@ -9591,10 +9104,8 @@ Get next directory entry.
 Returned entry must be freed with [`avio_free_directory_entry`](@ref)(). In particular it may outlive [`AVIODirContext`](@ref).
 
 ### Parameters
-* `s`: directory read context. 
-
-* `next`:\\[out\\] next entry or NULL when no more entries. 
-
+* `s`: directory read context.
+* `next`:\\[out\\] next entry or NULL when no more entries.
 ### Returns
 >=0 on success or negative on error. End of list is not considered an error.
 """
@@ -9612,8 +9123,7 @@ Close directory.
     Entries created using [`avio_read_dir`](@ref)() are not deleted and must be freeded with [`avio_free_directory_entry`](@ref)().
 
 ### Parameters
-* `s`: directory read context. 
-
+* `s`: directory read context.
 ### Returns
 >=0 on success or negative on error.
 """
@@ -9639,20 +9149,13 @@ end
 Allocate and initialize an [`AVIOContext`](@ref) for buffered I/O. It must be later freed with [`avio_context_free`](@ref)().
 
 ### Parameters
-* `buffer`: Memory block for input/output operations via [`AVIOContext`](@ref). The buffer must be allocated with [`av_malloc`](@ref)() and friends. It may be freed and replaced with a new buffer by libavformat. [`AVIOContext`](@ref).buffer holds the buffer currently in use, which must be later freed with [`av_free`](@ref)(). 
-
-* `buffer_size`: The buffer size is very important for performance. For protocols with fixed blocksize it should be set to this blocksize. For others a typical size is a cache page, e.g. 4kb. 
-
-* `write_flag`: Set to 1 if the buffer should be writable, 0 otherwise. 
-
-* `opaque`: An opaque pointer to user-specific data. 
-
-* `read_packet`: A function for refilling the buffer, may be NULL. For stream protocols, must never return 0 but rather a proper [`AVERROR`](@ref) code. 
-
-* `write_packet`: A function for writing the buffer contents, may be NULL. The function may not change the input buffers content. 
-
+* `buffer`: Memory block for input/output operations via [`AVIOContext`](@ref). The buffer must be allocated with [`av_malloc`](@ref)() and friends. It may be freed and replaced with a new buffer by libavformat. [`AVIOContext`](@ref).buffer holds the buffer currently in use, which must be later freed with [`av_free`](@ref)().
+* `buffer_size`: The buffer size is very important for performance. For protocols with fixed blocksize it should be set to this blocksize. For others a typical size is a cache page, e.g. 4kb.
+* `write_flag`: Set to 1 if the buffer should be writable, 0 otherwise.
+* `opaque`: An opaque pointer to user-specific data.
+* `read_packet`: A function for refilling the buffer, may be NULL. For stream protocols, must never return 0 but rather a proper [`AVERROR`](@ref) code.
+* `write_packet`: A function for writing the buffer contents, may be NULL. The function may not change the input buffers content.
 * `seek`: A function for seeking to specified byte position, may be NULL.
-
 ### Returns
 Allocated [`AVIOContext`](@ref) or NULL on failure.
 """
@@ -9715,7 +9218,7 @@ end
 """
     avio_put_str(s, str)
 
-Write a NULL-terminated string. 
+Write a NULL-terminated string.
 
 ### Returns
 number of bytes written.
@@ -9727,13 +9230,11 @@ end
 """
     avio_put_str16le(s, str)
 
-Convert an UTF-8 string to UTF-16LE and write it. 
+Convert an UTF-8 string to UTF-16LE and write it.
 
 ### Parameters
-* `s`: the [`AVIOContext`](@ref) 
-
+* `s`: the [`AVIOContext`](@ref)
 * `str`: NULL-terminated UTF-8 string
-
 ### Returns
 number of bytes written.
 """
@@ -9744,13 +9245,11 @@ end
 """
     avio_put_str16be(s, str)
 
-Convert an UTF-8 string to UTF-16BE and write it. 
+Convert an UTF-8 string to UTF-16BE and write it.
 
 ### Parameters
-* `s`: the [`AVIOContext`](@ref) 
-
+* `s`: the [`AVIOContext`](@ref)
 * `str`: NULL-terminated UTF-8 string
-
 ### Returns
 number of bytes written.
 """
@@ -9766,8 +9265,8 @@ Mark the written bytestream as a specific type.
 Zero-length ranges are omitted from the output.
 
 ### Parameters
-* `time`: the stream time the current bytestream pos corresponds to (in [`AV_TIME_BASE`](@ref) units), or [`AV_NOPTS_VALUE`](@ref) if unknown or not applicable 
-
+* `s`: the [`AVIOContext`](@ref)
+* `time`: the stream time the current bytestream pos corresponds to (in [`AV_TIME_BASE`](@ref) units), or [`AV_NOPTS_VALUE`](@ref) if unknown or not applicable
 * `type`: the kind of data written starting at the current pos
 """
 function avio_write_marker(s, time::Int64, type::AVIODataMarkerType)
@@ -9777,7 +9276,7 @@ end
 """
     avio_seek(s, offset::Int64, whence::Integer)
 
-fseek() equivalent for [`AVIOContext`](@ref). 
+fseek() equivalent for [`AVIOContext`](@ref).
 
 ### Returns
 new position or [`AVERROR`](@ref).
@@ -9789,7 +9288,7 @@ end
 """
     avio_skip(s, offset::Int64)
 
-Skip given number of bytes forward 
+Skip given number of bytes forward
 
 ### Returns
 new position or [`AVERROR`](@ref).
@@ -9801,7 +9300,7 @@ end
 """
     avio_tell(s)
 
-ftell() equivalent for [`AVIOContext`](@ref). 
+ftell() equivalent for [`AVIOContext`](@ref).
 
 ### Returns
 position or [`AVERROR`](@ref).
@@ -9813,7 +9312,7 @@ end
 """
     avio_size(s)
 
-Get the filesize. 
+Get the filesize.
 
 ### Returns
 filesize or [`AVERROR`](@ref)
@@ -9825,7 +9324,7 @@ end
 """
     avio_feof(s)
 
-Similar to feof() but also returns nonzero on read errors. 
+Similar to feof() but also returns nonzero on read errors.
 
 ### Returns
 non zero if and only if at end of file or a read error happened when reading.
@@ -9850,7 +9349,7 @@ end
 """
     avio_read(s, buf, size::Integer)
 
-Read size bytes from [`AVIOContext`](@ref) into buf. 
+Read size bytes from [`AVIOContext`](@ref) into buf.
 
 ### Returns
 number of bytes read or [`AVERROR`](@ref)
@@ -9862,7 +9361,7 @@ end
 """
     avio_read_partial(s, buf, size::Integer)
 
-Read size bytes from [`AVIOContext`](@ref) into buf. Unlike [`avio_read`](@ref)(), this is allowed to read fewer bytes than requested. The missing bytes can be read in the next call. This always tries to read at least 1 byte. Useful to reduce latency in certain cases. 
+Read size bytes from [`AVIOContext`](@ref) into buf. Unlike [`avio_read`](@ref)(), this is allowed to read fewer bytes than requested. The missing bytes can be read in the next call. This always tries to read at least 1 byte. Useful to reduce latency in certain cases.
 
 ### Returns
 number of bytes read or [`AVERROR`](@ref)
@@ -9933,7 +9432,7 @@ end
 """
     avio_get_str16le(pb, maxlen::Integer, buf, buflen::Integer)
 
-Read a UTF-16 string from pb and convert it to UTF-8. The reading will terminate when either a null or invalid character was encountered or maxlen bytes have been read. 
+Read a UTF-16 string from pb and convert it to UTF-8. The reading will terminate when either a null or invalid character was encountered or maxlen bytes have been read.
 
 ### Returns
 number of bytes read (is always <= maxlen)
@@ -9949,19 +9448,16 @@ end
 """
     avio_open(s, url, flags::Integer)
 
-Create and initialize a [`AVIOContext`](@ref) for accessing the resource indicated by url. 
+Create and initialize a [`AVIOContext`](@ref) for accessing the resource indicated by url.
 
 !!! note
 
     When the resource indicated by url has been opened in read+write mode, the [`AVIOContext`](@ref) can be used only for writing.
 
 ### Parameters
-* `s`: Used to return the pointer to the created [`AVIOContext`](@ref). In case of failure the pointed to value is set to NULL. 
-
-* `url`: resource to access 
-
-* `flags`: flags which control how the resource indicated by url is to be opened 
-
+* `s`: Used to return the pointer to the created [`AVIOContext`](@ref). In case of failure the pointed to value is set to NULL.
+* `url`: resource to access
+* `flags`: flags which control how the resource indicated by url is to be opened
 ### Returns
 >= 0 in case of success, a negative value corresponding to an [`AVERROR`](@ref) code in case of failure
 """
@@ -9972,23 +9468,18 @@ end
 """
     avio_open2(s, url, flags::Integer, int_cb, options)
 
-Create and initialize a [`AVIOContext`](@ref) for accessing the resource indicated by url. 
+Create and initialize a [`AVIOContext`](@ref) for accessing the resource indicated by url.
 
 !!! note
 
     When the resource indicated by url has been opened in read+write mode, the [`AVIOContext`](@ref) can be used only for writing.
 
 ### Parameters
-* `s`: Used to return the pointer to the created [`AVIOContext`](@ref). In case of failure the pointed to value is set to NULL. 
-
-* `url`: resource to access 
-
-* `flags`: flags which control how the resource indicated by url is to be opened 
-
-* `int_cb`: an interrupt callback to be used at the protocols level 
-
-* `options`: A dictionary filled with protocol-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL. 
-
+* `s`: Used to return the pointer to the created [`AVIOContext`](@ref). In case of failure the pointed to value is set to NULL.
+* `url`: resource to access
+* `flags`: flags which control how the resource indicated by url is to be opened
+* `int_cb`: an interrupt callback to be used at the protocols level
+* `options`: A dictionary filled with protocol-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.
 ### Returns
 >= 0 in case of success, a negative value corresponding to an [`AVERROR`](@ref) code in case of failure
 """
@@ -10004,8 +9495,7 @@ Close the resource accessed by the [`AVIOContext`](@ref) s and free it. This fun
 The internal buffer is automatically flushed before closing the resource.
 
 ### Returns
-0 on success, an [`AVERROR`](@ref) < 0 on error. 
-
+0 on success, an [`AVERROR`](@ref) < 0 on error.
 ### See also
 [`avio_closep`](@ref)
 """
@@ -10021,8 +9511,7 @@ Close the resource accessed by the [`AVIOContext`](@ref) *s, free it and set the
 The internal buffer is automatically flushed before closing the resource.
 
 ### Returns
-0 on success, an [`AVERROR`](@ref) < 0 on error. 
-
+0 on success, an [`AVERROR`](@ref) < 0 on error.
 ### See also
 [`avio_close`](@ref)
 """
@@ -10036,8 +9525,7 @@ end
 Open a write only memory stream.
 
 ### Parameters
-* `s`: new IO context 
-
+* `s`: new IO context
 ### Returns
 zero if no error.
 """
@@ -10051,10 +9539,8 @@ end
 Return the written size and a pointer to the buffer. The [`AVIOContext`](@ref) stream is left intact. The buffer must NOT be freed. No padding is added to the buffer.
 
 ### Parameters
-* `s`: IO context 
-
-* `pbuffer`: pointer to a byte buffer 
-
+* `s`: IO context
+* `pbuffer`: pointer to a byte buffer
 ### Returns
 the length of the byte buffer
 """
@@ -10068,10 +9554,8 @@ end
 Return the written size and a pointer to the buffer. The buffer must be freed with [`av_free`](@ref)(). Padding of [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref) is added to the buffer.
 
 ### Parameters
-* `s`: IO context 
-
-* `pbuffer`: pointer to a byte buffer 
-
+* `s`: IO context
+* `pbuffer`: pointer to a byte buffer
 ### Returns
 the length of the byte buffer
 """
@@ -10085,10 +9569,8 @@ end
 Iterate through names of available protocols.
 
 ### Parameters
-* `opaque`: A private pointer representing current protocol. It must be a pointer to NULL on first iteration and will be updated by successive calls to [`avio_enum_protocols`](@ref). 
-
+* `opaque`: A private pointer representing current protocol. It must be a pointer to NULL on first iteration and will be updated by successive calls to [`avio_enum_protocols`](@ref).
 * `output`: If set to 1, iterate over output protocols, otherwise over input protocols.
-
 ### Returns
 A static string containing the name of current protocol or NULL
 """
@@ -10114,8 +9596,7 @@ end
 Pause and resume playing - only meaningful if using a network streaming protocol (e.g. MMS).
 
 ### Parameters
-* `h`: IO context from which to call the read\\_pause function pointer 
-
+* `h`: IO context from which to call the read\\_pause function pointer
 * `pause`: 1 for pause, 0 for resume
 """
 function avio_pause(h, pause::Integer)
@@ -10128,17 +9609,12 @@ end
 Seek to a given timestamp relative to some component stream. Only meaningful if using a network streaming protocol (e.g. MMS.).
 
 ### Parameters
-* `h`: IO context from which to call the seek function pointers 
-
-* `stream_index`: The stream index that the timestamp is relative to. If stream\\_index is (-1) the timestamp should be in [`AV_TIME_BASE`](@ref) units from the beginning of the presentation. If a stream\\_index >= 0 is used and the protocol does not support seeking based on component streams, the call will fail. 
-
-* `timestamp`: timestamp in [`AVStream`](@ref).time\\_base units or if there is no stream specified then in [`AV_TIME_BASE`](@ref) units. 
-
-* `flags`: Optional combination of [`AVSEEK_FLAG_BACKWARD`](@ref), [`AVSEEK_FLAG_BYTE`](@ref) and [`AVSEEK_FLAG_ANY`](@ref). The protocol may silently ignore [`AVSEEK_FLAG_BACKWARD`](@ref) and [`AVSEEK_FLAG_ANY`](@ref), but [`AVSEEK_FLAG_BYTE`](@ref) will fail if used and not supported. 
-
+* `h`: IO context from which to call the seek function pointers
+* `stream_index`: The stream index that the timestamp is relative to. If stream\\_index is (-1) the timestamp should be in [`AV_TIME_BASE`](@ref) units from the beginning of the presentation. If a stream\\_index >= 0 is used and the protocol does not support seeking based on component streams, the call will fail.
+* `timestamp`: timestamp in [`AVStream`](@ref).time\\_base units or if there is no stream specified then in [`AV_TIME_BASE`](@ref) units.
+* `flags`: Optional combination of [`AVSEEK_FLAG_BACKWARD`](@ref), [`AVSEEK_FLAG_BYTE`](@ref) and [`AVSEEK_FLAG_ANY`](@ref). The protocol may silently ignore [`AVSEEK_FLAG_BACKWARD`](@ref) and [`AVSEEK_FLAG_ANY`](@ref), but [`AVSEEK_FLAG_BYTE`](@ref) will fail if used and not supported.
 ### Returns
->= 0 on success 
-
+>= 0 on success
 ### See also
 [`AVInputFormat`](@ref)::read\\_seek
 """
@@ -10153,21 +9629,15 @@ Buffer to print data progressively
 
 The string buffer grows as necessary and is always 0-terminated. The content of the string is never accessed, and thus is encoding-agnostic and can even hold binary data.
 
-Small buffers are kept in the structure itself, and thus require no memory allocation at all (unless the contents of the buffer is needed after the structure goes out of scope). This is almost as lightweight as declaring a local "char buf[512]".
+Small buffers are kept in the structure itself, and thus require no memory allocation at all (unless the contents of the buffer is needed after the structure goes out of scope). This is almost as lightweight as declaring a local `char buf[512]`.
 
 The length of the string can go beyond the allocated size: the buffer is then truncated, but the functions still keep account of the actual total length.
 
-In other words, buf->len can be greater than buf->size and records the total length of what would have been to the buffer if there had been enough memory.
+In other words, [`AVBPrint`](@ref).len can be greater than [`AVBPrint`](@ref).size and records the total length of what would have been to the buffer if there had been enough memory.
 
 Append operations do not need to be tested for failure: if a memory allocation fails, data stop being appended to the buffer, but the length is still updated. This situation can be tested with [`av_bprint_is_complete`](@ref)().
 
-The size\\_max field determines several possible behaviours:
-
-size\\_max = -1 (= UINT\\_MAX) or any large value will let the buffer be reallocated as necessary, with an amortized linear cost.
-
-size\\_max = 0 prevents writing anything to the buffer: only the total length is computed. The write operations can then possibly be repeated in a buffer with exactly the necessary size (using size\\_init = size\\_max = len + 1).
-
-size\\_max = 1 is automatically replaced by the exact size available in the structure itself, thus ensuring no dynamic memory allocation. The internal buffer is large enough to hold a reasonable paragraph of text, such as the current paragraph.
+The [`AVBPrint`](@ref).size\\_max field determines several possible behaviours: - `size\\_max = -1` (= `UINT_MAX`) or any large value will let the buffer be reallocated as necessary, with an amortized linear cost. - `size\\_max = 0` prevents writing anything to the buffer: only the total length is computed. The write operations can then possibly be repeated in a buffer with exactly the necessary size (using `size\\_init = size\\_max = len + 1`). - `size\\_max = 1` is automatically replaced by the exact size available in the structure itself, thus ensuring no dynamic memory allocation. The internal buffer is large enough to hold a reasonable paragraph of text, such as the current paragraph.
 """
 struct AVBPrint
     str::Cstring
@@ -10193,13 +9663,11 @@ end
 """
     avio_accept(s, c)
 
-Accept and allocate a client context on a server context. 
+Accept and allocate a client context on a server context.
 
 ### Parameters
-* `s`: the server context 
-
-* `c`: the client context, must be unallocated 
-
+* `s`: the server context
+* `c`: the client context, must be unallocated
 ### Returns
 >= 0 on success or a negative value corresponding to an [`AVERROR`](@ref) on failure
 """
@@ -10213,8 +9681,7 @@ end
 Perform one step of the protocol handshake to accept a new client. This function must be called on a client returned by [`avio_accept`](@ref)() before using it as a read/write context. It is separate from [`avio_accept`](@ref)() because it may block. A step of the handshake is defined by places where the application may decide to change the proceedings. For example, on a protocol with a request header and a reply header, each one can constitute a step because the application may use the parameters from the request to change parameters in the reply; or each individual chunk of the request can constitute a step. If the handshake is already finished, [`avio_handshake`](@ref)() does nothing and returns 0 immediately.
 
 ### Parameters
-* `c`: the client context to perform the handshake on 
-
+* `c`: the client context to perform the handshake on
 ### Returns
 0 on a complete and successful handshake > 0 if the handshake progressed, but is not complete < 0 for an [`AVERROR`](@ref) code
 """
@@ -10222,27 +9689,33 @@ function avio_handshake(c)
     ccall((:avio_handshake, libavformat), Cint, (Ptr{AVIOContext},), c)
 end
 
-const AVAdler = Culong
+"""
+` lavu_adler32 Adler-32`
+
+` lavu_hash`
+
+Adler-32 hash function implementation.
+
+@{
+"""
+const AVAdler = UInt32
 
 """
-    av_adler32_update(adler::AVAdler, buf, len::Integer)
+    av_adler32_update(adler::AVAdler, buf, len::Csize_t)
 
 Calculate the Adler32 checksum of a buffer.
 
 Passing the return value to a subsequent [`av_adler32_update`](@ref)() call allows the checksum of multiple buffers to be calculated as though they were concatenated.
 
 ### Parameters
-* `adler`: initial checksum value 
-
-* `buf`: pointer to input buffer 
-
-* `len`: size of input buffer 
-
+* `adler`: initial checksum value
+* `buf`: pointer to input buffer
+* `len`: size of input buffer
 ### Returns
 updated checksum
 """
-function av_adler32_update(adler::AVAdler, buf, len::Integer)
-    ccall((:av_adler32_update, libavutil), AVAdler, (AVAdler, Ptr{UInt8}, Cuint), adler, buf, len)
+function av_adler32_update(adler::AVAdler, buf, len::Csize_t)
+    ccall((:av_adler32_update, libavutil), AVAdler, (AVAdler, Ptr{UInt8}, Csize_t), adler, buf, len)
 end
 
 mutable struct AVAES end
@@ -10259,11 +9732,12 @@ end
 """
     av_aes_init(a, key, key_bits::Integer, decrypt::Integer)
 
-Initialize an [`AVAES`](@ref) context. 
+Initialize an [`AVAES`](@ref) context.
 
 ### Parameters
-* `key_bits`: 128, 192 or 256 
-
+* `a`: The [`AVAES`](@ref) context
+* `key`: Pointer to the key
+* `key_bits`: 128, 192 or 256
 * `decrypt`: 0 for encryption, 1 for decryption
 """
 function av_aes_init(a, key, key_bits::Integer, decrypt::Integer)
@@ -10273,17 +9747,14 @@ end
 """
     av_aes_crypt(a, dst, src, count::Integer, iv, decrypt::Integer)
 
-Encrypt or decrypt a buffer using a previously initialized context. 
+Encrypt or decrypt a buffer using a previously initialized context.
 
 ### Parameters
-* `count`: number of 16 byte blocks 
-
-* `dst`: destination array, can be equal to src 
-
-* `src`: source array, can be equal to dst 
-
-* `iv`: initialization vector for CBC mode, if NULL then ECB will be used 
-
+* `a`: The [`AVAES`](@ref) context
+* `dst`: destination array, can be equal to src
+* `src`: source array, can be equal to dst
+* `count`: number of 16 byte blocks
+* `iv`: initialization vector for CBC mode, if NULL then ECB will be used
 * `decrypt`: 0 for encryption, 1 for decryption
 """
 function av_aes_crypt(a, dst, src, count::Integer, iv, decrypt::Integer)
@@ -10304,9 +9775,10 @@ end
 """
     av_aes_ctr_init(a, key)
 
-Initialize an [`AVAESCTR`](@ref) context. 
+Initialize an [`AVAESCTR`](@ref) context.
 
 ### Parameters
+* `a`: The [`AVAESCTR`](@ref) context to initialize
 * `key`: encryption key, must have a length of [`AES_CTR_KEY_SIZE`](@ref)
 """
 function av_aes_ctr_init(a, key)
@@ -10317,6 +9789,9 @@ end
     av_aes_ctr_free(a)
 
 Release an [`AVAESCTR`](@ref) context.
+
+### Parameters
+* `a`: The [`AVAESCTR`](@ref) context
 """
 function av_aes_ctr_free(a)
     ccall((:av_aes_ctr_free, libavutil), Cvoid, (Ptr{AVAESCTR},), a)
@@ -10325,13 +9800,12 @@ end
 """
     av_aes_ctr_crypt(a, dst, src, size::Integer)
 
-Process a buffer using a previously initialized context. 
+Process a buffer using a previously initialized context.
 
 ### Parameters
-* `dst`: destination array, can be equal to src 
-
-* `src`: source array, can be equal to dst 
-
+* `a`: The [`AVAESCTR`](@ref) context
+* `dst`: destination array, can be equal to src
+* `src`: source array, can be equal to dst
 * `size`: the size of src and dst
 """
 function av_aes_ctr_crypt(a, dst, src, size::Integer)
@@ -10383,6 +9857,45 @@ function av_aes_ctr_increment_iv(a)
     ccall((:av_aes_ctr_increment_iv, libavutil), Cvoid, (Ptr{AVAESCTR},), a)
 end
 
+"""
+    AVAmbientViewingEnvironment
+
+Ambient viewing environment metadata as defined by H.274. The values are saved in AVRationals so that they keep their exactness, while allowing for easy access to a double value with f.ex. [`av_q2d`](@ref).
+
+!!! note
+
+    sizeof([`AVAmbientViewingEnvironment`](@ref)) is not part of the public ABI, and it must be allocated using [`av_ambient_viewing_environment_alloc`](@ref).
+"""
+struct AVAmbientViewingEnvironment
+    ambient_illuminance::AVRational
+    ambient_light_x::AVRational
+    ambient_light_y::AVRational
+end
+
+"""
+    av_ambient_viewing_environment_alloc(size)
+
+Allocate an [`AVAmbientViewingEnvironment`](@ref) structure.
+
+### Returns
+the newly allocated struct or NULL on failure
+"""
+function av_ambient_viewing_environment_alloc(size)
+    ccall((:av_ambient_viewing_environment_alloc, libavutil), Ptr{AVAmbientViewingEnvironment}, (Ptr{Csize_t},), size)
+end
+
+"""
+    av_ambient_viewing_environment_create_side_data(frame)
+
+Allocate and add an [`AVAmbientViewingEnvironment`](@ref) structure to an existing [`AVFrame`](@ref) as side data.
+
+### Returns
+the newly allocated struct, or NULL on failure
+"""
+function av_ambient_viewing_environment_create_side_data(frame)
+    ccall((:av_ambient_viewing_environment_create_side_data, libavutil), Ptr{AVAmbientViewingEnvironment}, (Ptr{AVFrame},), frame)
+end
+
 mutable struct AVAudioFifo end
 
 """
@@ -10403,12 +9916,9 @@ end
 Allocate an [`AVAudioFifo`](@ref).
 
 ### Parameters
-* `sample_fmt`: sample format 
-
-* `channels`: number of channels 
-
-* `nb_samples`: initial allocation size, in samples 
-
+* `sample_fmt`: sample format
+* `channels`: number of channels
+* `nb_samples`: initial allocation size, in samples
 ### Returns
 newly allocated [`AVAudioFifo`](@ref), or NULL on error
 """
@@ -10422,10 +9932,8 @@ end
 Reallocate an [`AVAudioFifo`](@ref).
 
 ### Parameters
-* `af`: [`AVAudioFifo`](@ref) to reallocate 
-
-* `nb_samples`: new allocation size, in samples 
-
+* `af`: [`AVAudioFifo`](@ref) to reallocate
+* `nb_samples`: new allocation size, in samples
 ### Returns
 0 if OK, or negative [`AVERROR`](@ref) code on failure
 """
@@ -10441,15 +9949,11 @@ Write data to an [`AVAudioFifo`](@ref).
 The [`AVAudioFifo`](@ref) will be reallocated automatically if the available space is less than nb\\_samples.
 
 ### Parameters
-* `af`: [`AVAudioFifo`](@ref) to write to 
-
-* `data`: audio data plane pointers 
-
-* `nb_samples`: number of samples to write 
-
+* `af`: [`AVAudioFifo`](@ref) to write to
+* `data`: audio data plane pointers
+* `nb_samples`: number of samples to write
 ### Returns
 number of samples actually written, or negative [`AVERROR`](@ref) code on failure. If successful, the number of samples actually written will always be nb\\_samples.
-
 ### See also
 enum [`AVSampleFormat`](@ref) The documentation for [`AVSampleFormat`](@ref) describes the data layout.
 """
@@ -10463,15 +9967,11 @@ end
 Peek data from an [`AVAudioFifo`](@ref).
 
 ### Parameters
-* `af`: [`AVAudioFifo`](@ref) to read from 
-
-* `data`: audio data plane pointers 
-
-* `nb_samples`: number of samples to peek 
-
+* `af`: [`AVAudioFifo`](@ref) to read from
+* `data`: audio data plane pointers
+* `nb_samples`: number of samples to peek
 ### Returns
 number of samples actually peek, or negative [`AVERROR`](@ref) code on failure. The number of samples actually peek will not be greater than nb\\_samples, and will only be less than nb\\_samples if [`av_audio_fifo_size`](@ref) is less than nb\\_samples.
-
 ### See also
 enum [`AVSampleFormat`](@ref) The documentation for [`AVSampleFormat`](@ref) describes the data layout.
 """
@@ -10485,17 +9985,12 @@ end
 Peek data from an [`AVAudioFifo`](@ref).
 
 ### Parameters
-* `af`: [`AVAudioFifo`](@ref) to read from 
-
-* `data`: audio data plane pointers 
-
-* `nb_samples`: number of samples to peek 
-
-* `offset`: offset from current read position 
-
+* `af`: [`AVAudioFifo`](@ref) to read from
+* `data`: audio data plane pointers
+* `nb_samples`: number of samples to peek
+* `offset`: offset from current read position
 ### Returns
 number of samples actually peek, or negative [`AVERROR`](@ref) code on failure. The number of samples actually peek will not be greater than nb\\_samples, and will only be less than nb\\_samples if [`av_audio_fifo_size`](@ref) is less than nb\\_samples.
-
 ### See also
 enum [`AVSampleFormat`](@ref) The documentation for [`AVSampleFormat`](@ref) describes the data layout.
 """
@@ -10509,15 +10004,11 @@ end
 Read data from an [`AVAudioFifo`](@ref).
 
 ### Parameters
-* `af`: [`AVAudioFifo`](@ref) to read from 
-
-* `data`: audio data plane pointers 
-
-* `nb_samples`: number of samples to read 
-
+* `af`: [`AVAudioFifo`](@ref) to read from
+* `data`: audio data plane pointers
+* `nb_samples`: number of samples to read
 ### Returns
 number of samples actually read, or negative [`AVERROR`](@ref) code on failure. The number of samples actually read will not be greater than nb\\_samples, and will only be less than nb\\_samples if [`av_audio_fifo_size`](@ref) is less than nb\\_samples.
-
 ### See also
 enum [`AVSampleFormat`](@ref) The documentation for [`AVSampleFormat`](@ref) describes the data layout.
 """
@@ -10533,10 +10024,8 @@ Drain data from an [`AVAudioFifo`](@ref).
 Removes the data without reading it.
 
 ### Parameters
-* `af`: [`AVAudioFifo`](@ref) to drain 
-
-* `nb_samples`: number of samples to drain 
-
+* `af`: [`AVAudioFifo`](@ref) to drain
+* `nb_samples`: number of samples to drain
 ### Returns
 0 if OK, or negative [`AVERROR`](@ref) code on failure
 """
@@ -10564,8 +10053,7 @@ end
 Get the current number of samples in the [`AVAudioFifo`](@ref) available for reading.
 
 ### Parameters
-* `af`: the [`AVAudioFifo`](@ref) to query 
-
+* `af`: the [`AVAudioFifo`](@ref) to query
 ### Returns
 number of samples available for reading
 """
@@ -10579,8 +10067,7 @@ end
 Get the current number of samples in the [`AVAudioFifo`](@ref) available for writing.
 
 ### Parameters
-* `af`: the [`AVAudioFifo`](@ref) to query 
-
+* `af`: the [`AVAudioFifo`](@ref) to query
 ### Returns
 number of samples available for writing
 """
@@ -10605,12 +10092,9 @@ end
 Return non-zero if pfx is a prefix of str. If it is, *ptr is set to the address of the first character in str after the prefix.
 
 ### Parameters
-* `str`: input string 
-
-* `pfx`: prefix to test 
-
-* `ptr`: updated if the prefix is matched inside str 
-
+* `str`: input string
+* `pfx`: prefix to test
+* `ptr`: updated if the prefix is matched inside str
 ### Returns
 non-zero if the prefix matches, zero otherwise
 """
@@ -10624,12 +10108,9 @@ end
 Return non-zero if pfx is a prefix of str independent of case. If it is, *ptr is set to the address of the first character in str after the prefix.
 
 ### Parameters
-* `str`: input string 
-
-* `pfx`: prefix to test 
-
-* `ptr`: updated if the prefix is matched inside str 
-
+* `str`: input string
+* `pfx`: prefix to test
+* `ptr`: updated if the prefix is matched inside str
 ### Returns
 non-zero if the prefix matches, zero otherwise
 """
@@ -10645,10 +10126,8 @@ Locate the first case-independent occurrence in the string haystack of the strin
 This function is a case-insensitive version of the standard strstr().
 
 ### Parameters
-* `haystack`: string to search in 
-
-* `needle`: string to search for 
-
+* `haystack`: string to search in
+* `needle`: string to search for
 ### Returns
 pointer to the located match within haystack or a null pointer if no match
 """
@@ -10664,12 +10143,9 @@ Locate the first occurrence of the string needle in the string haystack where no
 This function is a length-limited version of the standard strstr().
 
 ### Parameters
-* `haystack`: string to search in 
-
-* `needle`: string to search for 
-
-* `hay_length`: length of string to search in 
-
+* `haystack`: string to search in
+* `needle`: string to search for
+* `hay_length`: length of string to search in
 ### Returns
 pointer to the located match within haystack or a null pointer if no match
 """
@@ -10689,12 +10165,9 @@ This function is the same as BSD strlcpy().
     since the return value is the length of src, src absolutely \\_must\\_ be a properly 0-terminated string, otherwise this will read beyond the end of the buffer and possibly crash.
 
 ### Parameters
-* `dst`: destination buffer 
-
-* `src`: source string 
-
-* `size`: size of destination buffer 
-
+* `dst`: destination buffer
+* `src`: source string
+* `size`: size of destination buffer
 ### Returns
 the length of src
 """
@@ -10714,12 +10187,9 @@ This function is similar to BSD strlcat(), but differs when size <= strlen(dst).
     since the return value use the length of src and dst, these absolutely \\_must\\_ be a properly 0-terminated strings, otherwise this will read beyond the end of the buffer and possibly crash.
 
 ### Parameters
-* `dst`: destination buffer 
-
-* `src`: source string 
-
-* `size`: size of destination buffer 
-
+* `dst`: destination buffer
+* `src`: source string
+* `size`: size of destination buffer
 ### Returns
 the total length of src and dst
 """
@@ -10733,23 +10203,13 @@ end
 Get the count of continuous non zero chars starting from the beginning.
 
 ### Parameters
+* `s`: the string whose length to count
 * `len`: maximum number of characters to check in the string, that is the maximum value which is returned by the function
 """
 function av_strnlen(s, len::Csize_t)
     ccall((:av_strnlen, libavutil), Csize_t, (Cstring, Csize_t), s, len)
 end
 
-"""
-    av_d2str(d::Cdouble)
-
-Convert a number to an av\\_malloced string. 
-
-\\deprecated use [`av_asprintf`](@ref)() with "f" or a more specific format
-"""
-function av_d2str(d::Cdouble)
-    ccall((:av_d2str, libavutil), Cstring, (Cdouble,), d)
-end
-
 """
     av_get_token(buf, term)
 
@@ -10758,10 +10218,8 @@ Unescape the given string until a non escaped terminating char, and return the t
 The normal \\ and ' escaping is supported. Leading and trailing whitespaces are removed, unless they are escaped with '\\' or are enclosed between ''.
 
 ### Parameters
-* `buf`: the buffer to parse, buf will be updated to point to the terminating char 
-
-* `term`: a 0-terminated list of terminating chars 
-
+* `buf`: the buffer to parse, buf will be updated to point to the terminating char
+* `term`: a 0-terminated list of terminating chars
 ### Returns
 the malloced unescaped string, which must be av\\_freed by the user, NULL in case of allocation failure
 """
@@ -10781,12 +10239,9 @@ On the first call to [`av_strtok`](@ref)(), s should point to the string to pars
 This function is similar to strtok\\_r() defined in POSIX.1.
 
 ### Parameters
-* `s`: the string to parse, may be NULL 
-
-* `delim`: 0-terminated list of token delimiters, must be non-NULL 
-
-* `saveptr`: user-provided pointer which points to stored information necessary for [`av_strtok`](@ref)() to continue scanning the same string. saveptr is updated to point to the next character after the first delimiter found, or to NULL if the string was terminated 
-
+* `s`: the string to parse, may be NULL
+* `delim`: 0-terminated list of token delimiters, must be non-NULL
+* `saveptr`: user-provided pointer which points to stored information necessary for [`av_strtok`](@ref)() to continue scanning the same string. saveptr is updated to point to the next character after the first delimiter found, or to NULL if the string was terminated
 ### Returns
 the found token, or NULL when no token is found
 """
@@ -10851,7 +10306,7 @@ end
 """
     av_strcasecmp(a, b)
 
-Locale-independent case-insensitive compare. 
+Locale-independent case-insensitive compare.
 
 !!! note
 
@@ -10864,7 +10319,7 @@ end
 """
     av_strncasecmp(a, b, n::Csize_t)
 
-Locale-independent case-insensitive compare. 
+Locale-independent case-insensitive compare.
 
 !!! note
 
@@ -10877,11 +10332,11 @@ end
 """
     av_strireplace(str, from, to)
 
-Locale-independent strings replace. 
+Locale-independent strings replace.
 
 !!! note
 
-    This means only ASCII-range characters are replace
+    This means only ASCII-range characters are replaced.
 """
 function av_strireplace(str, from, to)
     ccall((:av_strireplace, libavutil), Cstring, (Cstring, Cstring, Cstring), str, from, to)
@@ -10890,11 +10345,10 @@ end
 """
     av_basename(path)
 
-Thread safe basename. 
+Thread safe basename.
 
 ### Parameters
-* `path`: the string to parse, on DOS both \\ and / are considered separators. 
-
+* `path`: the string to parse, on DOS both \\ and / are considered separators.
 ### Returns
 pointer to the basename substring. If path does not contain a slash, the function returns a copy of path. If path is a NULL pointer or points to an empty string, a pointer to a string "." is returned.
 """
@@ -10905,17 +10359,16 @@ end
 """
     av_dirname(path)
 
-Thread safe dirname. 
+Thread safe dirname.
 
 !!! note
 
     the function may modify the contents of the path, so copies should be passed.
 
 ### Parameters
-* `path`: the string to parse, on DOS both \\ and / are considered separators. 
-
+* `path`: the string to parse, on DOS both \\ and / are considered separators.
 ### Returns
-A pointer to a string that's the parent directory of path. If path is a NULL pointer or points to an empty string, a pointer to a string "." is returned. 
+A pointer to a string that's the parent directory of path. If path is a NULL pointer or points to an empty string, a pointer to a string "." is returned.
 """
 function av_dirname(path)
     ccall((:av_dirname, libavutil), Cstring, (Cstring,), path)
@@ -10927,10 +10380,8 @@ end
 Match instances of a name in a comma-separated list of names. List entries are checked from the start to the end of the names list, the first match ends further processing. If an entry prefixed with '-' matches, then 0 is returned. The "ALL" list entry is considered to match all names.
 
 ### Parameters
-* `name`: Name to look for. 
-
-* `names`: List of names. 
-
+* `name`: Name to look for.
+* `names`: List of names.
 ### Returns
 1 on match, 0 otherwise.
 """
@@ -10941,13 +10392,11 @@ end
 """
     av_append_path_component(path, component)
 
-Append path component to the existing path. Path separator '/' is placed between when needed. Resulting string have to be freed with [`av_free`](@ref)(). 
+Append path component to the existing path. Path separator '/' is placed between when needed. Resulting string have to be freed with [`av_free`](@ref)().
 
 ### Parameters
-* `path`: base path 
-
-* `component`: component to be appended 
-
+* `path`: base path
+* `component`: component to be appended
 ### Returns
 new path or NULL on error.
 """
@@ -10967,19 +10416,13 @@ const AV_ESCAPE_MODE_XML = 3 % UInt32
 Escape string in src, and put the escaped string in an allocated string in *dst, which must be freed with [`av_free`](@ref)().
 
 ### Parameters
-* `dst`: pointer where an allocated string is put 
-
-* `src`: string to escape, must be non-NULL 
-
-* `special_chars`: string containing the special characters which need to be escaped, can be NULL 
-
-* `mode`: escape mode to employ, see AV\\_ESCAPE\\_MODE\\_* macros. Any unknown value for mode will be considered equivalent to AV\\_ESCAPE\\_MODE\\_BACKSLASH, but this behaviour can change without notice. 
-
-* `flags`: flags which control how to escape, see AV\\_ESCAPE\\_FLAG\\_ macros 
-
+* `dst`: pointer where an allocated string is put
+* `src`: string to escape, must be non-NULL
+* `special_chars`: string containing the special characters which need to be escaped, can be NULL
+* `mode`: escape mode to employ, see AV\\_ESCAPE\\_MODE\\_* macros. Any unknown value for mode will be considered equivalent to AV\\_ESCAPE\\_MODE\\_BACKSLASH, but this behaviour can change without notice.
+* `flags`: flags which control how to escape, see AV\\_ESCAPE\\_FLAG\\_ macros
 ### Returns
-the length of the allocated string, or a negative error code in case of error 
-
+the length of the allocated string, or a negative error code in case of error
 ### See also
 [`av_bprint_escape`](@ref)()
 """
@@ -11001,14 +10444,10 @@ Depending on the specified flags, the function will also fail in case the decode
     For speed-relevant code a carefully implemented use of [`GET_UTF8`](@ref)() may be preferred.
 
 ### Parameters
-* `codep`: pointer used to return the parsed code in case of success. The value in *codep is set even in case the range check fails. 
-
-* `bufp`: pointer to the address the first byte of the sequence to decode, updated by the function to point to the byte next after the decoded sequence 
-
-* `buf_end`: pointer to the end of the buffer, points to the next byte past the last in the buffer. This is used to avoid buffer overreads (in case of an unfinished UTF-8 sequence towards the end of the buffer). 
-
-* `flags`: a collection of AV\\_UTF8\\_FLAG\\_* flags 
-
+* `codep`: pointer used to return the parsed code in case of success. The value in *codep is set even in case the range check fails.
+* `bufp`: pointer to the address the first byte of the sequence to decode, updated by the function to point to the byte next after the decoded sequence
+* `buf_end`: pointer to the end of the buffer, points to the next byte past the last in the buffer. This is used to avoid buffer overreads (in case of an unfinished UTF-8 sequence towards the end of the buffer).
+* `flags`: a collection of AV\\_UTF8\\_FLAG\\_* flags
 ### Returns
 >= 0 in case a sequence was successfully read, a negative value in case of invalid sequence
 """
@@ -11019,7 +10458,7 @@ end
 """
     av_match_list(name, list, separator::Cchar)
 
-Check if a name is in a list. 
+Check if a name is in a list.
 
 ### Returns
 0 if not found, or the 1 based index where it has been found in the list.
@@ -11034,12 +10473,9 @@ end
 Compute the length of an integer list.
 
 ### Parameters
-* `elsize`: size in bytes of each list element (only 1, 2, 4 or 8) 
-
-* `term`: list terminator (usually 0 or -1) 
-
-* `list`: pointer to the list 
-
+* `elsize`: size in bytes of each list element (only 1, 2, 4 or 8)
+* `term`: list terminator (usually 0 or -1)
+* `list`: pointer to the list
 ### Returns
 length of the list, in elements, not counting the terminator
 """
@@ -11053,10 +10489,8 @@ end
 Fill the provided buffer with a string containing a FourCC (four-character code) representation.
 
 ### Parameters
-* `buf`: a buffer with size in bytes of at least [`AV_FOURCC_MAX_STRING_SIZE`](@ref) 
-
-* `fourcc`: the fourcc to represent 
-
+* `buf`: a buffer with size in bytes of at least [`AV_FOURCC_MAX_STRING_SIZE`](@ref)
+* `fourcc`: the fourcc to represent
 ### Returns
 the buffer in input
 """
@@ -11115,8 +10549,7 @@ end
 Return a single letter to describe the given picture type pict\\_type.
 
 ### Parameters
-* `pict_type`:\\[in\\] the picture type 
-
+* `pict_type`:\\[in\\] the picture type
 ### Returns
 a single character representing the picture type, '?' if pict\\_type is unknown
 """
@@ -11137,6 +10570,8 @@ end
     av_fopen_utf8(path, mode)
 
 Open a file using a UTF-8 filename. The API of this function matches POSIX fopen(), errors are returned through errno.
+
+\\deprecated Avoid using it, as on Windows, the FILE* allocated by this function may be allocated with a different CRT than the caller who uses the FILE*. No replacement provided in public API.
 """
 function av_fopen_utf8(path, mode)
     ccall((:av_fopen_utf8, libavutil), Ptr{Libc.FILE}, (Cstring, Cstring), path, mode)
@@ -11157,12 +10592,9 @@ end
 Decode a base64-encoded string.
 
 ### Parameters
-* `out`: buffer for decoded data 
-
-* `in`: null-terminated input string 
-
-* `out_size`: size in bytes of the out buffer, must be at least 3/4 of the length of in, that is [`AV_BASE64_DECODE_SIZE`](@ref)(strlen(in)) 
-
+* `out`: buffer for decoded data
+* `in`: null-terminated input string
+* `out_size`: size in bytes of the out buffer, must be at least 3/4 of the length of in, that is [`AV_BASE64_DECODE_SIZE`](@ref)(strlen(in))
 ### Returns
 number of bytes written, or a negative value in case of invalid input
 """
@@ -11176,14 +10608,10 @@ end
 Encode data to base64 and null-terminate.
 
 ### Parameters
-* `out`: buffer for encoded data 
-
-* `out_size`: size in bytes of the out buffer (including the null terminator), must be at least [`AV_BASE64_SIZE`](@ref)(in\\_size) 
-
-* `in`: input buffer containing the data to encode 
-
-* `in_size`: size in bytes of the in buffer 
-
+* `out`: buffer for encoded data
+* `out_size`: size in bytes of the out buffer (including the null terminator), must be at least [`AV_BASE64_SIZE`](@ref)(in\\_size)
+* `in`: input buffer containing the data to encode
+* `in_size`: size in bytes of the in buffer
 ### Returns
 out or NULL in case of error
 """
@@ -11211,10 +10639,8 @@ end
 Initialize an [`AVBlowfish`](@ref) context.
 
 ### Parameters
-* `ctx`: an [`AVBlowfish`](@ref) context 
-
-* `key`: a key 
-
+* `ctx`: an [`AVBlowfish`](@ref) context
+* `key`: a key
 * `key_len`: length of the key
 """
 function av_blowfish_init(ctx, key, key_len::Integer)
@@ -11227,12 +10653,9 @@ end
 Encrypt or decrypt a buffer using a previously initialized context.
 
 ### Parameters
-* `ctx`: an [`AVBlowfish`](@ref) context 
-
-* `xl`: left four bytes halves of input to be encrypted 
-
-* `xr`: right four bytes halves of input to be encrypted 
-
+* `ctx`: an [`AVBlowfish`](@ref) context
+* `xl`: left four bytes halves of input to be encrypted
+* `xr`: right four bytes halves of input to be encrypted
 * `decrypt`: 0 for encryption, 1 for decryption
 """
 function av_blowfish_crypt_ecb(ctx, xl, xr, decrypt::Integer)
@@ -11245,16 +10668,11 @@ end
 Encrypt or decrypt a buffer using a previously initialized context.
 
 ### Parameters
-* `ctx`: an [`AVBlowfish`](@ref) context 
-
-* `dst`: destination array, can be equal to src 
-
-* `src`: source array, can be equal to dst 
-
-* `count`: number of 8 byte blocks 
-
-* `iv`: initialization vector for CBC mode, if NULL ECB will be used 
-
+* `ctx`: an [`AVBlowfish`](@ref) context
+* `dst`: destination array, can be equal to src
+* `src`: source array, can be equal to dst
+* `count`: number of 8 byte blocks
+* `iv`: initialization vector for CBC mode, if NULL ECB will be used
 * `decrypt`: 0 for encryption, 1 for decryption
 """
 function av_blowfish_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)
@@ -11275,11 +10693,9 @@ end
 Init a print buffer.
 
 ### Parameters
-* `buf`: buffer to init 
-
-* `size_init`: initial size (including the final 0) 
-
-* `size_max`: maximum size; 0 means do not write anything, just count the length; 1 is replaced by the maximum value for automatic storage; any large value means that the internal buffer will be reallocated as needed up to that limit; -1 is converted to UINT\\_MAX, the largest limit possible. Check also AV\\_BPRINT\\_SIZE\\_* macros.
+* `buf`: buffer to init
+* `size_init`: initial size (including the final 0)
+* `size_max`: maximum size; - `0` means do not write anything, just count the length - `1` is replaced by the maximum value for automatic storage any large value means that the internal buffer will be reallocated as needed up to that limit - `-1` is converted to `UINT_MAX`, the largest limit possible. Check also `AV\\_BPRINT\\_SIZE\\_*` macros.
 """
 function av_bprint_init(buf, size_init::Integer, size_max::Integer)
     ccall((:av_bprint_init, libavutil), Cvoid, (Ptr{AVBPrint}, Cuint, Cuint), buf, size_init, size_max)
@@ -11290,13 +10706,11 @@ end
 
 Init a print buffer using a pre-existing buffer.
 
-The buffer will not be reallocated.
+The buffer will not be reallocated. In case size equals zero, the [`AVBPrint`](@ref) will be initialized to use the internal buffer as if using [`AV_BPRINT_SIZE_COUNT_ONLY`](@ref) with [`av_bprint_init`](@ref)().
 
 ### Parameters
-* `buf`: buffer structure to init 
-
-* `buffer`: byte buffer to use for the string data 
-
+* `buf`: buffer structure to init
+* `buffer`: byte buffer to use for the string data
 * `size`: size of buffer
 """
 function av_bprint_init_for_buffer(buf, buffer, size::Integer)
@@ -11346,12 +10760,9 @@ end
 Allocate bytes in the buffer for external use.
 
 ### Parameters
-* `buf`:\\[in\\] buffer structure 
-
-* `size`:\\[in\\] required size 
-
-* `mem`:\\[out\\] pointer to the memory area 
-
+* `buf`:\\[in\\] buffer structure
+* `size`:\\[in\\] required size
+* `mem`:\\[out\\] pointer to the memory area
 * `actual_size`:\\[out\\] size of the memory area after allocation; can be larger or smaller than size
 """
 function av_bprint_get_buffer(buf, size::Integer, mem, actual_size)
@@ -11385,7 +10796,7 @@ Finalize a print buffer.
 
 The print buffer can no longer be used afterwards, but the len and size fields are still valid.
 
-* [out] ret\\_str if not NULL, used to return a permanent copy of the buffer contents, or NULL if memory allocation fails; if NULL, the buffer is discarded and freed 
+* [out] ret\\_str if not NULL, used to return a permanent copy of the buffer contents, or NULL if memory allocation fails; if NULL, the buffer is discarded and freed
 
 ### Returns
 0 for success or error code (probably [`AVERROR`](@ref)(ENOMEM))
@@ -11400,14 +10811,10 @@ end
 Escape the content in src and append it to dstbuf.
 
 ### Parameters
-* `dstbuf`: already inited destination bprint buffer 
-
-* `src`: string containing the text to escape 
-
-* `special_chars`: string containing the special characters which need to be escaped, can be NULL 
-
-* `mode`: escape mode to employ, see AV\\_ESCAPE\\_MODE\\_* macros. Any unknown value for mode will be considered equivalent to AV\\_ESCAPE\\_MODE\\_BACKSLASH, but this behaviour can change without notice. 
-
+* `dstbuf`: already inited destination bprint buffer
+* `src`: string containing the text to escape
+* `special_chars`: string containing the special characters which need to be escaped, can be NULL
+* `mode`: escape mode to employ, see AV\\_ESCAPE\\_MODE\\_* macros. Any unknown value for mode will be considered equivalent to AV\\_ESCAPE\\_MODE\\_BACKSLASH, but this behaviour can change without notice.
 * `flags`: flags which control how to escape, see AV\\_ESCAPE\\_FLAG\\_* macros
 """
 function av_bprint_escape(dstbuf, src, special_chars, mode::AVEscapeMode, flags::Integer)
@@ -11426,16 +10833,45 @@ function av_bswap64(x::UInt64)
     ccall((:av_bswap64, libavutil), UInt64, (UInt64,), x)
 end
 
-function av_buffer_alloc(size::Integer)
-    ccall((:av_buffer_alloc, libavutil), Ptr{AVBufferRef}, (Cint,), size)
-end
+"""
+    av_buffer_alloc(size::Csize_t)
+
+Allocate an [`AVBuffer`](@ref) of the given size using [`av_malloc`](@ref)().
+
+### Returns
+an [`AVBufferRef`](@ref) of given size or NULL when out of memory
+"""
+function av_buffer_alloc(size::Csize_t)
+    ccall((:av_buffer_alloc, libavutil), Ptr{AVBufferRef}, (Csize_t,), size)
+end
+
+"""
+    av_buffer_allocz(size::Csize_t)
+
+Same as [`av_buffer_alloc`](@ref)(), except the returned buffer will be initialized to zero.
+"""
+function av_buffer_allocz(size::Csize_t)
+    ccall((:av_buffer_allocz, libavutil), Ptr{AVBufferRef}, (Csize_t,), size)
+end
+
+"""
+    av_buffer_create(data, size::Csize_t, free, opaque, flags::Integer)
+
+Create an [`AVBuffer`](@ref) from an existing array.
 
-function av_buffer_allocz(size::Integer)
-    ccall((:av_buffer_allocz, libavutil), Ptr{AVBufferRef}, (Cint,), size)
-end
+If this function is successful, data is owned by the [`AVBuffer`](@ref). The caller may only access data through the returned [`AVBufferRef`](@ref) and references derived from it. If this function fails, data is left untouched.
 
-function av_buffer_create(data, size::Integer, free, opaque, flags::Integer)
-    ccall((:av_buffer_create, libavutil), Ptr{AVBufferRef}, (Ptr{UInt8}, Cint, Ptr{Cvoid}, Ptr{Cvoid}, Cint), data, size, free, opaque, flags)
+### Parameters
+* `data`: data array
+* `size`: size of data in bytes
+* `free`: a callback for freeing this buffer's data
+* `opaque`: parameter to be got for processing or passed to free
+* `flags`: a combination of AV\\_BUFFER\\_FLAG\\_*
+### Returns
+an [`AVBufferRef`](@ref) referring to data on success, NULL on failure.
+"""
+function av_buffer_create(data, size::Csize_t, free, opaque, flags::Integer)
+    ccall((:av_buffer_create, libavutil), Ptr{AVBufferRef}, (Ptr{UInt8}, Csize_t, Ptr{Cvoid}, Ptr{Cvoid}, Cint), data, size, free, opaque, flags)
 end
 
 """
@@ -11501,8 +10937,7 @@ end
 Create a writable reference from a given buffer reference, avoiding data copy if possible.
 
 ### Parameters
-* `buf`: buffer reference to make writable. On success, buf is either left untouched, or it is unreferenced and a new writable [`AVBufferRef`](@ref) is written in its place. On failure, buf is left untouched. 
-
+* `buf`: buffer reference to make writable. On success, buf is either left untouched, or it is unreferenced and a new writable [`AVBufferRef`](@ref) is written in its place. On failure, buf is left untouched.
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) on failure.
 """
@@ -11510,8 +10945,23 @@ function av_buffer_make_writable(buf)
     ccall((:av_buffer_make_writable, libavutil), Cint, (Ptr{Ptr{AVBufferRef}},), buf)
 end
 
-function av_buffer_realloc(buf, size::Integer)
-    ccall((:av_buffer_realloc, libavutil), Cint, (Ptr{Ptr{AVBufferRef}}, Cint), buf, size)
+"""
+    av_buffer_realloc(buf, size::Csize_t)
+
+Reallocate a given buffer.
+
+!!! note
+
+    the buffer is actually reallocated with [`av_realloc`](@ref)() only if it was initially allocated through [`av_buffer_realloc`](@ref)(NULL) and there is only one reference to it (i.e. the one passed to this function). In all other cases a new buffer is allocated and the data is copied.
+
+### Parameters
+* `buf`: a buffer reference to reallocate. On success, buf will be unreferenced and a new reference with the required size will be written in its place. On failure buf will be left untouched. *buf may be NULL, then a new buffer is allocated.
+* `size`: required new buffer size.
+### Returns
+0 on success, a negative [`AVERROR`](@ref) on failure.
+"""
+function av_buffer_realloc(buf, size::Csize_t)
+    ccall((:av_buffer_realloc, libavutil), Cint, (Ptr{Ptr{AVBufferRef}}, Csize_t), buf, size)
 end
 
 """
@@ -11522,10 +10972,8 @@ Ensure dst refers to the same data as src.
 When *dst is already equivalent to src, do nothing. Otherwise unreference dst and replace it with a new reference to src.
 
 ### Parameters
-* `dst`: Pointer to either a valid buffer reference or NULL. On success, this will point to a buffer reference equivalent to src. On failure, dst will be left untouched. 
-
-* `src`: A buffer reference to replace dst with. May be NULL, then this function is equivalent to [`av_buffer_unref`](@ref)(dst). 
-
+* `dst`: Pointer to either a valid buffer reference or NULL. On success, this will point to a buffer reference equivalent to src. On failure, dst will be left untouched.
+* `src`: A buffer reference to replace dst with. May be NULL, then this function is equivalent to [`av_buffer_unref`](@ref)(dst).
 ### Returns
 0 on success [`AVERROR`](@ref)(ENOMEM) on memory allocation failure.
 """
@@ -11535,12 +10983,36 @@ end
 
 mutable struct AVBufferPool end
 
-function av_buffer_pool_init(size::Integer, alloc)
-    ccall((:av_buffer_pool_init, libavutil), Ptr{AVBufferPool}, (Cint, Ptr{Cvoid}), size, alloc)
+"""
+    av_buffer_pool_init(size::Csize_t, alloc)
+
+Allocate and initialize a buffer pool.
+
+### Parameters
+* `size`: size of each buffer in this pool
+* `alloc`: a function that will be used to allocate new buffers when the pool is empty. May be NULL, then the default allocator will be used ([`av_buffer_alloc`](@ref)()).
+### Returns
+newly created buffer pool on success, NULL on error.
+"""
+function av_buffer_pool_init(size::Csize_t, alloc)
+    ccall((:av_buffer_pool_init, libavutil), Ptr{AVBufferPool}, (Csize_t, Ptr{Cvoid}), size, alloc)
 end
 
-function av_buffer_pool_init2(size::Integer, opaque, alloc, pool_free)
-    ccall((:av_buffer_pool_init2, libavutil), Ptr{AVBufferPool}, (Cint, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), size, opaque, alloc, pool_free)
+"""
+    av_buffer_pool_init2(size::Csize_t, opaque, alloc, pool_free)
+
+Allocate and initialize a buffer pool with a more complex allocator.
+
+### Parameters
+* `size`: size of each buffer in this pool
+* `opaque`: arbitrary user data used by the allocator
+* `alloc`: a function that will be used to allocate new buffers when the pool is empty. May be NULL, then the default allocator will be used ([`av_buffer_alloc`](@ref)()).
+* `pool_free`: a function that will be called immediately before the pool is freed. I.e. after [`av_buffer_pool_uninit`](@ref)() is called by the caller and all the frames are returned to the pool and freed. It is intended to uninitialize the user opaque data. May be NULL.
+### Returns
+newly created buffer pool on success, NULL on error.
+"""
+function av_buffer_pool_init2(size::Csize_t, opaque, alloc, pool_free)
+    ccall((:av_buffer_pool_init2, libavutil), Ptr{AVBufferPool}, (Csize_t, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), size, opaque, alloc, pool_free)
 end
 
 """
@@ -11577,8 +11049,7 @@ Query the original opaque parameter of an allocated buffer in the pool.
     the opaque parameter of ref is used by the buffer pool implementation, therefore you have to use this function to access the original opaque parameter of an allocated buffer.
 
 ### Parameters
-* `ref`: a buffer reference to a buffer returned by [`av_buffer_pool_get`](@ref). 
-
+* `ref`: a buffer reference to a buffer returned by [`av_buffer_pool_get`](@ref).
 ### Returns
 the opaque parameter set by the buffer allocator function of the buffer pool.
 """
@@ -11603,10 +11074,8 @@ end
 Initialize an [`AVCAMELLIA`](@ref) context.
 
 ### Parameters
-* `ctx`: an [`AVCAMELLIA`](@ref) context 
-
-* `key`: a key of 16, 24, 32 bytes used for encryption/decryption 
-
+* `ctx`: an [`AVCAMELLIA`](@ref) context
+* `key`: a key of 16, 24, 32 bytes used for encryption/decryption
 * `key_bits`: number of keybits: possible are 128, 192, 256
 """
 function av_camellia_init(ctx, key, key_bits::Integer)
@@ -11619,16 +11088,11 @@ end
 Encrypt or decrypt a buffer using a previously initialized context
 
 ### Parameters
-* `ctx`: an [`AVCAMELLIA`](@ref) context 
-
-* `dst`: destination array, can be equal to src 
-
-* `src`: source array, can be equal to dst 
-
-* `count`: number of 16 byte blocks 
-
-* `iv`: initialization vector for CBC mode, NULL for ECB mode 
-
+* `ctx`: an [`AVCAMELLIA`](@ref) context
+* `dst`: destination array, can be equal to src
+* `src`: source array, can be equal to dst
+* `count`: number of 16 byte blocks
+* `iv`: initialization vector for CBC mode, NULL for ECB mode
 * `decrypt`: 0 for encryption, 1 for decryption
 """
 function av_camellia_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)
@@ -11652,12 +11116,9 @@ end
 Initialize an [`AVCAST5`](@ref) context.
 
 ### Parameters
-* `ctx`: an [`AVCAST5`](@ref) context 
-
-* `key`: a key of 5,6,...16 bytes used for encryption/decryption 
-
-* `key_bits`: number of keybits: possible are 40,48,...,128 
-
+* `ctx`: an [`AVCAST5`](@ref) context
+* `key`: a key of 5,6,...16 bytes used for encryption/decryption
+* `key_bits`: number of keybits: possible are 40,48,...,128
 ### Returns
 0 on success, less than 0 on failure
 """
@@ -11671,14 +11132,10 @@ end
 Encrypt or decrypt a buffer using a previously initialized context, ECB mode only
 
 ### Parameters
-* `ctx`: an [`AVCAST5`](@ref) context 
-
-* `dst`: destination array, can be equal to src 
-
-* `src`: source array, can be equal to dst 
-
-* `count`: number of 8 byte blocks 
-
+* `ctx`: an [`AVCAST5`](@ref) context
+* `dst`: destination array, can be equal to src
+* `src`: source array, can be equal to dst
+* `count`: number of 8 byte blocks
 * `decrypt`: 0 for encryption, 1 for decryption
 """
 function av_cast5_crypt(ctx, dst, src, count::Integer, decrypt::Integer)
@@ -11691,21 +11148,64 @@ end
 Encrypt or decrypt a buffer using a previously initialized context
 
 ### Parameters
-* `ctx`: an [`AVCAST5`](@ref) context 
+* `ctx`: an [`AVCAST5`](@ref) context
+* `dst`: destination array, can be equal to src
+* `src`: source array, can be equal to dst
+* `count`: number of 8 byte blocks
+* `iv`: initialization vector for CBC mode, NULL for ECB mode
+* `decrypt`: 0 for encryption, 1 for decryption
+"""
+function av_cast5_crypt2(ctx, dst, src, count::Integer, iv, decrypt::Integer)
+    ccall((:av_cast5_crypt2, libavutil), Cvoid, (Ptr{AVCAST5}, Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}, Cint), ctx, dst, src, count, iv, decrypt)
+end
 
-* `dst`: destination array, can be equal to src 
+"""
+    AVChannel
 
-* `src`: source array, can be equal to dst 
+` lavu_audio_channels Audio channels`
 
-* `count`: number of 8 byte blocks 
+` lavu_audio`
 
-* `iv`: initialization vector for CBC mode, NULL for ECB mode 
+Audio channel layout utility functions
 
-* `decrypt`: 0 for encryption, 1 for decryption
+@{
 """
-function av_cast5_crypt2(ctx, dst, src, count::Integer, iv, decrypt::Integer)
-    ccall((:av_cast5_crypt2, libavutil), Cvoid, (Ptr{AVCAST5}, Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}, Cint), ctx, dst, src, count, iv, decrypt)
-end
+const AVChannel = Int32
+const AV_CHAN_NONE = -1 % Int32
+const AV_CHAN_FRONT_LEFT = 0 % Int32
+const AV_CHAN_FRONT_RIGHT = 1 % Int32
+const AV_CHAN_FRONT_CENTER = 2 % Int32
+const AV_CHAN_LOW_FREQUENCY = 3 % Int32
+const AV_CHAN_BACK_LEFT = 4 % Int32
+const AV_CHAN_BACK_RIGHT = 5 % Int32
+const AV_CHAN_FRONT_LEFT_OF_CENTER = 6 % Int32
+const AV_CHAN_FRONT_RIGHT_OF_CENTER = 7 % Int32
+const AV_CHAN_BACK_CENTER = 8 % Int32
+const AV_CHAN_SIDE_LEFT = 9 % Int32
+const AV_CHAN_SIDE_RIGHT = 10 % Int32
+const AV_CHAN_TOP_CENTER = 11 % Int32
+const AV_CHAN_TOP_FRONT_LEFT = 12 % Int32
+const AV_CHAN_TOP_FRONT_CENTER = 13 % Int32
+const AV_CHAN_TOP_FRONT_RIGHT = 14 % Int32
+const AV_CHAN_TOP_BACK_LEFT = 15 % Int32
+const AV_CHAN_TOP_BACK_CENTER = 16 % Int32
+const AV_CHAN_TOP_BACK_RIGHT = 17 % Int32
+const AV_CHAN_STEREO_LEFT = 29 % Int32
+const AV_CHAN_STEREO_RIGHT = 30 % Int32
+const AV_CHAN_WIDE_LEFT = 31 % Int32
+const AV_CHAN_WIDE_RIGHT = 32 % Int32
+const AV_CHAN_SURROUND_DIRECT_LEFT = 33 % Int32
+const AV_CHAN_SURROUND_DIRECT_RIGHT = 34 % Int32
+const AV_CHAN_LOW_FREQUENCY_2 = 35 % Int32
+const AV_CHAN_TOP_SIDE_LEFT = 36 % Int32
+const AV_CHAN_TOP_SIDE_RIGHT = 37 % Int32
+const AV_CHAN_BOTTOM_FRONT_CENTER = 38 % Int32
+const AV_CHAN_BOTTOM_FRONT_LEFT = 39 % Int32
+const AV_CHAN_BOTTOM_FRONT_RIGHT = 40 % Int32
+const AV_CHAN_UNUSED = 512 % Int32
+const AV_CHAN_UNKNOWN = 768 % Int32
+const AV_CHAN_AMBISONIC_BASE = 1024 % Int32
+const AV_CHAN_AMBISONIC_END = 2047 % Int32
 
 const AVMatrixEncoding = UInt32
 const AV_MATRIX_ENCODING_NONE = 0 % UInt32
@@ -11717,6 +11217,21 @@ const AV_MATRIX_ENCODING_DOLBYEX = 5 % UInt32
 const AV_MATRIX_ENCODING_DOLBYHEADPHONE = 6 % UInt32
 const AV_MATRIX_ENCODING_NB = 7 % UInt32
 
+"""
+    AVChannelCustom
+
+An [`AVChannelCustom`](@ref) defines a single channel within a custom order layout
+
+Unlike most structures in FFmpeg, sizeof([`AVChannelCustom`](@ref)) is a part of the public ABI.
+
+No new fields may be added to it without a major version bump.
+"""
+struct AVChannelCustom
+    id::AVChannel
+    name::NTuple{16, Cchar}
+    opaque::Ptr{Cvoid}
+end
+
 """
     av_get_channel_layout(name)
 
@@ -11726,6 +11241,8 @@ name can be one or several of the following notations, separated by '+' or '|':
 
 Example: "stereo+FC" = "2c+FC" = "2c+1c" = "0x7"
 
+\\deprecated use [`av_channel_layout_from_string`](@ref)()
+
 ### See also
 [`av_get_default_channel_layout`](@ref)); - a channel layout mask, in hexadecimal starting with "0x" (see the AV\\_CH\\_* macros).
 """
@@ -11740,16 +11257,14 @@ Return a channel layout and the number of channels based on the specified name.
 
 This function is similar to (
 
-### Parameters
-* `name`:\\[in\\] channel layout specification string 
-
-* `channel_layout`:\\[out\\] parsed channel layout (0 if unknown) 
+\\deprecated use [`av_channel_layout_from_string`](@ref)()
 
+### Parameters
+* `name`:\\[in\\] channel layout specification string
+* `channel_layout`:\\[out\\] parsed channel layout (0 if unknown)
 * `nb_channels`:\\[out\\] number of channels
-
 ### Returns
 0 on success, [`AVERROR`](@ref)(EINVAL) if the parsing fails.
-
 ### See also
 [`av_get_channel_layout`](@ref)), but can also parse unknown channel layout specifications.
 """
@@ -11762,10 +11277,13 @@ end
 
 Return a description of a channel layout. If nb\\_channels is <= 0, it is guessed from the channel\\_layout.
 
-### Parameters
-* `buf`: put here the string containing the channel layout 
+\\deprecated use [`av_channel_layout_describe`](@ref)()
 
+### Parameters
+* `buf`: put here the string containing the channel layout
 * `buf_size`: size in bytes of the buffer
+* `nb_channels`: number of channels
+* `channel_layout`: channel layout bitset
 """
 function av_get_channel_layout_string(buf, buf_size::Integer, nb_channels::Integer, channel_layout::UInt64)
     ccall((:av_get_channel_layout_string, libavutil), Cvoid, (Cstring, Cint, Cint, UInt64), buf, buf_size, nb_channels, channel_layout)
@@ -11774,108 +11292,419 @@ end
 """
     av_bprint_channel_layout(bp, nb_channels::Integer, channel_layout::UInt64)
 
-Append a description of a channel layout to a bprint buffer.
+Append a description of a channel layout to a bprint buffer.
+
+\\deprecated use [`av_channel_layout_describe`](@ref)()
+"""
+function av_bprint_channel_layout(bp, nb_channels::Integer, channel_layout::UInt64)
+    ccall((:av_bprint_channel_layout, libavutil), Cvoid, (Ptr{AVBPrint}, Cint, UInt64), bp, nb_channels, channel_layout)
+end
+
+"""
+    av_get_channel_layout_nb_channels(channel_layout::UInt64)
+
+Return the number of channels in the channel layout.
+
+\\deprecated use [`AVChannelLayout`](@ref).nb\\_channels
+"""
+function av_get_channel_layout_nb_channels(channel_layout::UInt64)
+    ccall((:av_get_channel_layout_nb_channels, libavutil), Cint, (UInt64,), channel_layout)
+end
+
+"""
+    av_get_default_channel_layout(nb_channels::Integer)
+
+Return default channel layout for a given number of channels.
+
+\\deprecated use [`av_channel_layout_default`](@ref)()
+"""
+function av_get_default_channel_layout(nb_channels::Integer)
+    ccall((:av_get_default_channel_layout, libavutil), Int64, (Cint,), nb_channels)
+end
+
+"""
+    av_get_channel_layout_channel_index(channel_layout::UInt64, channel::UInt64)
+
+Get the index of a channel in channel\\_layout.
+
+\\deprecated use [`av_channel_layout_index_from_channel`](@ref)()
+
+### Parameters
+* `channel_layout`: channel layout bitset
+* `channel`: a channel layout describing exactly one channel which must be present in channel\\_layout.
+### Returns
+index of channel in channel\\_layout on success, a negative [`AVERROR`](@ref) on error.
+"""
+function av_get_channel_layout_channel_index(channel_layout::UInt64, channel::UInt64)
+    ccall((:av_get_channel_layout_channel_index, libavutil), Cint, (UInt64, UInt64), channel_layout, channel)
+end
+
+"""
+    av_channel_layout_extract_channel(channel_layout::UInt64, index::Integer)
+
+Get the channel with the given index in channel\\_layout.
+
+\\deprecated use [`av_channel_layout_channel_from_index`](@ref)()
+"""
+function av_channel_layout_extract_channel(channel_layout::UInt64, index::Integer)
+    ccall((:av_channel_layout_extract_channel, libavutil), UInt64, (UInt64, Cint), channel_layout, index)
+end
+
+"""
+    av_get_channel_name(channel::UInt64)
+
+Get the name of a given channel.
+
+\\deprecated use [`av_channel_name`](@ref)()
+
+### Returns
+channel name on success, NULL on error.
+"""
+function av_get_channel_name(channel::UInt64)
+    ccall((:av_get_channel_name, libavutil), Cstring, (UInt64,), channel)
+end
+
+"""
+    av_get_channel_description(channel::UInt64)
+
+Get the description of a given channel.
+
+\\deprecated use [`av_channel_description`](@ref)()
+
+### Parameters
+* `channel`: a channel layout with a single channel
+### Returns
+channel description on success, NULL on error
+"""
+function av_get_channel_description(channel::UInt64)
+    ccall((:av_get_channel_description, libavutil), Cstring, (UInt64,), channel)
+end
+
+"""
+    av_get_standard_channel_layout(index::Integer, layout, name)
+
+Get the value and name of a standard channel layout.
+
+\\deprecated use [`av_channel_layout_standard`](@ref)()
+
+### Parameters
+* `index`:\\[in\\] index in an internal list, starting at 0
+* `layout`:\\[out\\] channel layout mask
+* `name`:\\[out\\] name of the layout
+### Returns
+0 if the layout exists, <0 if index is beyond the limits
+"""
+function av_get_standard_channel_layout(index::Integer, layout, name)
+    ccall((:av_get_standard_channel_layout, libavutil), Cint, (Cuint, Ptr{UInt64}, Ptr{Cstring}), index, layout, name)
+end
+
+"""
+    av_channel_name(buf, buf_size::Csize_t, channel::AVChannel)
+
+Get a human readable string in an abbreviated form describing a given channel. This is the inverse function of av_channel_from_string().
+
+### Parameters
+* `buf`: pre-allocated buffer where to put the generated string
+* `buf_size`: size in bytes of the buffer.
+* `channel`: the [`AVChannel`](@ref) whose name to get
+### Returns
+amount of bytes needed to hold the output string, or a negative [`AVERROR`](@ref) on failure. If the returned value is bigger than buf\\_size, then the string was truncated.
+"""
+function av_channel_name(buf, buf_size::Csize_t, channel::AVChannel)
+    ccall((:av_channel_name, libavutil), Cint, (Cstring, Csize_t, AVChannel), buf, buf_size, channel)
+end
+
+"""
+    av_channel_name_bprint(bp, channel_id::AVChannel)
+
+bprint variant of [`av_channel_name`](@ref)().
+
+!!! note
+
+    the string will be appended to the bprint buffer.
+"""
+function av_channel_name_bprint(bp, channel_id::AVChannel)
+    ccall((:av_channel_name_bprint, libavutil), Cvoid, (Ptr{AVBPrint}, AVChannel), bp, channel_id)
+end
+
+"""
+    av_channel_description(buf, buf_size::Csize_t, channel::AVChannel)
+
+Get a human readable string describing a given channel.
+
+### Parameters
+* `buf`: pre-allocated buffer where to put the generated string
+* `buf_size`: size in bytes of the buffer.
+* `channel`: the [`AVChannel`](@ref) whose description to get
+### Returns
+amount of bytes needed to hold the output string, or a negative [`AVERROR`](@ref) on failure. If the returned value is bigger than buf\\_size, then the string was truncated.
+"""
+function av_channel_description(buf, buf_size::Csize_t, channel::AVChannel)
+    ccall((:av_channel_description, libavutil), Cint, (Cstring, Csize_t, AVChannel), buf, buf_size, channel)
+end
+
+"""
+    av_channel_description_bprint(bp, channel_id::AVChannel)
+
+bprint variant of [`av_channel_description`](@ref)().
+
+!!! note
+
+    the string will be appended to the bprint buffer.
+"""
+function av_channel_description_bprint(bp, channel_id::AVChannel)
+    ccall((:av_channel_description_bprint, libavutil), Cvoid, (Ptr{AVBPrint}, AVChannel), bp, channel_id)
+end
+
+"""
+    av_channel_from_string(name)
+
+This is the inverse function of av_channel_name().
+
+### Returns
+the channel with the given name AV\\_CHAN\\_NONE when name does not identify a known channel
+"""
+function av_channel_from_string(name)
+    ccall((:av_channel_from_string, libavutil), AVChannel, (Cstring,), name)
+end
+
+"""
+    av_channel_layout_from_mask(channel_layout, mask::UInt64)
+
+Initialize a native channel layout from a bitmask indicating which channels are present.
+
+### Parameters
+* `channel_layout`: the layout structure to be initialized
+* `mask`: bitmask describing the channel layout
+### Returns
+0 on success [`AVERROR`](@ref)(EINVAL) for invalid mask values
+"""
+function av_channel_layout_from_mask(channel_layout, mask::UInt64)
+    ccall((:av_channel_layout_from_mask, libavutil), Cint, (Ptr{AVChannelLayout}, UInt64), channel_layout, mask)
+end
+
+"""
+    av_channel_layout_from_string(channel_layout, str)
+
+Initialize a channel layout from a given string description. The input string can be represented by: - the formal channel layout name (returned by [`av_channel_layout_describe`](@ref)()) - single or multiple channel names (returned by [`av_channel_name`](@ref)(), eg. "FL", or concatenated with "+", each optionally containing a custom name after a "@", eg. "FL@Left+FR@Right+LFE") - a decimal or hexadecimal value of a native channel layout (eg. "4" or "0x4") - the number of channels with default layout (eg. "4c") - the number of unordered channels (eg. "4C" or "4 channels") - the ambisonic order followed by optional non-diegetic channels (eg. "ambisonic 2+stereo")
+
+### Parameters
+* `channel_layout`: input channel layout
+* `str`: string describing the channel layout
+### Returns
+0 channel layout was detected, AVERROR\\_INVALIDATATA otherwise
+"""
+function av_channel_layout_from_string(channel_layout, str)
+    ccall((:av_channel_layout_from_string, libavutil), Cint, (Ptr{AVChannelLayout}, Cstring), channel_layout, str)
+end
+
+"""
+    av_channel_layout_default(ch_layout, nb_channels::Integer)
+
+Get the default channel layout for a given number of channels.
+
+### Parameters
+* `ch_layout`: the layout structure to be initialized
+* `nb_channels`: number of channels
+"""
+function av_channel_layout_default(ch_layout, nb_channels::Integer)
+    ccall((:av_channel_layout_default, libavutil), Cvoid, (Ptr{AVChannelLayout}, Cint), ch_layout, nb_channels)
+end
+
+"""
+    av_channel_layout_standard(opaque)
+
+Iterate over all standard channel layouts.
+
+### Parameters
+* `opaque`: a pointer where libavutil will store the iteration state. Must point to NULL to start the iteration.
+### Returns
+the standard channel layout or NULL when the iteration is finished
+"""
+function av_channel_layout_standard(opaque)
+    ccall((:av_channel_layout_standard, libavutil), Ptr{AVChannelLayout}, (Ptr{Ptr{Cvoid}},), opaque)
+end
+
+"""
+    av_channel_layout_uninit(channel_layout)
+
+Free any allocated data in the channel layout and reset the channel count to 0.
+
+### Parameters
+* `channel_layout`: the layout structure to be uninitialized
+"""
+function av_channel_layout_uninit(channel_layout)
+    ccall((:av_channel_layout_uninit, libavutil), Cvoid, (Ptr{AVChannelLayout},), channel_layout)
+end
+
+"""
+    av_channel_layout_copy(dst, src)
+
+Make a copy of a channel layout. This differs from just assigning src to dst in that it allocates and copies the map for AV\\_CHANNEL\\_ORDER\\_CUSTOM.
+
+!!! note
+
+    the destination channel\\_layout will be always uninitialized before copy.
+
+### Parameters
+* `dst`: destination channel layout
+* `src`: source channel layout
+### Returns
+0 on success, a negative [`AVERROR`](@ref) on error.
+"""
+function av_channel_layout_copy(dst, src)
+    ccall((:av_channel_layout_copy, libavutil), Cint, (Ptr{AVChannelLayout}, Ptr{AVChannelLayout}), dst, src)
+end
+
+"""
+    av_channel_layout_describe(channel_layout, buf, buf_size::Csize_t)
+
+Get a human-readable string describing the channel layout properties. The string will be in the same format that is accepted by av_channel_layout_from_string(), allowing to rebuild the same channel layout, except for opaque pointers.
+
+### Parameters
+* `channel_layout`: channel layout to be described
+* `buf`: pre-allocated buffer where to put the generated string
+* `buf_size`: size in bytes of the buffer.
+### Returns
+amount of bytes needed to hold the output string, or a negative [`AVERROR`](@ref) on failure. If the returned value is bigger than buf\\_size, then the string was truncated.
 """
-function av_bprint_channel_layout(bp, nb_channels::Integer, channel_layout::UInt64)
-    ccall((:av_bprint_channel_layout, libavutil), Cvoid, (Ptr{AVBPrint}, Cint, UInt64), bp, nb_channels, channel_layout)
+function av_channel_layout_describe(channel_layout, buf, buf_size::Csize_t)
+    ccall((:av_channel_layout_describe, libavutil), Cint, (Ptr{AVChannelLayout}, Cstring, Csize_t), channel_layout, buf, buf_size)
 end
 
 """
-    av_get_channel_layout_nb_channels(channel_layout::UInt64)
+    av_channel_layout_describe_bprint(channel_layout, bp)
 
-Return the number of channels in the channel layout.
+bprint variant of [`av_channel_layout_describe`](@ref)().
+
+!!! note
+
+    the string will be appended to the bprint buffer.
+
+### Returns
+0 on success, or a negative [`AVERROR`](@ref) value on failure.
 """
-function av_get_channel_layout_nb_channels(channel_layout::UInt64)
-    ccall((:av_get_channel_layout_nb_channels, libavutil), Cint, (UInt64,), channel_layout)
+function av_channel_layout_describe_bprint(channel_layout, bp)
+    ccall((:av_channel_layout_describe_bprint, libavutil), Cint, (Ptr{AVChannelLayout}, Ptr{AVBPrint}), channel_layout, bp)
 end
 
 """
-    av_get_default_channel_layout(nb_channels::Integer)
+    av_channel_layout_channel_from_index(channel_layout, idx::Integer)
 
-Return default channel layout for a given number of channels.
+Get the channel with the given index in a channel layout.
+
+### Parameters
+* `channel_layout`: input channel layout
+* `idx`: index of the channel
+### Returns
+channel with the index idx in channel\\_layout on success or AV\\_CHAN\\_NONE on failure (if idx is not valid or the channel order is unspecified)
 """
-function av_get_default_channel_layout(nb_channels::Integer)
-    ccall((:av_get_default_channel_layout, libavutil), Int64, (Cint,), nb_channels)
+function av_channel_layout_channel_from_index(channel_layout, idx::Integer)
+    ccall((:av_channel_layout_channel_from_index, libavutil), AVChannel, (Ptr{AVChannelLayout}, Cuint), channel_layout, idx)
 end
 
 """
-    av_get_channel_layout_channel_index(channel_layout::UInt64, channel::UInt64)
+    av_channel_layout_index_from_channel(channel_layout, channel::AVChannel)
 
-Get the index of a channel in channel\\_layout.
+Get the index of a given channel in a channel layout. In case multiple channels are found, only the first match will be returned.
 
 ### Parameters
-* `channel`: a channel layout describing exactly one channel which must be present in channel\\_layout.
-
+* `channel_layout`: input channel layout
+* `channel`: the channel whose index to obtain
 ### Returns
-index of channel in channel\\_layout on success, a negative [`AVERROR`](@ref) on error.
+index of channel in channel\\_layout on success or a negative number if channel is not present in channel\\_layout.
 """
-function av_get_channel_layout_channel_index(channel_layout::UInt64, channel::UInt64)
-    ccall((:av_get_channel_layout_channel_index, libavutil), Cint, (UInt64, UInt64), channel_layout, channel)
+function av_channel_layout_index_from_channel(channel_layout, channel::AVChannel)
+    ccall((:av_channel_layout_index_from_channel, libavutil), Cint, (Ptr{AVChannelLayout}, AVChannel), channel_layout, channel)
 end
 
 """
-    av_channel_layout_extract_channel(channel_layout::UInt64, index::Integer)
+    av_channel_layout_index_from_string(channel_layout, name)
 
-Get the channel with the given index in channel\\_layout.
+Get the index in a channel layout of a channel described by the given string. In case multiple channels are found, only the first match will be returned.
+
+This function accepts channel names in the same format as av_channel_from_string().
+
+### Parameters
+* `channel_layout`: input channel layout
+* `name`: string describing the channel whose index to obtain
+### Returns
+a channel index described by the given string, or a negative [`AVERROR`](@ref) value.
 """
-function av_channel_layout_extract_channel(channel_layout::UInt64, index::Integer)
-    ccall((:av_channel_layout_extract_channel, libavutil), UInt64, (UInt64, Cint), channel_layout, index)
+function av_channel_layout_index_from_string(channel_layout, name)
+    ccall((:av_channel_layout_index_from_string, libavutil), Cint, (Ptr{AVChannelLayout}, Cstring), channel_layout, name)
 end
 
 """
-    av_get_channel_name(channel::UInt64)
+    av_channel_layout_channel_from_string(channel_layout, name)
 
-Get the name of a given channel.
+Get a channel described by the given string.
+
+This function accepts channel names in the same format as av_channel_from_string().
 
+### Parameters
+* `channel_layout`: input channel layout
+* `name`: string describing the channel to obtain
 ### Returns
-channel name on success, NULL on error.
+a channel described by the given string in channel\\_layout on success or AV\\_CHAN\\_NONE on failure (if the string is not valid or the channel order is unspecified)
 """
-function av_get_channel_name(channel::UInt64)
-    ccall((:av_get_channel_name, libavutil), Cstring, (UInt64,), channel)
+function av_channel_layout_channel_from_string(channel_layout, name)
+    ccall((:av_channel_layout_channel_from_string, libavutil), AVChannel, (Ptr{AVChannelLayout}, Cstring), channel_layout, name)
 end
 
 """
-    av_get_channel_description(channel::UInt64)
+    av_channel_layout_subset(channel_layout, mask::UInt64)
 
-Get the description of a given channel.
+Find out what channels from a given set are present in a channel layout, without regard for their positions.
 
 ### Parameters
-* `channel`: a channel layout with a single channel 
-
+* `channel_layout`: input channel layout
+* `mask`: a combination of AV\\_CH\\_* representing a set of channels
 ### Returns
-channel description on success, NULL on error
+a bitfield representing all the channels from mask that are present in channel\\_layout
 """
-function av_get_channel_description(channel::UInt64)
-    ccall((:av_get_channel_description, libavutil), Cstring, (UInt64,), channel)
+function av_channel_layout_subset(channel_layout, mask::UInt64)
+    ccall((:av_channel_layout_subset, libavutil), UInt64, (Ptr{AVChannelLayout}, UInt64), channel_layout, mask)
 end
 
 """
-    av_get_standard_channel_layout(index::Integer, layout, name)
+    av_channel_layout_check(channel_layout)
 
-Get the value and name of a standard channel layout.
+Check whether a channel layout is valid, i.e. can possibly describe audio data.
 
 ### Parameters
-* `index`:\\[in\\] index in an internal list, starting at 0 
+* `channel_layout`: input channel layout
+### Returns
+1 if channel\\_layout is valid, 0 otherwise.
+"""
+function av_channel_layout_check(channel_layout)
+    ccall((:av_channel_layout_check, libavutil), Cint, (Ptr{AVChannelLayout},), channel_layout)
+end
+
+"""
+    av_channel_layout_compare(chl, chl1)
 
-* `layout`:\\[out\\] channel layout mask 
+Check whether two channel layouts are semantically the same, i.e. the same channels are present on the same positions in both.
 
-* `name`:\\[out\\] name of the layout 
+If one of the channel layouts is AV\\_CHANNEL\\_ORDER\\_UNSPEC, while the other is not, they are considered to be unequal. If both are AV\\_CHANNEL\\_ORDER\\_UNSPEC, they are considered equal iff the channel counts are the same in both.
 
+### Parameters
+* `chl`: input channel layout
+* `chl1`: input channel layout
 ### Returns
-0 if the layout exists, <0 if index is beyond the limits
+0 if chl and chl1 are equal, 1 if they are not equal. A negative [`AVERROR`](@ref) code if one or both are invalid.
 """
-function av_get_standard_channel_layout(index::Integer, layout, name)
-    ccall((:av_get_standard_channel_layout, libavutil), Cint, (Cuint, Ptr{UInt64}, Ptr{Cstring}), index, layout, name)
+function av_channel_layout_compare(chl, chl1)
+    ccall((:av_channel_layout_compare, libavutil), Cint, (Ptr{AVChannelLayout}, Ptr{AVChannelLayout}), chl, chl1)
 end
 
 """
     av_ceil_log2_c(x::Integer)
 
-Compute ceil(log2(x)). 
+Compute ceil(log2(x)).
 
 ### Parameters
-* `x`: value used to compute ceil(log2(x)) 
-
+* `x`: value used to compute ceil(log2(x))
 ### Returns
 computed ceiling of log2(x)
 """
@@ -11886,15 +11715,12 @@ end
 """
     av_clip_c(a::Integer, amin::Integer, amax::Integer)
 
-Clip a signed integer value into the amin-amax range. 
+Clip a signed integer value into the amin-amax range.
 
 ### Parameters
-* `a`: value to clip 
-
-* `amin`: minimum value of the clip range 
-
-* `amax`: maximum value of the clip range 
-
+* `a`: value to clip
+* `amin`: minimum value of the clip range
+* `amax`: maximum value of the clip range
 ### Returns
 clipped value
 """
@@ -11905,15 +11731,12 @@ end
 """
     av_clip64_c(a::Int64, amin::Int64, amax::Int64)
 
-Clip a signed 64bit integer value into the amin-amax range. 
+Clip a signed 64bit integer value into the amin-amax range.
 
 ### Parameters
-* `a`: value to clip 
-
-* `amin`: minimum value of the clip range 
-
-* `amax`: maximum value of the clip range 
-
+* `a`: value to clip
+* `amin`: minimum value of the clip range
+* `amax`: maximum value of the clip range
 ### Returns
 clipped value
 """
@@ -11924,11 +11747,10 @@ end
 """
     av_clip_uint8_c(a::Integer)
 
-Clip a signed integer value into the 0-255 range. 
+Clip a signed integer value into the 0-255 range.
 
 ### Parameters
-* `a`: value to clip 
-
+* `a`: value to clip
 ### Returns
 clipped value
 """
@@ -11939,11 +11761,10 @@ end
 """
     av_clip_int8_c(a::Integer)
 
-Clip a signed integer value into the -128,127 range. 
+Clip a signed integer value into the -128,127 range.
 
 ### Parameters
-* `a`: value to clip 
-
+* `a`: value to clip
 ### Returns
 clipped value
 """
@@ -11954,11 +11775,10 @@ end
 """
     av_clip_uint16_c(a::Integer)
 
-Clip a signed integer value into the 0-65535 range. 
+Clip a signed integer value into the 0-65535 range.
 
 ### Parameters
-* `a`: value to clip 
-
+* `a`: value to clip
 ### Returns
 clipped value
 """
@@ -11969,11 +11789,10 @@ end
 """
     av_clip_int16_c(a::Integer)
 
-Clip a signed integer value into the -32768,32767 range. 
+Clip a signed integer value into the -32768,32767 range.
 
 ### Parameters
-* `a`: value to clip 
-
+* `a`: value to clip
 ### Returns
 clipped value
 """
@@ -11984,11 +11803,10 @@ end
 """
     av_clipl_int32_c(a::Int64)
 
-Clip a signed 64-bit integer value into the -2147483648,2147483647 range. 
+Clip a signed 64-bit integer value into the -2147483648,2147483647 range.
 
 ### Parameters
-* `a`: value to clip 
-
+* `a`: value to clip
 ### Returns
 clipped value
 """
@@ -11999,13 +11817,11 @@ end
 """
     av_clip_intp2_c(a::Integer, p::Integer)
 
-Clip a signed integer into the -(2^p),(2^p-1) range. 
+Clip a signed integer into the -(2^p),(2^p-1) range.
 
 ### Parameters
-* `a`: value to clip 
-
-* `p`: bit position to clip at 
-
+* `a`: value to clip
+* `p`: bit position to clip at
 ### Returns
 clipped value
 """
@@ -12016,13 +11832,11 @@ end
 """
     av_clip_uintp2_c(a::Integer, p::Integer)
 
-Clip a signed integer to an unsigned power of two range. 
+Clip a signed integer to an unsigned power of two range.
 
 ### Parameters
-* `a`: value to clip 
-
-* `p`: bit position to clip at 
-
+* `a`: value to clip
+* `p`: bit position to clip at
 ### Returns
 clipped value
 """
@@ -12033,13 +11847,11 @@ end
 """
     av_mod_uintp2_c(a::Integer, p::Integer)
 
-Clear high bits from an unsigned integer starting with specific bit position 
+Clear high bits from an unsigned integer starting with specific bit position
 
 ### Parameters
-* `a`: value to clip 
-
-* `p`: bit position to clip at 
-
+* `a`: value to clip
+* `p`: bit position to clip at
 ### Returns
 clipped value
 """
@@ -12053,10 +11865,8 @@ end
 Add two signed 32-bit values with saturation.
 
 ### Parameters
-* `a`: one value 
-
-* `b`: another value 
-
+* `a`: one value
+* `b`: another value
 ### Returns
 sum with signed saturation
 """
@@ -12070,10 +11880,8 @@ end
 Add a doubled value to another value with saturation at both stages.
 
 ### Parameters
-* `a`: first value 
-
-* `b`: value doubled and added to a 
-
+* `a`: first value
+* `b`: value doubled and added to a
 ### Returns
 sum sat(a + sat(2*b)) with signed saturation
 """
@@ -12087,10 +11895,8 @@ end
 Subtract two signed 32-bit values with saturation.
 
 ### Parameters
-* `a`: one value 
-
-* `b`: another value 
-
+* `a`: one value
+* `b`: another value
 ### Returns
 difference with signed saturation
 """
@@ -12104,10 +11910,8 @@ end
 Subtract a doubled value from another value with saturation at both stages.
 
 ### Parameters
-* `a`: first value 
-
-* `b`: value doubled and subtracted from a 
-
+* `a`: first value
+* `b`: value doubled and subtracted from a
 ### Returns
 difference sat(a - sat(2*b)) with signed saturation
 """
@@ -12121,10 +11925,8 @@ end
 Add two signed 64-bit values with saturation.
 
 ### Parameters
-* `a`: one value 
-
-* `b`: another value 
-
+* `a`: one value
+* `b`: another value
 ### Returns
 sum with signed saturation
 """
@@ -12138,10 +11940,8 @@ end
 Subtract two signed 64-bit values with saturation.
 
 ### Parameters
-* `a`: one value 
-
-* `b`: another value 
-
+* `a`: one value
+* `b`: another value
 ### Returns
 difference with signed saturation
 """
@@ -12152,15 +11952,12 @@ end
 """
     av_clipf_c(a::Cfloat, amin::Cfloat, amax::Cfloat)
 
-Clip a float value into the amin-amax range. 
+Clip a float value into the amin-amax range. If a is nan or -inf amin will be returned. If a is +inf amax will be returned.
 
 ### Parameters
-* `a`: value to clip 
-
-* `amin`: minimum value of the clip range 
-
-* `amax`: maximum value of the clip range 
-
+* `a`: value to clip
+* `amin`: minimum value of the clip range
+* `amax`: maximum value of the clip range
 ### Returns
 clipped value
 """
@@ -12171,15 +11968,12 @@ end
 """
     av_clipd_c(a::Cdouble, amin::Cdouble, amax::Cdouble)
 
-Clip a double value into the amin-amax range. 
+Clip a double value into the amin-amax range. If a is nan or -inf amin will be returned. If a is +inf amax will be returned.
 
 ### Parameters
-* `a`: value to clip 
-
-* `amin`: minimum value of the clip range 
-
-* `amax`: maximum value of the clip range 
-
+* `a`: value to clip
+* `amin`: minimum value of the clip range
+* `amax`: maximum value of the clip range
 ### Returns
 clipped value
 """
@@ -12190,11 +11984,10 @@ end
 """
     av_popcount_c(x::Integer)
 
-Count number of bits set to one in x 
+Count number of bits set to one in x
 
 ### Parameters
-* `x`: value to count bits of 
-
+* `x`: value to count bits of
 ### Returns
 the number of bits set to one in x
 """
@@ -12205,11 +11998,10 @@ end
 """
     av_popcount64_c(x::UInt64)
 
-Count number of bits set to one in x 
+Count number of bits set to one in x
 
 ### Parameters
-* `x`: value to count bits of 
-
+* `x`: value to count bits of
 ### Returns
 the number of bits set to one in x
 """
@@ -12247,31 +12039,6 @@ function av_force_cpu_flags(flags::Integer)
     ccall((:av_force_cpu_flags, libavutil), Cvoid, (Cint,), flags)
 end
 
-"""
-    av_set_cpu_flags_mask(mask::Integer)
-
-Set a mask on flags returned by [`av_get_cpu_flags`](@ref)(). This function is mainly useful for testing. Please use [`av_force_cpu_flags`](@ref)() and [`av_get_cpu_flags`](@ref)() instead which are more flexible
-"""
-function av_set_cpu_flags_mask(mask::Integer)
-    ccall((:av_set_cpu_flags_mask, libavutil), Cvoid, (Cint,), mask)
-end
-
-"""
-    av_parse_cpu_flags(s)
-
-Parse CPU flags from a string.
-
-The returned flags contain the specified flags as well as related unspecified flags.
-
-This function exists only for compatibility with libav. Please use [`av_parse_cpu_caps`](@ref)() when possible. 
-
-### Returns
-a combination of AV\\_CPU\\_* flags, negative on error.
-"""
-function av_parse_cpu_flags(s)
-    ccall((:av_parse_cpu_flags, libavutil), Cint, (Cstring,), s)
-end
-
 """
     av_parse_cpu_caps(flags, s)
 
@@ -12294,12 +12061,21 @@ function av_cpu_count()
     ccall((:av_cpu_count, libavutil), Cint, ())
 end
 
+"""
+    av_cpu_force_count(count::Integer)
+
+Overrides cpu count detection and forces the specified count. Count < 1 disables forcing of specific count.
+"""
+function av_cpu_force_count(count::Integer)
+    ccall((:av_cpu_force_count, libavutil), Cvoid, (Cint,), count)
+end
+
 """
     av_cpu_max_align()
 
 Get the maximum data alignment that may be required by FFmpeg.
 
-Note that this is affected by the build configuration and the CPU flags mask, so e.g. if the CPU supports AVX, but libavutil has been built with --disable-avx or the [`AV_CPU_FLAG_AVX`](@ref) flag has been disabled through [`av_set_cpu_flags_mask`](@ref)(), then this function will behave as if AVX is not present.
+Note that this is affected by the build configuration and the CPU flags mask, so e.g. if the CPU supports AVX, but libavutil has been built with --disable-avx or the [`AV_CPU_FLAG_AVX`](@ref) flag has been disabled through av\\_set\\_cpu\\_flags\\_mask(), then this function will behave as if AVX is not present.
 """
 function av_cpu_max_align()
     ccall((:av_cpu_max_align, libavutil), Csize_t, ())
@@ -12332,19 +12108,14 @@ const AV_CRC_MAX = 8 % UInt32
 """
     av_crc_init(ctx, le::Integer, bits::Integer, poly::Integer, ctx_size::Integer)
 
-Initialize a CRC table. 
+Initialize a CRC table.
 
 ### Parameters
-* `ctx`: must be an array of size sizeof([`AVCRC`](@ref))*257 or sizeof([`AVCRC`](@ref))*1024 
-
-* `le`: If 1, the lowest bit represents the coefficient for the highest exponent of the corresponding polynomial (both for poly and actual CRC). If 0, you must swap the CRC parameter and the result of [`av_crc`](@ref) if you need the standard representation (can be simplified in most cases to e.g. bswap16): [`av_bswap32`](@ref)(crc << (32-bits)) 
-
-* `bits`: number of bits for the CRC 
-
-* `poly`: generator polynomial without the x**bits coefficient, in the representation as specified by le 
-
-* `ctx_size`: size of ctx in bytes 
-
+* `ctx`: must be an array of size sizeof([`AVCRC`](@ref))*257 or sizeof([`AVCRC`](@ref))*1024
+* `le`: If 1, the lowest bit represents the coefficient for the highest exponent of the corresponding polynomial (both for poly and actual CRC). If 0, you must swap the CRC parameter and the result of [`av_crc`](@ref) if you need the standard representation (can be simplified in most cases to e.g. bswap16): [`av_bswap32`](@ref)(crc << (32-bits))
+* `bits`: number of bits for the CRC
+* `poly`: generator polynomial without the x**bits coefficient, in the representation as specified by le
+* `ctx_size`: size of ctx in bytes
 ### Returns
 <0 on failure
 """
@@ -12355,11 +12126,10 @@ end
 """
     av_crc_get_table(crc_id::AVCRCId)
 
-Get an initialized standard CRC table. 
+Get an initialized standard CRC table.
 
 ### Parameters
-* `crc_id`: ID of a standard CRC 
-
+* `crc_id`: ID of a standard CRC
 ### Returns
 a pointer to the CRC table or NULL on failure
 """
@@ -12370,14 +12140,15 @@ end
 """
     av_crc(ctx, crc::Integer, buffer, length::Csize_t)
 
-Calculate the CRC of a block. 
+Calculate the CRC of a block.
 
 ### Parameters
-* `crc`: CRC of previous blocks if any or initial value for CRC 
-
+* `ctx`: initialized [`AVCRC`](@ref) array (see [`av_crc_init`](@ref)())
+* `crc`: CRC of previous blocks if any or initial value for CRC
+* `buffer`: buffer whose CRC to calculate
+* `length`: length of the buffer
 ### Returns
 CRC updated with the data from the given block
-
 ### See also
 [`av_crc_init`](@ref)() "le" parameter
 """
@@ -12385,6 +12156,133 @@ function av_crc(ctx, crc::Integer, buffer, length::Csize_t)
     ccall((:av_crc, libavutil), UInt32, (Ptr{AVCRC}, UInt32, Ptr{UInt8}, Csize_t), ctx, crc, buffer, length)
 end
 
+"""
+    AVLumaCoefficients
+
+Struct containing luma coefficients to be used for RGB to YUV/YCoCg, or similar calculations.
+"""
+struct AVLumaCoefficients
+    cr::AVRational
+    cg::AVRational
+    cb::AVRational
+end
+
+"""
+    AVCIExy
+
+Struct containing chromaticity x and y values for the standard CIE 1931 chromaticity definition.
+"""
+struct AVCIExy
+    x::AVRational
+    y::AVRational
+end
+
+"""
+    AVPrimaryCoefficients
+
+Struct defining the red, green, and blue primary locations in terms of CIE 1931 chromaticity x and y.
+"""
+struct AVPrimaryCoefficients
+    r::AVCIExy
+    g::AVCIExy
+    b::AVCIExy
+end
+
+"""
+Struct defining white point location in terms of CIE 1931 chromaticity x and y.
+"""
+const AVWhitepointCoefficients = AVCIExy
+
+"""
+    AVColorPrimariesDesc
+
+Struct that contains both white point location and primaries location, providing the complete description of a color gamut.
+"""
+struct AVColorPrimariesDesc
+    wp::AVWhitepointCoefficients
+    prim::AVPrimaryCoefficients
+end
+
+# typedef double ( * av_csp_trc_function ) ( double )
+"""
+Function pointer representing a double -> double transfer function that performs an EOTF transfer inversion. This function outputs linear light.
+"""
+const av_csp_trc_function = Ptr{Cvoid}
+
+"""
+    av_csp_luma_coeffs_from_avcsp(csp::AVColorSpace)
+
+Retrieves the Luma coefficients necessary to construct a conversion matrix from an enum constant describing the colorspace.
+
+### Parameters
+* `csp`: An enum constant indicating YUV or similar colorspace.
+### Returns
+The Luma coefficients associated with that colorspace, or NULL if the constant is unknown to libavutil.
+"""
+function av_csp_luma_coeffs_from_avcsp(csp::AVColorSpace)
+    ccall((:av_csp_luma_coeffs_from_avcsp, libavutil), Ptr{AVLumaCoefficients}, (AVColorSpace,), csp)
+end
+
+"""
+    av_csp_primaries_desc_from_id(prm::AVColorPrimaries)
+
+Retrieves a complete gamut description from an enum constant describing the color primaries.
+
+### Parameters
+* `prm`: An enum constant indicating primaries
+### Returns
+A description of the colorspace gamut associated with that enum constant, or NULL if the constant is unknown to libavutil.
+"""
+function av_csp_primaries_desc_from_id(prm::AVColorPrimaries)
+    ccall((:av_csp_primaries_desc_from_id, libavutil), Ptr{AVColorPrimariesDesc}, (AVColorPrimaries,), prm)
+end
+
+"""
+    av_csp_primaries_id_from_desc(prm)
+
+Detects which enum [`AVColorPrimaries`](@ref) constant corresponds to the given complete gamut description.
+
+### Parameters
+* `prm`: A description of the colorspace gamut
+### Returns
+The enum constant associated with this gamut, or AVCOL\\_PRI\\_UNSPECIFIED if no clear match can be idenitified.
+### See also
+enum [`AVColorPrimaries`](@ref)
+"""
+function av_csp_primaries_id_from_desc(prm)
+    ccall((:av_csp_primaries_id_from_desc, libavutil), AVColorPrimaries, (Ptr{AVColorPrimariesDesc},), prm)
+end
+
+"""
+    av_csp_approximate_trc_gamma(trc::AVColorTransferCharacteristic)
+
+Determine a suitable 'gamma' value to match the supplied [`AVColorTransferCharacteristic`](@ref).
+
+See Apple Technical Note TN2257 (https://developer.apple.com/library/mac/technotes/tn2257/\\_index.html)
+
+This function returns the gamma exponent for the OETF. For example, sRGB is approximated by gamma 2.2, not by gamma 0.45455.
+
+### Returns
+Will return an approximation to the simple gamma function matching the supplied Transfer Characteristic, Will return 0.0 for any we cannot reasonably match against.
+"""
+function av_csp_approximate_trc_gamma(trc::AVColorTransferCharacteristic)
+    ccall((:av_csp_approximate_trc_gamma, libavutil), Cdouble, (AVColorTransferCharacteristic,), trc)
+end
+
+"""
+    av_csp_trc_func_from_id(trc::AVColorTransferCharacteristic)
+
+Determine the function needed to apply the given [`AVColorTransferCharacteristic`](@ref) to linear input.
+
+The function returned should expect a nominal domain and range of [0.0-1.0] values outside of this range maybe valid depending on the chosen characteristic function.
+
+### Returns
+Will return pointer to the function matching the supplied Transfer Characteristic. If unspecified will return NULL:
+"""
+function av_csp_trc_func_from_id(trc::AVColorTransferCharacteristic)
+    ccall((:av_csp_trc_func_from_id, libavutil), av_csp_trc_function, (AVColorTransferCharacteristic,), trc)
+end
+
 """
     AVDES
 
@@ -12414,10 +12312,10 @@ end
 Initializes an [`AVDES`](@ref) context.
 
 ### Parameters
-* `key_bits`: must be 64 or 192 
-
-* `decrypt`: 0 for encryption/CBC-MAC, 1 for decryption 
-
+* `d`: pointer to a [`AVDES`](@ref) structure to initialize
+* `key`: pointer to the key to use
+* `key_bits`: must be 64 or 192
+* `decrypt`: 0 for encryption/CBC-MAC, 1 for decryption
 ### Returns
 zero on success, negative value otherwise
 """
@@ -12431,14 +12329,11 @@ end
 Encrypts / decrypts using the DES algorithm.
 
 ### Parameters
-* `count`: number of 8 byte blocks 
-
-* `dst`: destination array, can be equal to src, must be 8-byte aligned 
-
-* `src`: source array, can be equal to dst, must be 8-byte aligned, may be NULL 
-
-* `iv`: initialization vector for CBC mode, if NULL then ECB will be used, must be 8-byte aligned 
-
+* `d`: pointer to the [`AVDES`](@ref) structure
+* `dst`: destination array, can be equal to src, must be 8-byte aligned
+* `src`: source array, can be equal to dst, must be 8-byte aligned, may be NULL
+* `count`: number of 8 byte blocks
+* `iv`: initialization vector for CBC mode, if NULL then ECB will be used, must be 8-byte aligned
 * `decrypt`: 0 for encryption, 1 for decryption
 """
 function av_des_crypt(d, dst, src, count::Integer, iv, decrypt::Integer)
@@ -12451,16 +12346,80 @@ end
 Calculates CBC-MAC using the DES algorithm.
 
 ### Parameters
-* `count`: number of 8 byte blocks 
-
-* `dst`: destination array, can be equal to src, must be 8-byte aligned 
-
+* `d`: pointer to the [`AVDES`](@ref) structure
+* `dst`: destination array, can be equal to src, must be 8-byte aligned
 * `src`: source array, can be equal to dst, must be 8-byte aligned, may be NULL
+* `count`: number of 8 byte blocks
 """
 function av_des_mac(d, dst, src, count::Integer)
     ccall((:av_des_mac, libavutil), Cvoid, (Ptr{AVDES}, Ptr{UInt8}, Ptr{UInt8}, Cint), d, dst, src, count)
 end
 
+struct AVDetectionBBox
+    x::Cint
+    y::Cint
+    w::Cint
+    h::Cint
+    detect_label::NTuple{64, Cchar}
+    detect_confidence::AVRational
+    classify_count::UInt32
+    classify_labels::NTuple{4, NTuple{64, Cchar}}
+    classify_confidences::NTuple{4, AVRational}
+end
+
+struct AVDetectionBBoxHeader
+    source::NTuple{256, Cchar}
+    nb_bboxes::UInt32
+    bboxes_offset::Csize_t
+    bbox_size::Csize_t
+end
+
+function av_get_detection_bbox(header, idx::Integer)
+    ccall((:av_get_detection_bbox, libavutil), Ptr{AVDetectionBBox}, (Ptr{AVDetectionBBoxHeader}, Cuint), header, idx)
+end
+
+"""
+    av_detection_bbox_alloc(nb_bboxes::Integer, out_size)
+
+Allocates memory for [`AVDetectionBBoxHeader`](@ref), plus an array of {
+
+```c++
+ nb_bboxes}
+ AVDetectionBBox, and initializes the variables.
+ Can be freed with a normal av_free() call.
+ @param nb_bboxes number of AVDetectionBBox structures to allocate
+ @param out_size if non-NULL, the size in bytes of the resulting data array is
+ written here.
+ 
+
+```
+"""
+function av_detection_bbox_alloc(nb_bboxes::Integer, out_size)
+    ccall((:av_detection_bbox_alloc, libavutil), Ptr{AVDetectionBBoxHeader}, (UInt32, Ptr{Csize_t}), nb_bboxes, out_size)
+end
+
+"""
+    av_detection_bbox_create_side_data(frame, nb_bboxes::Integer)
+
+Allocates memory for [`AVDetectionBBoxHeader`](@ref), plus an array of {
+
+```c++
+ nb_bboxes}
+ AVDetectionBBox, in the given AVFrame {@code frame} as AVFrameSideData of type
+ AV_FRAME_DATA_DETECTION_BBOXES and initializes the variables.
+ 
+
+```
+"""
+function av_detection_bbox_create_side_data(frame, nb_bboxes::Integer)
+    ccall((:av_detection_bbox_create_side_data, libavutil), Ptr{AVDetectionBBoxHeader}, (Ptr{AVFrame}, UInt32), frame, nb_bboxes)
+end
+
+"""
+    AVDictionaryEntry
+
+@}
+"""
 struct AVDictionaryEntry
     key::Cstring
     value::Cstring
@@ -12473,20 +12432,51 @@ Get a dictionary entry with matching key.
 
 The returned entry key or value must not be changed, or it will cause undefined behavior.
 
-To iterate through all the dictionary entries, you can set the matching key to the null string "" and set the [`AV_DICT_IGNORE_SUFFIX`](@ref) flag.
+### Parameters
+* `prev`: Set to the previous matching element to find the next. If set to NULL the first matching element is returned.
+* `key`: Matching key
+* `flags`: A collection of AV\\_DICT\\_* flags controlling how the entry is retrieved
+### Returns
+Found entry or NULL in case no matching entry was found in the dictionary
+"""
+function av_dict_get(m, key, prev, flags::Integer)
+    ccall((:av_dict_get, libavutil), Ptr{AVDictionaryEntry}, (Ptr{AVDictionary}, Cstring, Ptr{AVDictionaryEntry}, Cint), m, key, prev, flags)
+end
+
+"""
+    av_dict_iterate(m, prev)
+
+Iterate over a dictionary
+
+Iterates through all entries in the dictionary.
+
+!!! warning
+
+    The returned [`AVDictionaryEntry`](@ref) key/value must not be changed.
+
+!!! warning
+
+    As [`av_dict_set`](@ref)() invalidates all previous entries returned by this function, it must not be called while iterating over the dict.
+
+Typical usage:
 
-### Parameters
-* `prev`: Set to the previous matching element to find the next. If set to NULL the first matching element is returned. 
+```c++
+ const AVDictionaryEntry *e = NULL;
+ while ((e = av_dict_iterate(m, e))) {
+     // ...
+ }
+```
 
-* `key`: matching key 
+\\retvalAVDictionaryEntry* The next element in the dictionary
 
-* `flags`: a collection of AV\\_DICT\\_* flags controlling how the entry is retrieved 
+\\retvalNULL No more elements in the dictionary
 
-### Returns
-found entry or NULL in case no matching entry was found in the dictionary
+### Parameters
+* `m`: The dictionary to iterate over
+* `prev`: Pointer to the previous [`AVDictionaryEntry`](@ref), NULL initially
 """
-function av_dict_get(m, key, prev, flags::Integer)
-    ccall((:av_dict_get, libavutil), Ptr{AVDictionaryEntry}, (Ptr{AVDictionary}, Cstring, Ptr{AVDictionaryEntry}, Cint), m, key, prev, flags)
+function av_dict_iterate(m, prev)
+    ccall((:av_dict_iterate, libavutil), Ptr{AVDictionaryEntry}, (Ptr{AVDictionary}, Ptr{AVDictionaryEntry}), m, prev)
 end
 
 """
@@ -12495,8 +12485,7 @@ end
 Get number of entries in dictionary.
 
 ### Parameters
-* `m`: dictionary 
-
+* `m`: dictionary
 ### Returns
 number of entries in dictionary
 """
@@ -12511,15 +12500,14 @@ Set the given entry in *pm, overwriting an existing entry.
 
 Note: If [`AV_DICT_DONT_STRDUP_KEY`](@ref) or [`AV_DICT_DONT_STRDUP_VAL`](@ref) is set, these arguments will be freed on error.
 
-Warning: Adding a new entry to a dictionary invalidates all existing entries previously returned with [`av_dict_get`](@ref).
-
-### Parameters
-* `pm`: pointer to a pointer to a dictionary struct. If *pm is NULL a dictionary struct is allocated and put in *pm. 
-
-* `key`: entry key to add to *pm (will either be av\\_strduped or added as a new key depending on flags) 
+!!! warning
 
-* `value`: entry value to add to *pm (will be av\\_strduped or added as a new key depending on flags). Passing a NULL value will cause an existing entry to be deleted. 
+    Adding a new entry to a dictionary invalidates all existing entries previously returned with [`av_dict_get`](@ref)() or [`av_dict_iterate`](@ref)().
 
+### Parameters
+* `pm`: Pointer to a pointer to a dictionary struct. If *pm is NULL a dictionary struct is allocated and put in *pm.
+* `key`: Entry key to add to *pm (will either be av\\_strduped or added as a new key depending on flags)
+* `value`: Entry value to add to *pm (will be av\\_strduped or added as a new key depending on flags). Passing a NULL value will cause an existing entry to be deleted.
 ### Returns
 >= 0 on success otherwise an error code <0
 """
@@ -12530,9 +12518,9 @@ end
 """
     av_dict_set_int(pm, key, value::Int64, flags::Integer)
 
-Convenience wrapper for [`av_dict_set`](@ref) that converts the value to a string and stores it.
+Convenience wrapper for [`av_dict_set`](@ref)() that converts the value to a string and stores it.
 
-Note: If [`AV_DICT_DONT_STRDUP_KEY`](@ref) is set, key will be freed on error.
+Note: If ::[`AV_DICT_DONT_STRDUP_KEY`](@ref) is set, key will be freed on error.
 """
 function av_dict_set_int(pm, key, value::Int64, flags::Integer)
     ccall((:av_dict_set_int, libavutil), Cint, (Ptr{Ptr{AVDictionary}}, Cstring, Int64, Cint), pm, key, value, flags)
@@ -12546,12 +12534,9 @@ Parse the key/value pairs list and add the parsed entries to a dictionary.
 In case of failure, all the successfully set entries are stored in *pm. You may need to manually free the created dictionary.
 
 ### Parameters
-* `key_val_sep`: a 0-terminated list of characters used to separate key from value 
-
-* `pairs_sep`: a 0-terminated list of characters used to separate two pairs from each other 
-
-* `flags`: flags to use when adding to dictionary. [`AV_DICT_DONT_STRDUP_KEY`](@ref) and [`AV_DICT_DONT_STRDUP_VAL`](@ref) are ignored since the key/value tokens will always be duplicated. 
-
+* `key_val_sep`: A 0-terminated list of characters used to separate key from value
+* `pairs_sep`: A 0-terminated list of characters used to separate two pairs from each other
+* `flags`: Flags to use when adding to the dictionary. ::[`AV_DICT_DONT_STRDUP_KEY`](@ref) and ::[`AV_DICT_DONT_STRDUP_VAL`](@ref) are ignored since the key/value tokens will always be duplicated.
 ### Returns
 0 on success, negative [`AVERROR`](@ref) code on failure
 """
@@ -12562,19 +12547,16 @@ end
 """
     av_dict_copy(dst, src, flags::Integer)
 
-Copy entries from one [`AVDictionary`](@ref) struct into another. 
+Copy entries from one [`AVDictionary`](@ref) struct into another.
 
 !!! note
 
-    metadata is read using the [`AV_DICT_IGNORE_SUFFIX`](@ref) flag 
+    Metadata is read using the ::[`AV_DICT_IGNORE_SUFFIX`](@ref) flag
 
 ### Parameters
-* `dst`: pointer to a pointer to a [`AVDictionary`](@ref) struct. If *dst is NULL, this function will allocate a struct for you and put it in *dst 
-
-* `src`: pointer to source [`AVDictionary`](@ref) struct 
-
-* `flags`: flags to use when setting entries in *dst 
-
+* `dst`: Pointer to a pointer to a [`AVDictionary`](@ref) struct to copy into. If *dst is NULL, this function will allocate a struct for you and put it in *dst
+* `src`: Pointer to the source [`AVDictionary`](@ref) struct to copy items from.
+* `flags`: Flags to use when setting entries in *dst
 ### Returns
 0 on success, negative [`AVERROR`](@ref) code on failure. If dst was allocated by this function, callers should free the associated memory.
 """
@@ -12596,7 +12578,7 @@ end
 
 Get dictionary entries as a string.
 
-Create a string containing dictionary's entries. Such string may be passed back to [`av_dict_parse_string`](@ref)(). 
+Create a string containing dictionary's entries. Such string may be passed back to [`av_dict_parse_string`](@ref)().
 
 !!! note
 
@@ -12607,16 +12589,12 @@ Create a string containing dictionary's entries. Such string may be passed back
     Separators cannot be neither '\\' nor '\\0'. They also cannot be the same.
 
 ### Parameters
-* `m`:\\[in\\] dictionary 
-
-* `buffer`:\\[out\\] Pointer to buffer that will be allocated with string containg entries. Buffer must be freed by the caller when is no longer needed. 
-
-* `key_val_sep`:\\[in\\] character used to separate key from value 
-
-* `pairs_sep`:\\[in\\] character used to separate two pairs from each other 
-
+* `m`:\\[in\\] The dictionary
+* `buffer`:\\[out\\] Pointer to buffer that will be allocated with string containg entries. Buffer must be freed by the caller when is no longer needed.
+* `key_val_sep`:\\[in\\] Character used to separate key from value
+* `pairs_sep`:\\[in\\] Character used to separate two pairs from each other
 ### Returns
->= 0 on success, negative on error 
+>= 0 on success, negative on error
 """
 function av_dict_get_string(m, buffer, key_val_sep::Cchar, pairs_sep::Cchar)
     ccall((:av_dict_get_string, libavutil), Cint, (Ptr{AVDictionary}, Ptr{Cstring}, Cchar, Cchar), m, buffer, key_val_sep, pairs_sep)
@@ -12632,8 +12610,7 @@ Extract the rotation component of the transformation matrix.
     floating point numbers are inherently inexact, so callers are recommended to round the return value to nearest integer before use.
 
 ### Parameters
-* `matrix`: the transformation matrix 
-
+* `matrix`: the transformation matrix
 ### Returns
 the angle (in degrees) by which the transformation rotates the frame counterclockwise. The angle will be in range [-180.0, 180.0], or NaN if the matrix is singular.
 """
@@ -12644,11 +12621,10 @@ end
 """
     av_display_rotation_set(matrix, angle::Cdouble)
 
-Initialize a transformation matrix describing a pure counterclockwise rotation by the specified angle (in degrees).
+Initialize a transformation matrix describing a pure clockwise rotation by the specified angle (in degrees).
 
 ### Parameters
-* `matrix`: an allocated transformation matrix (will be fully overwritten by this function) 
-
+* `matrix`:\\[out\\] a transformation matrix (will be fully overwritten by this function)
 * `angle`: rotation angle in degrees.
 """
 function av_display_rotation_set(matrix, angle::Cdouble)
@@ -12661,10 +12637,8 @@ end
 Flip the input matrix horizontally and/or vertically.
 
 ### Parameters
-* `matrix`: an allocated transformation matrix 
-
-* `hflip`: whether the matrix should be flipped horizontally 
-
+* `matrix`:\\[in,out\\] a transformation matrix
+* `hflip`: whether the matrix should be flipped horizontally
 * `vflip`: whether the matrix should be flipped vertically
 """
 function av_display_matrix_flip(matrix, hflip::Integer, vflip::Integer)
@@ -12694,6 +12668,153 @@ function av_dovi_alloc(size)
     ccall((:av_dovi_alloc, libavutil), Ptr{AVDOVIDecoderConfigurationRecord}, (Ptr{Csize_t},), size)
 end
 
+"""
+    AVDOVIRpuDataHeader
+
+Dolby Vision RPU data header.
+
+!!! note
+
+    sizeof([`AVDOVIRpuDataHeader`](@ref)) is not part of the public ABI.
+"""
+struct AVDOVIRpuDataHeader
+    rpu_type::UInt8
+    rpu_format::UInt16
+    vdr_rpu_profile::UInt8
+    vdr_rpu_level::UInt8
+    chroma_resampling_explicit_filter_flag::UInt8
+    coef_data_type::UInt8
+    coef_log2_denom::UInt8
+    vdr_rpu_normalized_idc::UInt8
+    bl_video_full_range_flag::UInt8
+    bl_bit_depth::UInt8
+    el_bit_depth::UInt8
+    vdr_bit_depth::UInt8
+    spatial_resampling_filter_flag::UInt8
+    el_spatial_resampling_filter_flag::UInt8
+    disable_residual_flag::UInt8
+end
+
+const AVDOVIMappingMethod = UInt32
+const AV_DOVI_MAPPING_POLYNOMIAL = 0 % UInt32
+const AV_DOVI_MAPPING_MMR = 1 % UInt32
+
+struct AVDOVIReshapingCurve
+    num_pivots::UInt8
+    pivots::NTuple{9, UInt16}
+    mapping_idc::NTuple{8, AVDOVIMappingMethod}
+    poly_order::NTuple{8, UInt8}
+    poly_coef::NTuple{8, NTuple{3, Int64}}
+    mmr_order::NTuple{8, UInt8}
+    mmr_constant::NTuple{8, Int64}
+    mmr_coef::NTuple{8, NTuple{3, NTuple{7, Int64}}}
+end
+
+const AVDOVINLQMethod = Int32
+const AV_DOVI_NLQ_NONE = -1 % Int32
+const AV_DOVI_NLQ_LINEAR_DZ = 0 % Int32
+
+"""
+    AVDOVINLQParams
+
+Coefficients of the non-linear inverse quantization. For the interpretation of these, see ETSI GS CCM 001.
+"""
+struct AVDOVINLQParams
+    nlq_offset::UInt16
+    vdr_in_max::UInt64
+    linear_deadzone_slope::UInt64
+    linear_deadzone_threshold::UInt64
+end
+
+"""
+    AVDOVIDataMapping
+
+Dolby Vision RPU data mapping parameters.
+
+!!! note
+
+    sizeof([`AVDOVIDataMapping`](@ref)) is not part of the public ABI.
+"""
+struct AVDOVIDataMapping
+    vdr_rpu_id::UInt8
+    mapping_color_space::UInt8
+    mapping_chroma_format_idc::UInt8
+    curves::NTuple{3, AVDOVIReshapingCurve}
+    nlq_method_idc::AVDOVINLQMethod
+    num_x_partitions::UInt32
+    num_y_partitions::UInt32
+    nlq::NTuple{3, AVDOVINLQParams}
+end
+
+"""
+    AVDOVIColorMetadata
+
+Dolby Vision RPU colorspace metadata parameters.
+
+!!! note
+
+    sizeof([`AVDOVIColorMetadata`](@ref)) is not part of the public ABI.
+"""
+struct AVDOVIColorMetadata
+    dm_metadata_id::UInt8
+    scene_refresh_flag::UInt8
+    ycc_to_rgb_matrix::NTuple{9, AVRational}
+    ycc_to_rgb_offset::NTuple{3, AVRational}
+    rgb_to_lms_matrix::NTuple{9, AVRational}
+    signal_eotf::UInt16
+    signal_eotf_param0::UInt16
+    signal_eotf_param1::UInt16
+    signal_eotf_param2::UInt32
+    signal_bit_depth::UInt8
+    signal_color_space::UInt8
+    signal_chroma_format::UInt8
+    signal_full_range_flag::UInt8
+    source_min_pq::UInt16
+    source_max_pq::UInt16
+    source_diagonal::UInt16
+end
+
+"""
+    AVDOVIMetadata
+
+Combined struct representing a combination of header, mapping and color metadata, for attaching to frames as side data.
+
+!!! note
+
+    The struct must be allocated with [`av_dovi_metadata_alloc`](@ref)() and its size is not a part of the public ABI.
+"""
+struct AVDOVIMetadata
+    header_offset::Csize_t
+    mapping_offset::Csize_t
+    color_offset::Csize_t
+end
+
+function av_dovi_get_header(data)
+    ccall((:av_dovi_get_header, libavutil), Ptr{AVDOVIRpuDataHeader}, (Ptr{AVDOVIMetadata},), data)
+end
+
+function av_dovi_get_mapping(data)
+    ccall((:av_dovi_get_mapping, libavutil), Ptr{AVDOVIDataMapping}, (Ptr{AVDOVIMetadata},), data)
+end
+
+function av_dovi_get_color(data)
+    ccall((:av_dovi_get_color, libavutil), Ptr{AVDOVIColorMetadata}, (Ptr{AVDOVIMetadata},), data)
+end
+
+"""
+    av_dovi_metadata_alloc(size)
+
+Allocate an [`AVDOVIMetadata`](@ref) structure and initialize its fields to default values.
+
+### Parameters
+* `size`: If this parameter is non-NULL, the size in bytes of the allocated struct will be written here on success
+### Returns
+the newly allocated struct or NULL on failure
+"""
+function av_dovi_metadata_alloc(size)
+    ccall((:av_dovi_metadata_alloc, libavutil), Ptr{AVDOVIMetadata}, (Ptr{Csize_t},), size)
+end
+
 """
     AVDownmixType
 
@@ -12731,7 +12852,6 @@ If the side data is absent, it is created and added to the frame.
 
 ### Parameters
 * `frame`: the frame for which the side data is to be obtained or created
-
 ### Returns
 the [`AVDownmixInfo`](@ref) structure to be edited by the caller, or NULL if the structure cannot be allocated.
 """
@@ -12771,35 +12891,25 @@ This describes info used to initialize an encryption key system.
 The size of this struct is not part of the public ABI.
 """
 struct AVEncryptionInitInfo
-    system_id::Ptr{Cvoid} # system_id::Ptr{UInt8}
+    system_id::Ptr{UInt8}
     system_id_size::UInt32
-    key_ids::Ptr{Ptr{Cvoid}} # key_ids::Ptr{Ptr{UInt8}}
+    key_ids::Ptr{Ptr{UInt8}}
     num_key_ids::UInt32
     key_id_size::UInt32
-    data::Ptr{Cvoid} # data::Ptr{UInt8}
+    data::Ptr{UInt8}
     data_size::UInt32
     next::Ptr{AVEncryptionInitInfo}
 end
 
-function Base.getproperty(x::AVEncryptionInitInfo, f::Symbol)
-    f === :system_id && return Ptr{UInt8}(getfield(x, f))
-    f === :key_ids && return Ptr{Ptr{UInt8}}(getfield(x, f))
-    f === :data && return Ptr{UInt8}(getfield(x, f))
-    return getfield(x, f)
-end
-
 """
     av_encryption_info_alloc(subsample_count::Integer, key_id_size::Integer, iv_size::Integer)
 
 Allocates an [`AVEncryptionInfo`](@ref) structure and sub-pointers to hold the given number of subsamples. This will allocate pointers for the key ID, IV, and subsample entries, set the size members, and zero-initialize the rest.
 
 ### Parameters
-* `subsample_count`: The number of subsamples. 
-
-* `key_id_size`: The number of bytes in the key ID, should be 16. 
-
+* `subsample_count`: The number of subsamples.
+* `key_id_size`: The number of bytes in the key ID, should be 16.
 * `iv_size`: The number of bytes in the IV, should be 16.
-
 ### Returns
 The new [`AVEncryptionInfo`](@ref) structure, or NULL on error.
 """
@@ -12810,7 +12920,7 @@ end
 """
     av_encryption_info_clone(info)
 
-Allocates an [`AVEncryptionInfo`](@ref) structure with a copy of the given data. 
+Allocates an [`AVEncryptionInfo`](@ref) structure with a copy of the given data.
 
 ### Returns
 The new [`AVEncryptionInfo`](@ref) structure, or NULL on error.
@@ -12853,229 +12963,481 @@ function av_encryption_info_add_side_data(info, side_data_size)
 end
 
 """
-    av_encryption_init_info_alloc(system_id_size::Integer, num_key_ids::Integer, key_id_size::Integer, data_size::Integer)
+    av_encryption_init_info_alloc(system_id_size::Integer, num_key_ids::Integer, key_id_size::Integer, data_size::Integer)
+
+Allocates an [`AVEncryptionInitInfo`](@ref) structure and sub-pointers to hold the given sizes. This will allocate pointers and set all the fields.
+
+### Returns
+The new [`AVEncryptionInitInfo`](@ref) structure, or NULL on error.
+"""
+function av_encryption_init_info_alloc(system_id_size::Integer, num_key_ids::Integer, key_id_size::Integer, data_size::Integer)
+    ccall((:av_encryption_init_info_alloc, libavutil), Ptr{AVEncryptionInitInfo}, (UInt32, UInt32, UInt32, UInt32), system_id_size, num_key_ids, key_id_size, data_size)
+end
+
+"""
+    av_encryption_init_info_free(info)
+
+Frees the given encryption init info object. This MUST NOT be used to free the side-data data pointer, that should use normal side-data methods.
+"""
+function av_encryption_init_info_free(info)
+    ccall((:av_encryption_init_info_free, libavutil), Cvoid, (Ptr{AVEncryptionInitInfo},), info)
+end
+
+"""
+    av_encryption_init_info_get_side_data(side_data, side_data_size::Csize_t)
+
+Creates a copy of the [`AVEncryptionInitInfo`](@ref) that is contained in the given side data. The resulting object should be passed to [`av_encryption_init_info_free`](@ref)() when done.
+
+### Returns
+The new [`AVEncryptionInitInfo`](@ref) structure, or NULL on error.
+"""
+function av_encryption_init_info_get_side_data(side_data, side_data_size::Csize_t)
+    ccall((:av_encryption_init_info_get_side_data, libavutil), Ptr{AVEncryptionInitInfo}, (Ptr{UInt8}, Csize_t), side_data, side_data_size)
+end
+
+"""
+    av_encryption_init_info_add_side_data(info, side_data_size)
+
+Allocates and initializes side data that holds a copy of the given encryption init info. The resulting pointer should be either freed using [`av_free`](@ref) or given to [`av_packet_add_side_data`](@ref)().
+
+### Returns
+The new side-data pointer, or NULL.
+"""
+function av_encryption_init_info_add_side_data(info, side_data_size)
+    ccall((:av_encryption_init_info_add_side_data, libavutil), Ptr{UInt8}, (Ptr{AVEncryptionInitInfo}, Ptr{Csize_t}), info, side_data_size)
+end
+
+"""
+    av_make_error_string(errbuf, errbuf_size::Csize_t, errnum::Integer)
+
+Fill the provided buffer with a string containing an error string corresponding to the [`AVERROR`](@ref) code errnum.
+
+### Parameters
+* `errbuf`: a buffer
+* `errbuf_size`: size in bytes of errbuf
+* `errnum`: error code to describe
+### Returns
+the buffer in input, filled with the error description
+### See also
+[`av_strerror`](@ref)()
+"""
+function av_make_error_string(errbuf, errbuf_size::Csize_t, errnum::Integer)
+    ccall((:av_make_error_string, libavutil), Cstring, (Cstring, Csize_t, Cint), errbuf, errbuf_size, errnum)
+end
+
+"""
+    av_strerror(errnum::Integer, errbuf, errbuf_size::Csize_t)
+
+Put a description of the [`AVERROR`](@ref) code errnum in errbuf. In case of failure the global variable errno is set to indicate the error. Even in case of failure [`av_strerror`](@ref)() will print a generic error message indicating the errnum provided to errbuf.
+
+### Parameters
+* `errnum`: error code to describe
+* `errbuf`: buffer to which description is written
+* `errbuf_size`: the size in bytes of errbuf
+### Returns
+0 on success, a negative value if a description for errnum cannot be found
+"""
+function av_strerror(errnum::Integer, errbuf, errbuf_size::Csize_t)
+    ccall((:av_strerror, libavutil), Cint, (Cint, Cstring, Csize_t), errnum, errbuf, errbuf_size)
+end
+
+mutable struct AVExpr end
+
+"""
+    av_expr_parse_and_eval(res, s, const_names, const_values, func1_names, funcs1, func2_names, funcs2, opaque, log_offset::Integer, log_ctx)
+
+Parse and evaluate an expression. Note, this is significantly slower than [`av_expr_eval`](@ref)().
+
+### Parameters
+* `res`: a pointer to a double where is put the result value of the expression, or NAN in case of error
+* `s`: expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"
+* `const_names`: NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}
+* `const_values`: a zero terminated array of values for the identifiers from const\\_names
+* `func1_names`: NULL terminated array of zero terminated strings of funcs1 identifiers
+* `funcs1`: NULL terminated array of function pointers for functions which take 1 argument
+* `func2_names`: NULL terminated array of zero terminated strings of funcs2 identifiers
+* `funcs2`: NULL terminated array of function pointers for functions which take 2 arguments
+* `opaque`: a pointer which will be passed to all functions from funcs1 and funcs2
+* `log_offset`: log level offset, can be used to silence error messages
+* `log_ctx`: parent logging context
+### Returns
+>= 0 in case of success, a negative value corresponding to an [`AVERROR`](@ref) code otherwise
+"""
+function av_expr_parse_and_eval(res, s, const_names, const_values, func1_names, funcs1, func2_names, funcs2, opaque, log_offset::Integer, log_ctx)
+    ccall((:av_expr_parse_and_eval, libavutil), Cint, (Ptr{Cdouble}, Cstring, Ptr{Cstring}, Ptr{Cdouble}, Ptr{Cstring}, Ptr{Ptr{Cvoid}}, Ptr{Cstring}, Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cint, Ptr{Cvoid}), res, s, const_names, const_values, func1_names, funcs1, func2_names, funcs2, opaque, log_offset, log_ctx)
+end
+
+"""
+    av_expr_parse(expr, s, const_names, func1_names, funcs1, func2_names, funcs2, log_offset::Integer, log_ctx)
+
+Parse an expression.
+
+### Parameters
+* `expr`: a pointer where is put an [`AVExpr`](@ref) containing the parsed value in case of successful parsing, or NULL otherwise. The pointed to [`AVExpr`](@ref) must be freed with [`av_expr_free`](@ref)() by the user when it is not needed anymore.
+* `s`: expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"
+* `const_names`: NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}
+* `func1_names`: NULL terminated array of zero terminated strings of funcs1 identifiers
+* `funcs1`: NULL terminated array of function pointers for functions which take 1 argument
+* `func2_names`: NULL terminated array of zero terminated strings of funcs2 identifiers
+* `funcs2`: NULL terminated array of function pointers for functions which take 2 arguments
+* `log_offset`: log level offset, can be used to silence error messages
+* `log_ctx`: parent logging context
+### Returns
+>= 0 in case of success, a negative value corresponding to an [`AVERROR`](@ref) code otherwise
+"""
+function av_expr_parse(expr, s, const_names, func1_names, funcs1, func2_names, funcs2, log_offset::Integer, log_ctx)
+    ccall((:av_expr_parse, libavutil), Cint, (Ptr{Ptr{AVExpr}}, Cstring, Ptr{Cstring}, Ptr{Cstring}, Ptr{Ptr{Cvoid}}, Ptr{Cstring}, Ptr{Ptr{Cvoid}}, Cint, Ptr{Cvoid}), expr, s, const_names, func1_names, funcs1, func2_names, funcs2, log_offset, log_ctx)
+end
+
+"""
+    av_expr_eval(e, const_values, opaque)
+
+Evaluate a previously parsed expression.
+
+### Parameters
+* `e`: the [`AVExpr`](@ref) to evaluate
+* `const_values`: a zero terminated array of values for the identifiers from [`av_expr_parse`](@ref)() const\\_names
+* `opaque`: a pointer which will be passed to all functions from funcs1 and funcs2
+### Returns
+the value of the expression
+"""
+function av_expr_eval(e, const_values, opaque)
+    ccall((:av_expr_eval, libavutil), Cdouble, (Ptr{AVExpr}, Ptr{Cdouble}, Ptr{Cvoid}), e, const_values, opaque)
+end
+
+"""
+    av_expr_count_vars(e, counter, size::Integer)
+
+Track the presence of variables and their number of occurrences in a parsed expression
+
+### Parameters
+* `e`: the [`AVExpr`](@ref) to track variables in
+* `counter`: a zero-initialized array where the count of each variable will be stored
+* `size`: size of array
+### Returns
+0 on success, a negative value indicates that no expression or array was passed or size was zero
+"""
+function av_expr_count_vars(e, counter, size::Integer)
+    ccall((:av_expr_count_vars, libavutil), Cint, (Ptr{AVExpr}, Ptr{Cuint}, Cint), e, counter, size)
+end
+
+"""
+    av_expr_count_func(e, counter, size::Integer, arg::Integer)
+
+Track the presence of user provided functions and their number of occurrences in a parsed expression.
+
+### Parameters
+* `e`: the [`AVExpr`](@ref) to track user provided functions in
+* `counter`: a zero-initialized array where the count of each function will be stored if you passed 5 functions with 2 arguments to [`av_expr_parse`](@ref)() then for arg=2 this will use upto 5 entries.
+* `size`: size of array
+* `arg`: number of arguments the counted functions have
+### Returns
+0 on success, a negative value indicates that no expression or array was passed or size was zero
+"""
+function av_expr_count_func(e, counter, size::Integer, arg::Integer)
+    ccall((:av_expr_count_func, libavutil), Cint, (Ptr{AVExpr}, Ptr{Cuint}, Cint, Cint), e, counter, size, arg)
+end
+
+"""
+    av_expr_free(e)
+
+Free a parsed expression previously created with [`av_expr_parse`](@ref)().
+"""
+function av_expr_free(e)
+    ccall((:av_expr_free, libavutil), Cvoid, (Ptr{AVExpr},), e)
+end
+
+"""
+    av_strtod(numstr, tail)
+
+Parse the string in numstr and return its value as a double. If the string is empty, contains only whitespaces, or does not contain an initial substring that has the expected syntax for a floating-point number, no conversion is performed. In this case, returns a value of zero and the value returned in tail is the value of numstr.
+
+### Parameters
+* `numstr`: a string representing a number, may contain one of the International System number postfixes, for example 'K', 'M', 'G'. If 'i' is appended after the postfix, powers of 2 are used instead of powers of 10. The 'B' postfix multiplies the value by 8, and can be appended after another postfix or used alone. This allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.
+* `tail`: if non-NULL puts here the pointer to the char next after the last parsed character
+"""
+function av_strtod(numstr, tail)
+    ccall((:av_strtod, libavutil), Cdouble, (Cstring, Ptr{Cstring}), numstr, tail)
+end
+
+mutable struct AVExecutor end
+
+struct AVTask
+    next::Ptr{AVTask}
+end
+
+struct AVTaskCallbacks
+    user_data::Ptr{Cvoid}
+    local_context_size::Cint
+    priority_higher::Ptr{Cvoid}
+    ready::Ptr{Cvoid}
+    run::Ptr{Cvoid}
+end
+
+"""
+    av_executor_alloc(callbacks, thread_count::Integer)
 
-Allocates an [`AVEncryptionInitInfo`](@ref) structure and sub-pointers to hold the given sizes. This will allocate pointers and set all the fields.
+Alloc executor
 
+### Parameters
+* `callbacks`: callback structure for executor
+* `thread_count`: worker thread number
 ### Returns
-The new [`AVEncryptionInitInfo`](@ref) structure, or NULL on error.
+return the executor
 """
-function av_encryption_init_info_alloc(system_id_size::Integer, num_key_ids::Integer, key_id_size::Integer, data_size::Integer)
-    ccall((:av_encryption_init_info_alloc, libavutil), Ptr{AVEncryptionInitInfo}, (UInt32, UInt32, UInt32, UInt32), system_id_size, num_key_ids, key_id_size, data_size)
+function av_executor_alloc(callbacks, thread_count::Integer)
+    ccall((:av_executor_alloc, libavutil), Ptr{AVExecutor}, (Ptr{AVTaskCallbacks}, Cint), callbacks, thread_count)
 end
 
 """
-    av_encryption_init_info_free(info)
+    av_executor_free(e)
 
-Frees the given encryption init info object. This MUST NOT be used to free the side-data data pointer, that should use normal side-data methods.
+Free executor
+
+### Parameters
+* `e`: pointer to executor
 """
-function av_encryption_init_info_free(info)
-    ccall((:av_encryption_init_info_free, libavutil), Cvoid, (Ptr{AVEncryptionInitInfo},), info)
+function av_executor_free(e)
+    ccall((:av_executor_free, libavutil), Cvoid, (Ptr{Ptr{AVExecutor}},), e)
 end
 
 """
-    av_encryption_init_info_get_side_data(side_data, side_data_size::Csize_t)
+    av_executor_execute(e, t)
 
-Creates a copy of the [`AVEncryptionInitInfo`](@ref) that is contained in the given side data. The resulting object should be passed to [`av_encryption_init_info_free`](@ref)() when done.
+Add task to executor
 
-### Returns
-The new [`AVEncryptionInitInfo`](@ref) structure, or NULL on error.
+### Parameters
+* `e`: pointer to executor
+* `t`: pointer to task. If NULL, it will wakeup one work thread
 """
-function av_encryption_init_info_get_side_data(side_data, side_data_size::Csize_t)
-    ccall((:av_encryption_init_info_get_side_data, libavutil), Ptr{AVEncryptionInitInfo}, (Ptr{UInt8}, Csize_t), side_data, side_data_size)
+function av_executor_execute(e, t)
+    ccall((:av_executor_execute, libavutil), Cvoid, (Ptr{AVExecutor}, Ptr{AVTask}), e, t)
 end
 
-"""
-    av_encryption_init_info_add_side_data(info, side_data_size)
+mutable struct AVFifo end
 
-Allocates and initializes side data that holds a copy of the given encryption init info. The resulting pointer should be either freed using [`av_free`](@ref) or given to [`av_packet_add_side_data`](@ref)().
+# typedef int AVFifoCB ( void * opaque , void * buf , size_t * nb_elems )
+"""
+Callback for writing or reading from a FIFO, passed to (and invoked from) the av\\_fifo\\_*\\_cb() functions. It may be invoked multiple times from a single av\\_fifo\\_*\\_cb() call and may process less data than the maximum size indicated by nb\\_elems.
 
+### Parameters
+* `opaque`: the opaque pointer provided to the av\\_fifo\\_*\\_cb() function
+* `buf`: the buffer for reading or writing the data, depending on which av\\_fifo\\_*\\_cb function is called
+* `nb_elems`: On entry contains the maximum number of elements that can be read from / written into buf. On success, the callback should update it to contain the number of elements actually written.
 ### Returns
-The new side-data pointer, or NULL.
+0 on success, a negative error code on failure (will be returned from the invoking av\\_fifo\\_*\\_cb() function)
 """
-function av_encryption_init_info_add_side_data(info, side_data_size)
-    ccall((:av_encryption_init_info_add_side_data, libavutil), Ptr{UInt8}, (Ptr{AVEncryptionInitInfo}, Ptr{Csize_t}), info, side_data_size)
-end
+const AVFifoCB = Cvoid
 
 """
-    av_make_error_string(errbuf, errbuf_size::Csize_t, errnum::Integer)
+    av_fifo_alloc2(elems::Csize_t, elem_size::Csize_t, flags::Integer)
 
-Fill the provided buffer with a string containing an error string corresponding to the [`AVERROR`](@ref) code errnum.
+Allocate and initialize an [`AVFifo`](@ref) with a given element size.
 
 ### Parameters
-* `errbuf`: a buffer 
-
-* `errbuf_size`: size in bytes of errbuf 
-
-* `errnum`: error code to describe 
-
+* `elems`: initial number of elements that can be stored in the FIFO
+* `elem_size`: Size in bytes of a single element. Further operations on the returned FIFO will implicitly use this element size.
+* `flags`: a combination of AV\\_FIFO\\_FLAG\\_*
 ### Returns
-the buffer in input, filled with the error description 
-
-### See also
-[`av_strerror`](@ref)()
+newly-allocated [`AVFifo`](@ref) on success, a negative error code on failure
 """
-function av_make_error_string(errbuf, errbuf_size::Csize_t, errnum::Integer)
-    ccall((:av_make_error_string, libavutil), Cstring, (Cstring, Csize_t, Cint), errbuf, errbuf_size, errnum)
+function av_fifo_alloc2(elems::Csize_t, elem_size::Csize_t, flags::Integer)
+    ccall((:av_fifo_alloc2, libavutil), Ptr{AVFifo}, (Csize_t, Csize_t, Cuint), elems, elem_size, flags)
 end
 
 """
-    av_strerror(errnum::Integer, errbuf, errbuf_size::Csize_t)
+    av_fifo_elem_size(f)
 
-Put a description of the [`AVERROR`](@ref) code errnum in errbuf. In case of failure the global variable errno is set to indicate the error. Even in case of failure [`av_strerror`](@ref)() will print a generic error message indicating the errnum provided to errbuf.
+### Returns
+Element size for FIFO operations. This element size is set at FIFO allocation and remains constant during its lifetime
+"""
+function av_fifo_elem_size(f)
+    ccall((:av_fifo_elem_size, libavutil), Csize_t, (Ptr{AVFifo},), f)
+end
 
-### Parameters
-* `errnum`: error code to describe 
+"""
+    av_fifo_auto_grow_limit(f, max_elems::Csize_t)
 
-* `errbuf`: buffer to which description is written 
+Set the maximum size (in elements) to which the FIFO can be resized automatically. Has no effect unless [`AV_FIFO_FLAG_AUTO_GROW`](@ref) is used.
+"""
+function av_fifo_auto_grow_limit(f, max_elems::Csize_t)
+    ccall((:av_fifo_auto_grow_limit, libavutil), Cvoid, (Ptr{AVFifo}, Csize_t), f, max_elems)
+end
 
-* `errbuf_size`: the size in bytes of errbuf 
+"""
+    av_fifo_can_read(f)
 
 ### Returns
-0 on success, a negative value if a description for errnum cannot be found
+number of elements available for reading from the given FIFO.
 """
-function av_strerror(errnum::Integer, errbuf, errbuf_size::Csize_t)
-    ccall((:av_strerror, libavutil), Cint, (Cint, Cstring, Csize_t), errnum, errbuf, errbuf_size)
+function av_fifo_can_read(f)
+    ccall((:av_fifo_can_read, libavutil), Csize_t, (Ptr{AVFifo},), f)
 end
 
-mutable struct AVExpr end
-
 """
-    av_expr_parse_and_eval(res, s, const_names, const_values, func1_names, funcs1, func2_names, funcs2, opaque, log_offset::Integer, log_ctx)
-
-Parse and evaluate an expression. Note, this is significantly slower than [`av_expr_eval`](@ref)().
+    av_fifo_can_write(f)
 
-### Parameters
-* `res`: a pointer to a double where is put the result value of the expression, or NAN in case of error 
+In other words, this number of elements or less is guaranteed to fit into the FIFO. More data may be written when the [`AV_FIFO_FLAG_AUTO_GROW`](@ref) flag was specified at FIFO creation, but this may involve memory allocation, which can fail.
 
-* `s`: expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)" 
+### Returns
+Number of elements that can be written into the given FIFO without growing it.
+"""
+function av_fifo_can_write(f)
+    ccall((:av_fifo_can_write, libavutil), Csize_t, (Ptr{AVFifo},), f)
+end
 
-* `const_names`: NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0} 
+"""
+    av_fifo_grow2(f, inc::Csize_t)
 
-* `const_values`: a zero terminated array of values for the identifiers from const\\_names 
+Enlarge an [`AVFifo`](@ref).
 
-* `func1_names`: NULL terminated array of zero terminated strings of funcs1 identifiers 
+On success, the FIFO will be large enough to hold exactly inc + [`av_fifo_can_read`](@ref)() + [`av_fifo_can_write`](@ref)() elements. In case of failure, the old FIFO is kept unchanged.
 
-* `funcs1`: NULL terminated array of function pointers for functions which take 1 argument 
+### Parameters
+* `f`: [`AVFifo`](@ref) to resize
+* `inc`: number of elements to allocate for, in addition to the current allocated size
+### Returns
+a non-negative number on success, a negative error code on failure
+"""
+function av_fifo_grow2(f, inc::Csize_t)
+    ccall((:av_fifo_grow2, libavutil), Cint, (Ptr{AVFifo}, Csize_t), f, inc)
+end
 
-* `func2_names`: NULL terminated array of zero terminated strings of funcs2 identifiers 
+"""
+    av_fifo_write(f, buf, nb_elems::Csize_t)
 
-* `funcs2`: NULL terminated array of function pointers for functions which take 2 arguments 
+Write data into a FIFO.
 
-* `opaque`: a pointer which will be passed to all functions from funcs1 and funcs2 
+In case nb\\_elems > [`av_fifo_can_write`](@ref)(f) and the [`AV_FIFO_FLAG_AUTO_GROW`](@ref) flag was not specified at FIFO creation, nothing is written and an error is returned.
 
-* `log_ctx`: parent logging context 
+Calling function is guaranteed to succeed if nb\\_elems <= [`av_fifo_can_write`](@ref)(f).
 
+### Parameters
+* `f`: the FIFO buffer
+* `buf`: Data to be written. nb\\_elems * [`av_fifo_elem_size`](@ref)(f) bytes will be read from buf on success.
+* `nb_elems`: number of elements to write into FIFO
 ### Returns
->= 0 in case of success, a negative value corresponding to an [`AVERROR`](@ref) code otherwise
+a non-negative number on success, a negative error code on failure
 """
-function av_expr_parse_and_eval(res, s, const_names, const_values, func1_names, funcs1, func2_names, funcs2, opaque, log_offset::Integer, log_ctx)
-    ccall((:av_expr_parse_and_eval, libavutil), Cint, (Ptr{Cdouble}, Cstring, Ptr{Cstring}, Ptr{Cdouble}, Ptr{Cstring}, Ptr{Ptr{Cvoid}}, Ptr{Cstring}, Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cint, Ptr{Cvoid}), res, s, const_names, const_values, func1_names, funcs1, func2_names, funcs2, opaque, log_offset, log_ctx)
+function av_fifo_write(f, buf, nb_elems::Csize_t)
+    ccall((:av_fifo_write, libavutil), Cint, (Ptr{AVFifo}, Ptr{Cvoid}, Csize_t), f, buf, nb_elems)
 end
 
 """
-    av_expr_parse(expr, s, const_names, func1_names, funcs1, func2_names, funcs2, log_offset::Integer, log_ctx)
+    av_fifo_write_from_cb(f, read_cb::AVFifoCB, opaque, nb_elems)
 
-Parse an expression.
+Write data from a user-provided callback into a FIFO.
 
 ### Parameters
-* `expr`: a pointer where is put an [`AVExpr`](@ref) containing the parsed value in case of successful parsing, or NULL otherwise. The pointed to [`AVExpr`](@ref) must be freed with [`av_expr_free`](@ref)() by the user when it is not needed anymore. 
-
-* `s`: expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)" 
-
-* `const_names`: NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0} 
-
-* `func1_names`: NULL terminated array of zero terminated strings of funcs1 identifiers 
-
-* `funcs1`: NULL terminated array of function pointers for functions which take 1 argument 
+* `f`: the FIFO buffer
+* `read_cb`: Callback supplying the data to the FIFO. May be called multiple times.
+* `opaque`: opaque user data to be provided to read\\_cb
+* `nb_elems`: Should point to the maximum number of elements that can be written. Will be updated to contain the number of elements actually written.
+### Returns
+non-negative number on success, a negative error code on failure
+"""
+function av_fifo_write_from_cb(f, read_cb::AVFifoCB, opaque, nb_elems)
+    ccall((:av_fifo_write_from_cb, libavutil), Cint, (Ptr{AVFifo}, AVFifoCB, Ptr{Cvoid}, Ptr{Csize_t}), f, read_cb, opaque, nb_elems)
+end
 
-* `func2_names`: NULL terminated array of zero terminated strings of funcs2 identifiers 
+"""
+    av_fifo_read(f, buf, nb_elems::Csize_t)
 
-* `funcs2`: NULL terminated array of function pointers for functions which take 2 arguments 
+Read data from a FIFO.
 
-* `log_ctx`: parent logging context 
+In case nb\\_elems > [`av_fifo_can_read`](@ref)(f), nothing is read and an error is returned.
 
+### Parameters
+* `f`: the FIFO buffer
+* `buf`: Buffer to store the data. nb\\_elems * [`av_fifo_elem_size`](@ref)(f) bytes will be written into buf on success.
+* `nb_elems`: number of elements to read from FIFO
 ### Returns
->= 0 in case of success, a negative value corresponding to an [`AVERROR`](@ref) code otherwise
+a non-negative number on success, a negative error code on failure
 """
-function av_expr_parse(expr, s, const_names, func1_names, funcs1, func2_names, funcs2, log_offset::Integer, log_ctx)
-    ccall((:av_expr_parse, libavutil), Cint, (Ptr{Ptr{AVExpr}}, Cstring, Ptr{Cstring}, Ptr{Cstring}, Ptr{Ptr{Cvoid}}, Ptr{Cstring}, Ptr{Ptr{Cvoid}}, Cint, Ptr{Cvoid}), expr, s, const_names, func1_names, funcs1, func2_names, funcs2, log_offset, log_ctx)
+function av_fifo_read(f, buf, nb_elems::Csize_t)
+    ccall((:av_fifo_read, libavutil), Cint, (Ptr{AVFifo}, Ptr{Cvoid}, Csize_t), f, buf, nb_elems)
 end
 
 """
-    av_expr_eval(e, const_values, opaque)
+    av_fifo_read_to_cb(f, write_cb::AVFifoCB, opaque, nb_elems)
 
-Evaluate a previously parsed expression.
+Feed data from a FIFO into a user-provided callback.
 
 ### Parameters
-* `const_values`: a zero terminated array of values for the identifiers from [`av_expr_parse`](@ref)() const\\_names 
-
-* `opaque`: a pointer which will be passed to all functions from funcs1 and funcs2 
-
+* `f`: the FIFO buffer
+* `write_cb`: Callback the data will be supplied to. May be called multiple times.
+* `opaque`: opaque user data to be provided to write\\_cb
+* `nb_elems`: Should point to the maximum number of elements that can be read. Will be updated to contain the total number of elements actually sent to the callback.
 ### Returns
-the value of the expression
+non-negative number on success, a negative error code on failure
 """
-function av_expr_eval(e, const_values, opaque)
-    ccall((:av_expr_eval, libavutil), Cdouble, (Ptr{AVExpr}, Ptr{Cdouble}, Ptr{Cvoid}), e, const_values, opaque)
+function av_fifo_read_to_cb(f, write_cb::AVFifoCB, opaque, nb_elems)
+    ccall((:av_fifo_read_to_cb, libavutil), Cint, (Ptr{AVFifo}, AVFifoCB, Ptr{Cvoid}, Ptr{Csize_t}), f, write_cb, opaque, nb_elems)
 end
 
 """
-    av_expr_count_vars(e, counter, size::Integer)
-
-Track the presence of variables and their number of occurrences in a parsed expression
+    av_fifo_peek(f, buf, nb_elems::Csize_t, offset::Csize_t)
 
-### Parameters
-* `counter`: a zero-initialized array where the count of each variable will be stored 
+Read data from a FIFO without modifying FIFO state.
 
-* `size`: size of array 
+Returns an error if an attempt is made to peek to nonexistent elements (i.e. if offset + nb\\_elems is larger than [`av_fifo_can_read`](@ref)(f)).
 
+### Parameters
+* `f`: the FIFO buffer
+* `buf`: Buffer to store the data. nb\\_elems * [`av_fifo_elem_size`](@ref)(f) bytes will be written into buf.
+* `nb_elems`: number of elements to read from FIFO
+* `offset`: number of initial elements to skip.
 ### Returns
-0 on success, a negative value indicates that no expression or array was passed or size was zero
+a non-negative number on success, a negative error code on failure
 """
-function av_expr_count_vars(e, counter, size::Integer)
-    ccall((:av_expr_count_vars, libavutil), Cint, (Ptr{AVExpr}, Ptr{Cuint}, Cint), e, counter, size)
+function av_fifo_peek(f, buf, nb_elems::Csize_t, offset::Csize_t)
+    ccall((:av_fifo_peek, libavutil), Cint, (Ptr{AVFifo}, Ptr{Cvoid}, Csize_t, Csize_t), f, buf, nb_elems, offset)
 end
 
 """
-    av_expr_count_func(e, counter, size::Integer, arg::Integer)
+    av_fifo_peek_to_cb(f, write_cb::AVFifoCB, opaque, nb_elems, offset::Csize_t)
 
-Track the presence of user provided functions and their number of occurrences in a parsed expression.
+Feed data from a FIFO into a user-provided callback.
 
 ### Parameters
-* `counter`: a zero-initialized array where the count of each function will be stored if you passed 5 functions with 2 arguments to [`av_expr_parse`](@ref)() then for arg=2 this will use upto 5 entries. 
-
-* `size`: size of array 
-
-* `arg`: number of arguments the counted functions have 
-
+* `f`: the FIFO buffer
+* `write_cb`: Callback the data will be supplied to. May be called multiple times.
+* `opaque`: opaque user data to be provided to write\\_cb
+* `nb_elems`: Should point to the maximum number of elements that can be read. Will be updated to contain the total number of elements actually sent to the callback.
+* `offset`: number of initial elements to skip; offset + *nb\\_elems must not be larger than [`av_fifo_can_read`](@ref)(f).
 ### Returns
-0 on success, a negative value indicates that no expression or array was passed or size was zero
+a non-negative number on success, a negative error code on failure
 """
-function av_expr_count_func(e, counter, size::Integer, arg::Integer)
-    ccall((:av_expr_count_func, libavutil), Cint, (Ptr{AVExpr}, Ptr{Cuint}, Cint, Cint), e, counter, size, arg)
+function av_fifo_peek_to_cb(f, write_cb::AVFifoCB, opaque, nb_elems, offset::Csize_t)
+    ccall((:av_fifo_peek_to_cb, libavutil), Cint, (Ptr{AVFifo}, AVFifoCB, Ptr{Cvoid}, Ptr{Csize_t}, Csize_t), f, write_cb, opaque, nb_elems, offset)
 end
 
 """
-    av_expr_free(e)
+    av_fifo_drain2(f, size::Csize_t)
 
-Free a parsed expression previously created with [`av_expr_parse`](@ref)().
+Discard the specified amount of data from an [`AVFifo`](@ref).
+
+### Parameters
+* `size`: number of elements to discard, MUST NOT be larger than [`av_fifo_can_read`](@ref)(f)
 """
-function av_expr_free(e)
-    ccall((:av_expr_free, libavutil), Cvoid, (Ptr{AVExpr},), e)
+function av_fifo_drain2(f, size::Csize_t)
+    ccall((:av_fifo_drain2, libavutil), Cvoid, (Ptr{AVFifo}, Csize_t), f, size)
+end
+
+function av_fifo_reset2(f)
+    ccall((:av_fifo_reset2, libavutil), Cvoid, (Ptr{AVFifo},), f)
 end
 
 """
-    av_strtod(numstr, tail)
+    av_fifo_freep2(f)
 
-Parse the string in numstr and return its value as a double. If the string is empty, contains only whitespaces, or does not contain an initial substring that has the expected syntax for a floating-point number, no conversion is performed. In this case, returns a value of zero and the value returned in tail is the value of numstr.
+Free an [`AVFifo`](@ref) and reset pointer to NULL.
 
 ### Parameters
-* `numstr`: a string representing a number, may contain one of the International System number postfixes, for example 'K', 'M', 'G'. If 'i' is appended after the postfix, powers of 2 are used instead of powers of 10. The 'B' postfix multiplies the value by 8, and can be appended after another postfix or used alone. This allows using for example 'KB', 'MiB', 'G' and 'B' as postfix. 
-
-* `tail`: if non-NULL puts here the pointer to the char next after the last parsed character
+* `f`: Pointer to an [`AVFifo`](@ref) to free. *f == NULL is allowed.
 """
-function av_strtod(numstr, tail)
-    ccall((:av_strtod, libavutil), Cdouble, (Cstring, Ptr{Cstring}), numstr, tail)
+function av_fifo_freep2(f)
+    ccall((:av_fifo_freep2, libavutil), Cvoid, (Ptr{Ptr{AVFifo}},), f)
 end
 
 struct AVFifoBuffer
@@ -13090,11 +13452,12 @@ end
 """
     av_fifo_alloc(size::Integer)
 
-Initialize an [`AVFifoBuffer`](@ref). 
+Initialize an [`AVFifoBuffer`](@ref).
 
-### Parameters
-* `size`: of FIFO 
+\\deprecated use [`av_fifo_alloc2`](@ref)()
 
+### Parameters
+* `size`: of FIFO
 ### Returns
 [`AVFifoBuffer`](@ref) or NULL in case of memory allocation failure
 """
@@ -13105,13 +13468,13 @@ end
 """
     av_fifo_alloc_array(nmemb::Csize_t, size::Csize_t)
 
-Initialize an [`AVFifoBuffer`](@ref). 
+Initialize an [`AVFifoBuffer`](@ref).
 
-### Parameters
-* `nmemb`: number of elements 
-
-* `size`: size of the single element 
+\\deprecated use [`av_fifo_alloc2`](@ref)()
 
+### Parameters
+* `nmemb`: number of elements
+* `size`: size of the single element
 ### Returns
 [`AVFifoBuffer`](@ref) or NULL in case of memory allocation failure
 """
@@ -13122,7 +13485,9 @@ end
 """
     av_fifo_free(f)
 
-Free an [`AVFifoBuffer`](@ref). 
+Free an [`AVFifoBuffer`](@ref).
+
+\\deprecated use the [`AVFifo`](@ref) API with [`av_fifo_freep2`](@ref)()
 
 ### Parameters
 * `f`: [`AVFifoBuffer`](@ref) to free
@@ -13134,7 +13499,9 @@ end
 """
     av_fifo_freep(f)
 
-Free an [`AVFifoBuffer`](@ref) and reset pointer to NULL. 
+Free an [`AVFifoBuffer`](@ref) and reset pointer to NULL.
+
+\\deprecated use the [`AVFifo`](@ref) API with [`av_fifo_freep2`](@ref)()
 
 ### Parameters
 * `f`: [`AVFifoBuffer`](@ref) to free
@@ -13146,7 +13513,9 @@ end
 """
     av_fifo_reset(f)
 
-Reset the [`AVFifoBuffer`](@ref) to the state right after [`av_fifo_alloc`](@ref), in particular it is emptied. 
+Reset the [`AVFifoBuffer`](@ref) to the state right after [`av_fifo_alloc`](@ref), in particular it is emptied.
+
+\\deprecated use [`av_fifo_reset2`](@ref)() with the new [`AVFifo`](@ref)-API
 
 ### Parameters
 * `f`: [`AVFifoBuffer`](@ref) to reset
@@ -13158,11 +13527,12 @@ end
 """
     av_fifo_size(f)
 
-Return the amount of data in bytes in the [`AVFifoBuffer`](@ref), that is the amount of data you can read from it. 
+Return the amount of data in bytes in the [`AVFifoBuffer`](@ref), that is the amount of data you can read from it.
 
-### Parameters
-* `f`: [`AVFifoBuffer`](@ref) to read from 
+\\deprecated use [`av_fifo_can_read`](@ref)() with the new [`AVFifo`](@ref)-API
 
+### Parameters
+* `f`: [`AVFifoBuffer`](@ref) to read from
 ### Returns
 size
 """
@@ -13173,11 +13543,12 @@ end
 """
     av_fifo_space(f)
 
-Return the amount of space in bytes in the [`AVFifoBuffer`](@ref), that is the amount of data you can write into it. 
+Return the amount of space in bytes in the [`AVFifoBuffer`](@ref), that is the amount of data you can write into it.
 
-### Parameters
-* `f`: [`AVFifoBuffer`](@ref) to write into 
+\\deprecated use [`av_fifo_can_write`](@ref)() with the new [`AVFifo`](@ref)-API
 
+### Parameters
+* `f`: [`AVFifoBuffer`](@ref) to write into
 ### Returns
 size
 """
@@ -13188,18 +13559,18 @@ end
 """
     av_fifo_generic_peek_at(f, dest, offset::Integer, buf_size::Integer, func)
 
-Feed data at specific position from an [`AVFifoBuffer`](@ref) to a user-supplied callback. Similar as av\\_fifo\\_gereric\\_read but without discarding data. 
-
-### Parameters
-* `f`: [`AVFifoBuffer`](@ref) to read from 
-
-* `offset`: offset from current read position 
-
-* `buf_size`: number of bytes to read 
+Feed data at specific position from an [`AVFifoBuffer`](@ref) to a user-supplied callback. Similar as av\\_fifo\\_gereric\\_read but without discarding data.
 
-* `func`: generic read function 
+\\deprecated use the new [`AVFifo`](@ref)-API with [`av_fifo_peek`](@ref)() when func == NULL, [`av_fifo_peek_to_cb`](@ref)() otherwise
 
+### Parameters
+* `f`: [`AVFifoBuffer`](@ref) to read from
+* `offset`: offset from current read position
+* `buf_size`: number of bytes to read
+* `func`: generic read function
 * `dest`: data destination
+### Returns
+a non-negative number on success, a negative error code on failure
 """
 function av_fifo_generic_peek_at(f, dest, offset::Integer, buf_size::Integer, func)
     ccall((:av_fifo_generic_peek_at, libavutil), Cint, (Ptr{AVFifoBuffer}, Ptr{Cvoid}, Cint, Cint, Ptr{Cvoid}), f, dest, offset, buf_size, func)
@@ -13208,16 +13579,17 @@ end
 """
     av_fifo_generic_peek(f, dest, buf_size::Integer, func)
 
-Feed data from an [`AVFifoBuffer`](@ref) to a user-supplied callback. Similar as av\\_fifo\\_gereric\\_read but without discarding data. 
+Feed data from an [`AVFifoBuffer`](@ref) to a user-supplied callback. Similar as av\\_fifo\\_gereric\\_read but without discarding data.
 
-### Parameters
-* `f`: [`AVFifoBuffer`](@ref) to read from 
-
-* `buf_size`: number of bytes to read 
-
-* `func`: generic read function 
+\\deprecated use the new [`AVFifo`](@ref)-API with [`av_fifo_peek`](@ref)() when func == NULL, [`av_fifo_peek_to_cb`](@ref)() otherwise
 
+### Parameters
+* `f`: [`AVFifoBuffer`](@ref) to read from
+* `buf_size`: number of bytes to read
+* `func`: generic read function
 * `dest`: data destination
+### Returns
+a non-negative number on success, a negative error code on failure
 """
 function av_fifo_generic_peek(f, dest, buf_size::Integer, func)
     ccall((:av_fifo_generic_peek, libavutil), Cint, (Ptr{AVFifoBuffer}, Ptr{Cvoid}, Cint, Ptr{Cvoid}), f, dest, buf_size, func)
@@ -13226,16 +13598,17 @@ end
 """
     av_fifo_generic_read(f, dest, buf_size::Integer, func)
 
-Feed data from an [`AVFifoBuffer`](@ref) to a user-supplied callback. 
-
-### Parameters
-* `f`: [`AVFifoBuffer`](@ref) to read from 
-
-* `buf_size`: number of bytes to read 
+Feed data from an [`AVFifoBuffer`](@ref) to a user-supplied callback.
 
-* `func`: generic read function 
+\\deprecated use the new [`AVFifo`](@ref)-API with [`av_fifo_read`](@ref)() when func == NULL, [`av_fifo_read_to_cb`](@ref)() otherwise
 
+### Parameters
+* `f`: [`AVFifoBuffer`](@ref) to read from
+* `buf_size`: number of bytes to read
+* `func`: generic read function
 * `dest`: data destination
+### Returns
+a non-negative number on success, a negative error code on failure
 """
 function av_fifo_generic_read(f, dest, buf_size::Integer, func)
     ccall((:av_fifo_generic_read, libavutil), Cint, (Ptr{AVFifoBuffer}, Ptr{Cvoid}, Cint, Ptr{Cvoid}), f, dest, buf_size, func)
@@ -13244,19 +13617,17 @@ end
 """
     av_fifo_generic_write(f, src, size::Integer, func)
 
-Feed data from a user-supplied callback to an [`AVFifoBuffer`](@ref). 
-
-### Parameters
-* `f`: [`AVFifoBuffer`](@ref) to write to 
-
-* `src`: data source; non-const since it may be used as a modifiable context by the function defined in func 
-
-* `size`: number of bytes to write 
+Feed data from a user-supplied callback to an [`AVFifoBuffer`](@ref).
 
-* `func`: generic write function; the first parameter is src, the second is dest\\_buf, the third is dest\\_buf\\_size. func must return the number of bytes written to dest\\_buf, or <= 0 to indicate no more data available to write. If func is NULL, src is interpreted as a simple byte array for source data. 
+\\deprecated use the new [`AVFifo`](@ref)-API with [`av_fifo_write`](@ref)() when func == NULL, [`av_fifo_write_from_cb`](@ref)() otherwise
 
+### Parameters
+* `f`: [`AVFifoBuffer`](@ref) to write to
+* `src`: data source; non-const since it may be used as a modifiable context by the function defined in func
+* `size`: number of bytes to write
+* `func`: generic write function; the first parameter is src, the second is dest\\_buf, the third is dest\\_buf\\_size. func must return the number of bytes written to dest\\_buf, or <= 0 to indicate no more data available to write. If func is NULL, src is interpreted as a simple byte array for source data.
 ### Returns
-the number of bytes written to the FIFO
+the number of bytes written to the FIFO or a negative error code on failure
 """
 function av_fifo_generic_write(f, src, size::Integer, func)
     ccall((:av_fifo_generic_write, libavutil), Cint, (Ptr{AVFifoBuffer}, Ptr{Cvoid}, Cint, Ptr{Cvoid}), f, src, size, func)
@@ -13267,11 +13638,11 @@ end
 
 Resize an [`AVFifoBuffer`](@ref). In case of reallocation failure, the old FIFO is kept unchanged.
 
-### Parameters
-* `f`: [`AVFifoBuffer`](@ref) to resize 
-
-* `size`: new [`AVFifoBuffer`](@ref) size in bytes 
+\\deprecated use the new [`AVFifo`](@ref)-API with [`av_fifo_grow2`](@ref)() to increase FIFO size, decreasing FIFO size is not supported
 
+### Parameters
+* `f`: [`AVFifoBuffer`](@ref) to resize
+* `size`: new [`AVFifoBuffer`](@ref) size in bytes
 ### Returns
 <0 for failure, >=0 otherwise
 """
@@ -13284,11 +13655,11 @@ end
 
 Enlarge an [`AVFifoBuffer`](@ref). In case of reallocation failure, the old FIFO is kept unchanged. The new fifo size may be larger than the requested size.
 
-### Parameters
-* `f`: [`AVFifoBuffer`](@ref) to resize 
-
-* `additional_space`: the amount of space in bytes to allocate in addition to [`av_fifo_size`](@ref)() 
+\\deprecated use the new [`AVFifo`](@ref)-API with [`av_fifo_grow2`](@ref)(); note that unlike this function it adds to the allocated size, rather than to the used size
 
+### Parameters
+* `f`: [`AVFifoBuffer`](@ref) to resize
+* `additional_space`: the amount of space in bytes to allocate in addition to [`av_fifo_size`](@ref)()
 ### Returns
 <0 for failure, >=0 otherwise
 """
@@ -13299,11 +13670,12 @@ end
 """
     av_fifo_drain(f, size::Integer)
 
-Read and discard the specified amount of data from an [`AVFifoBuffer`](@ref). 
+Read and discard the specified amount of data from an [`AVFifoBuffer`](@ref).
 
-### Parameters
-* `f`: [`AVFifoBuffer`](@ref) to read from 
+\\deprecated use the new [`AVFifo`](@ref)-API with [`av_fifo_drain2`](@ref)()
 
+### Parameters
+* `f`: [`AVFifoBuffer`](@ref) to read from
 * `size`: amount of data to read in bytes
 """
 function av_fifo_drain(f, size::Integer)
@@ -13315,9 +13687,10 @@ end
 
 Return a pointer to the data stored in a FIFO buffer at a certain offset. The FIFO buffer is not modified.
 
-### Parameters
-* `f`: [`AVFifoBuffer`](@ref) to peek at, f must be non-NULL 
+\\deprecated use the new [`AVFifo`](@ref)-API with [`av_fifo_peek`](@ref)() or [`av_fifo_peek_to_cb`](@ref)()
 
+### Parameters
+* `f`: [`AVFifoBuffer`](@ref) to peek at, f must be non-NULL
 * `offs`: an offset in bytes, its absolute value must be less than the used buffer size or the returned pointer will point outside to the buffer data. The used buffer size can be checked with [`av_fifo_size`](@ref)().
 """
 function av_fifo_peek2(f, offs::Integer)
@@ -13330,10 +13703,11 @@ end
 Read the file with name filename, and put its content in a newly allocated buffer or map it with mmap() when available. In case of success set *bufptr to the read or mmapped buffer, and *size to the size in bytes of the buffer in *bufptr. Unlike mmap this function succeeds with zero sized files, in this case *bufptr will be set to NULL and *size will be set to 0. The returned buffer must be released with [`av_file_unmap`](@ref)().
 
 ### Parameters
-* `log_offset`: loglevel offset used for logging 
-
-* `log_ctx`: context used for logging 
-
+* `filename`: path to the file
+* `bufptr`:\\[out\\] pointee is set to the mapped or allocated buffer
+* `size`:\\[out\\] pointee is set to the size in bytes of the buffer
+* `log_offset`: loglevel offset used for logging
+* `log_ctx`: context used for logging
 ### Returns
 a non negative number in case of success, a negative value corresponding to an [`AVERROR`](@ref) error code in case of failure
 """
@@ -13347,6 +13721,7 @@ end
 Unmap or free the buffer bufptr created by [`av_file_map`](@ref)().
 
 ### Parameters
+* `bufptr`: the buffer previously created with [`av_file_map`](@ref)()
 * `size`: size in bytes of bufptr, must be the same as returned by [`av_file_map`](@ref)()
 """
 function av_file_unmap(bufptr, size::Csize_t)
@@ -13356,16 +13731,16 @@ end
 """
     av_tempfile(prefix, filename, log_offset::Integer, log_ctx)
 
-Wrapper to work around the lack of mkstemp() on mingw. Also, tries to create file in /tmp first, if possible. *prefix can be a character constant; *filename will be allocated internally. 
+Wrapper to work around the lack of mkstemp() on mingw. Also, tries to create file in /tmp first, if possible. *prefix can be a character constant; *filename will be allocated internally.
 
 !!! note
 
-    On very old libcs it is necessary to set a secure umask before calling this, [`av_tempfile`](@ref)() can't call umask itself as it is used in libraries and could interfere with the calling application. 
+    On very old libcs it is necessary to set a secure umask before calling this, [`av_tempfile`](@ref)() can't call umask itself as it is used in libraries and could interfere with the calling application.
 
 \\deprecated as fd numbers cannot be passed saftely between libs on some platforms
 
 ### Returns
-file descriptor of opened file (or negative value corresponding to an [`AVERROR`](@ref) code on error) and opened file name in **filename. 
+file descriptor of opened file (or negative value corresponding to an [`AVERROR`](@ref) code on error) and opened file name in **filename.
 """
 function av_tempfile(prefix, filename, log_offset::Integer, log_ctx)
     ccall((:av_tempfile, libavutil), Cint, (Cstring, Ptr{Cstring}, Cint, Ptr{Cvoid}), prefix, filename, log_offset, log_ctx)
@@ -13374,6 +13749,7 @@ end
 const AVFilmGrainParamsType = UInt32
 const AV_FILM_GRAIN_PARAMS_NONE = 0 % UInt32
 const AV_FILM_GRAIN_PARAMS_AV1 = 1 % UInt32
+const AV_FILM_GRAIN_PARAMS_H274 = 2 % UInt32
 
 """
     AVFilmGrainAOMParams
@@ -13404,27 +13780,55 @@ struct AVFilmGrainAOMParams
 end
 
 """
-    __JL_Ctag_1123
+    AVFilmGrainH274Params
+
+This structure describes how to handle film grain synthesis for codecs using the ITU-T H.274 Versatile suplemental enhancement information message.
+
+!!! note
+
+    The struct must be allocated as part of [`AVFilmGrainParams`](@ref) using [`av_film_grain_params_alloc`](@ref)(). Its size is not a part of the public ABI.
+"""
+struct AVFilmGrainH274Params
+    model_id::Cint
+    bit_depth_luma::Cint
+    bit_depth_chroma::Cint
+    color_range::AVColorRange
+    color_primaries::AVColorPrimaries
+    color_trc::AVColorTransferCharacteristic
+    color_space::AVColorSpace
+    blending_mode_id::Cint
+    log2_scale_factor::Cint
+    component_model_present::NTuple{3, Cint}
+    num_intensity_intervals::NTuple{3, UInt16}
+    num_model_values::NTuple{3, UInt8}
+    intensity_interval_lower_bound::NTuple{3, NTuple{256, UInt8}}
+    intensity_interval_upper_bound::NTuple{3, NTuple{256, UInt8}}
+    comp_model_value::NTuple{3, NTuple{256, NTuple{6, Int16}}}
+end
+
+"""
+    __JL_Ctag_980
 
 Additional fields may be added both here and in any structure included. If a codec's film grain structure differs slightly over another codec's, fields within may change meaning depending on the type.
 """
-struct __JL_Ctag_1123
-    data::NTuple{208, UInt8}
+struct __JL_Ctag_980
+    data::NTuple{10812, UInt8}
 end
 
-function Base.getproperty(x::Ptr{__JL_Ctag_1123}, f::Symbol)
+function Base.getproperty(x::Ptr{__JL_Ctag_980}, f::Symbol)
     f === :aom && return Ptr{AVFilmGrainAOMParams}(x + 0)
+    f === :h274 && return Ptr{AVFilmGrainH274Params}(x + 0)
     return getfield(x, f)
 end
 
-function Base.getproperty(x::__JL_Ctag_1123, f::Symbol)
-    r = Ref{__JL_Ctag_1123}(x)
-    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_1123}, r)
+function Base.getproperty(x::__JL_Ctag_980, f::Symbol)
+    r = Ref{__JL_Ctag_980}(x)
+    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_980}, r)
     fptr = getproperty(ptr, f)
     GC.@preserve r unsafe_load(fptr)
 end
 
-function Base.setproperty!(x::Ptr{__JL_Ctag_1123}, f::Symbol, v)
+function Base.setproperty!(x::Ptr{__JL_Ctag_980}, f::Symbol, v)
     unsafe_store!(getproperty(x, f), v)
 end
 
@@ -13438,13 +13842,13 @@ This structure describes how to handle film grain synthesis in video for specifi
     The struct must be allocated with [`av_film_grain_params_alloc`](@ref)() and its size is not a part of the public ABI.
 """
 struct AVFilmGrainParams
-    data::NTuple{224, UInt8}
+    data::NTuple{10832, UInt8}
 end
 
 function Base.getproperty(x::Ptr{AVFilmGrainParams}, f::Symbol)
     f === :type && return Ptr{AVFilmGrainParamsType}(x + 0)
     f === :seed && return Ptr{UInt64}(x + 8)
-    f === :codec && return Ptr{__JL_Ctag_1123}(x + 16)
+    f === :codec && return Ptr{__JL_Ctag_980}(x + 16)
     return getfield(x, f)
 end
 
@@ -13478,7 +13882,6 @@ Allocate a complete [`AVFilmGrainParams`](@ref) and add it to the frame.
 
 ### Parameters
 * `frame`: The frame which side data is added to.
-
 ### Returns
 The [`AVFilmGrainParams`](@ref) structure to be filled by caller.
 """
@@ -13488,142 +13891,29 @@ end
 
 const AVActiveFormatDescription = UInt32
 const AV_AFD_SAME = 8 % UInt32
-const AV_AFD_4_3 = 9 % UInt32
-const AV_AFD_16_9 = 10 % UInt32
-const AV_AFD_14_9 = 11 % UInt32
-const AV_AFD_4_3_SP_14_9 = 13 % UInt32
-const AV_AFD_16_9_SP_14_9 = 14 % UInt32
-const AV_AFD_SP_4_3 = 15 % UInt32
-
-"""
-    AVRegionOfInterest
-
-Structure describing a single Region Of Interest.
-
-When multiple regions are defined in a single side-data block, they should be ordered from most to least important - some encoders are only capable of supporting a limited number of distinct regions, so will have to truncate the list.
-
-When overlapping regions are defined, the first region containing a given area of the frame applies.
-"""
-struct AVRegionOfInterest
-    self_size::UInt32
-    top::Cint
-    bottom::Cint
-    left::Cint
-    right::Cint
-    qoffset::AVRational
-end
-
-"""
-    av_frame_get_best_effort_timestamp(frame)
-
-Accessors for some [`AVFrame`](@ref) fields. These used to be provided for ABI compatibility, and do not need to be used anymore.
-"""
-function av_frame_get_best_effort_timestamp(frame)
-    ccall((:av_frame_get_best_effort_timestamp, libavutil), Int64, (Ptr{AVFrame},), frame)
-end
-
-function av_frame_set_best_effort_timestamp(frame, val::Int64)
-    ccall((:av_frame_set_best_effort_timestamp, libavutil), Cvoid, (Ptr{AVFrame}, Int64), frame, val)
-end
-
-function av_frame_get_pkt_duration(frame)
-    ccall((:av_frame_get_pkt_duration, libavutil), Int64, (Ptr{AVFrame},), frame)
-end
-
-function av_frame_set_pkt_duration(frame, val::Int64)
-    ccall((:av_frame_set_pkt_duration, libavutil), Cvoid, (Ptr{AVFrame}, Int64), frame, val)
-end
-
-function av_frame_get_pkt_pos(frame)
-    ccall((:av_frame_get_pkt_pos, libavutil), Int64, (Ptr{AVFrame},), frame)
-end
-
-function av_frame_set_pkt_pos(frame, val::Int64)
-    ccall((:av_frame_set_pkt_pos, libavutil), Cvoid, (Ptr{AVFrame}, Int64), frame, val)
-end
-
-function av_frame_get_channel_layout(frame)
-    ccall((:av_frame_get_channel_layout, libavutil), Int64, (Ptr{AVFrame},), frame)
-end
-
-function av_frame_set_channel_layout(frame, val::Int64)
-    ccall((:av_frame_set_channel_layout, libavutil), Cvoid, (Ptr{AVFrame}, Int64), frame, val)
-end
-
-function av_frame_get_channels(frame)
-    ccall((:av_frame_get_channels, libavutil), Cint, (Ptr{AVFrame},), frame)
-end
-
-function av_frame_set_channels(frame, val::Integer)
-    ccall((:av_frame_set_channels, libavutil), Cvoid, (Ptr{AVFrame}, Cint), frame, val)
-end
-
-function av_frame_get_sample_rate(frame)
-    ccall((:av_frame_get_sample_rate, libavutil), Cint, (Ptr{AVFrame},), frame)
-end
-
-function av_frame_set_sample_rate(frame, val::Integer)
-    ccall((:av_frame_set_sample_rate, libavutil), Cvoid, (Ptr{AVFrame}, Cint), frame, val)
-end
-
-function av_frame_get_metadata(frame)
-    ccall((:av_frame_get_metadata, libavutil), Ptr{AVDictionary}, (Ptr{AVFrame},), frame)
-end
-
-function av_frame_set_metadata(frame, val)
-    ccall((:av_frame_set_metadata, libavutil), Cvoid, (Ptr{AVFrame}, Ptr{AVDictionary}), frame, val)
-end
-
-function av_frame_get_decode_error_flags(frame)
-    ccall((:av_frame_get_decode_error_flags, libavutil), Cint, (Ptr{AVFrame},), frame)
-end
-
-function av_frame_set_decode_error_flags(frame, val::Integer)
-    ccall((:av_frame_set_decode_error_flags, libavutil), Cvoid, (Ptr{AVFrame}, Cint), frame, val)
-end
-
-function av_frame_get_pkt_size(frame)
-    ccall((:av_frame_get_pkt_size, libavutil), Cint, (Ptr{AVFrame},), frame)
-end
-
-function av_frame_set_pkt_size(frame, val::Integer)
-    ccall((:av_frame_set_pkt_size, libavutil), Cvoid, (Ptr{AVFrame}, Cint), frame, val)
-end
-
-function av_frame_get_qp_table(f, stride, type)
-    ccall((:av_frame_get_qp_table, libavutil), Ptr{Int8}, (Ptr{AVFrame}, Ptr{Cint}, Ptr{Cint}), f, stride, type)
-end
-
-function av_frame_set_qp_table(f, buf, stride::Integer, type::Integer)
-    ccall((:av_frame_set_qp_table, libavutil), Cint, (Ptr{AVFrame}, Ptr{AVBufferRef}, Cint, Cint), f, buf, stride, type)
-end
-
-function av_frame_get_colorspace(frame)
-    ccall((:av_frame_get_colorspace, libavutil), AVColorSpace, (Ptr{AVFrame},), frame)
-end
-
-function av_frame_set_colorspace(frame, val::AVColorSpace)
-    ccall((:av_frame_set_colorspace, libavutil), Cvoid, (Ptr{AVFrame}, AVColorSpace), frame, val)
-end
-
-function av_frame_get_color_range(frame)
-    ccall((:av_frame_get_color_range, libavutil), AVColorRange, (Ptr{AVFrame},), frame)
-end
-
-function av_frame_set_color_range(frame, val::AVColorRange)
-    ccall((:av_frame_set_color_range, libavutil), Cvoid, (Ptr{AVFrame}, AVColorRange), frame, val)
-end
+const AV_AFD_4_3 = 9 % UInt32
+const AV_AFD_16_9 = 10 % UInt32
+const AV_AFD_14_9 = 11 % UInt32
+const AV_AFD_4_3_SP_14_9 = 13 % UInt32
+const AV_AFD_16_9_SP_14_9 = 14 % UInt32
+const AV_AFD_SP_4_3 = 15 % UInt32
 
 """
-    av_get_colorspace_name(val::AVColorSpace)
+    AVRegionOfInterest
+
+Structure describing a single Region Of Interest.
 
-Get the name of a colorspace. 
+When multiple regions are defined in a single side-data block, they should be ordered from most to least important - some encoders are only capable of supporting a limited number of distinct regions, so will have to truncate the list.
 
-### Returns
-a static string identifying the colorspace; can be NULL.
+When overlapping regions are defined, the first region containing a given area of the frame applies.
 """
-function av_get_colorspace_name(val::AVColorSpace)
-    ccall((:av_get_colorspace_name, libavutil), Cstring, (AVColorSpace,), val)
+struct AVRegionOfInterest
+    self_size::UInt32
+    top::Cint
+    bottom::Cint
+    left::Cint
+    right::Cint
+    qoffset::AVRational
 end
 
 """
@@ -13674,6 +13964,20 @@ function av_frame_ref(dst, src)
     ccall((:av_frame_ref, libavutil), Cint, (Ptr{AVFrame}, Ptr{AVFrame}), dst, src)
 end
 
+"""
+    av_frame_replace(dst, src)
+
+Ensure the destination frame refers to the same data described by the source frame, either by creating a new reference for each [`AVBufferRef`](@ref) from src if they differ from those in dst, by allocating new buffers and copying data if src is not reference counted, or by unrefencing it if src is empty.
+
+Frame properties on dst will be replaced by those from src.
+
+### Returns
+0 on success, a negative [`AVERROR`](@ref) on error. On error, dst is unreferenced.
+"""
+function av_frame_replace(dst, src)
+    ccall((:av_frame_replace, libavutil), Cint, (Ptr{AVFrame}, Ptr{AVFrame}), dst, src)
+end
+
 """
     av_frame_clone(src)
 
@@ -13715,7 +14019,7 @@ end
 
 Allocate new buffer(s) for audio or video data.
 
-The following fields must be set on frame before calling this function: - format (pixel format for video, sample format for audio) - width and height for video - nb\\_samples and channel\\_layout for audio
+The following fields must be set on frame before calling this function: - format (pixel format for video, sample format for audio) - width and height for video - nb\\_samples and ch\\_layout for audio
 
 This function will fill [`AVFrame`](@ref).data and [`AVFrame`](@ref).buf arrays and, if necessary, allocate and fill [`AVFrame`](@ref).extended\\_data and [`AVFrame`](@ref).extended\\_buf. For planar formats, one buffer will be allocated for each plane.
 
@@ -13724,10 +14028,8 @@ This function will fill [`AVFrame`](@ref).data and [`AVFrame`](@ref).buf arrays
     : if frame already has been allocated, calling this function will leak memory. In addition, undefined behavior can occur in certain cases.
 
 ### Parameters
-* `frame`: frame in which to store the new buffers. 
-
+* `frame`: frame in which to store the new buffers.
 * `align`: Required buffer size alignment. If equal to 0, alignment will be chosen automatically for the current CPU. It is highly recommended to pass 0 here unless you know what you are doing.
-
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) on error.
 """
@@ -13744,7 +14046,6 @@ If 1 is returned the answer is valid until [`av_buffer_ref`](@ref)() is called o
 
 ### Returns
 A positive value if the frame data is writable (which is true if and only if each of the underlying buffers has only one reference, namely the one stored in this frame). Return 0 otherwise.
-
 ### See also
 [`av_frame_make_writable`](@ref)(), [`av_buffer_is_writable`](@ref)()
 """
@@ -13757,11 +14058,10 @@ end
 
 Ensure that the frame data is writable, avoiding data copy if possible.
 
-Do nothing if the frame is writable, allocate new buffers and copy the data if it is not.
+Do nothing if the frame is writable, allocate new buffers and copy the data if it is not. Non-refcounted frames behave as non-writable, i.e. a copy is always made.
 
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) on error.
-
 ### See also
 [`av_frame_is_writable`](@ref)(), [`av_buffer_is_writable`](@ref)(), [`av_buffer_make_writable`](@ref)()
 """
@@ -13802,8 +14102,8 @@ end
 Get the buffer reference a given data plane is stored in.
 
 ### Parameters
+* `frame`: the frame to get the plane's buffer from
 * `plane`: index of the data plane of interest in frame->extended\\_data.
-
 ### Returns
 the buffer reference that contains the plane or NULL if the input frame is not valid.
 """
@@ -13812,22 +14112,19 @@ function av_frame_get_plane_buffer(frame, plane::Integer)
 end
 
 """
-    av_frame_new_side_data(frame, type::AVFrameSideDataType, size::Integer)
+    av_frame_new_side_data(frame, type::AVFrameSideDataType, size::Csize_t)
 
 Add a new side data to a frame.
 
 ### Parameters
-* `frame`: a frame to which the side data should be added 
-
-* `type`: type of the added side data 
-
+* `frame`: a frame to which the side data should be added
+* `type`: type of the added side data
 * `size`: size of the side data
-
 ### Returns
 newly added side data on success, NULL on error
 """
-function av_frame_new_side_data(frame, type::AVFrameSideDataType, size::Integer)
-    ccall((:av_frame_new_side_data, libavutil), Ptr{AVFrameSideData}, (Ptr{AVFrame}, AVFrameSideDataType, Cint), frame, type, size)
+function av_frame_new_side_data(frame, type::AVFrameSideDataType, size::Csize_t)
+    ccall((:av_frame_new_side_data, libavutil), Ptr{AVFrameSideData}, (Ptr{AVFrame}, AVFrameSideDataType, Csize_t), frame, type, size)
 end
 
 """
@@ -13836,12 +14133,9 @@ end
 Add a new side data to a frame from an existing [`AVBufferRef`](@ref)
 
 ### Parameters
-* `frame`: a frame to which the side data should be added 
-
-* `type`: the type of the added side data 
-
+* `frame`: a frame to which the side data should be added
+* `type`: the type of the added side data
 * `buf`: an [`AVBufferRef`](@ref) to add as side data. The ownership of the reference is transferred to the frame.
-
 ### Returns
 newly added side data on success, NULL on error. On failure the frame is unchanged and the [`AVBufferRef`](@ref) remains owned by the caller.
 """
@@ -13869,11 +14163,11 @@ function av_frame_remove_side_data(frame, type::AVFrameSideDataType)
 end
 
 """
-    __JL_Ctag_731
+    __JL_Ctag_626
 
 Flags for frame cropping.
 """
-const __JL_Ctag_731 = UInt32
+const __JL_Ctag_626 = UInt32
 const AV_FRAME_CROP_UNALIGNED = 1 % UInt32
 
 """
@@ -13884,10 +14178,8 @@ Crop the given video [`AVFrame`](@ref) according to its crop\\_left/crop\\_top/c
 In all cases, the cropping boundaries will be rounded to the inherent alignment of the pixel format. In some cases, such as for opaque hwaccel formats, the left/top cropping is ignored. The crop fields are set to 0 even if the cropping was rounded or ignored.
 
 ### Parameters
-* `frame`: the frame which should be cropped 
-
+* `frame`: the frame which should be cropped
 * `flags`: Some combination of AV\\_FRAME\\_CROP\\_* flags, or 0.
-
 ### Returns
 >= 0 on success, a negative [`AVERROR`](@ref) on error. If the cropping fields were invalid, [`AVERROR`](@ref)(ERANGE) is returned, and nothing is changed.
 """
@@ -13906,7 +14198,9 @@ function av_frame_side_data_name(type::AVFrameSideDataType)
 end
 
 """
-ffhash.c This example is a simple command line application that takes one or more arguments. It demonstrates a typical use of the hashing API with allocation, initialization, updating, and finalizing.
+` ffhash.c`
+
+This example is a simple command line application that takes one or more arguments. It demonstrates a typical use of the hashing API with allocation, initialization, updating, and finalizing.
 """
 mutable struct AVHashContext end
 
@@ -13934,8 +14228,7 @@ Get the names of available hash algorithms.
 This function can be used to enumerate the algorithms.
 
 ### Parameters
-* `i`:\\[in\\] Index of the hash algorithm, starting from 0 
-
+* `i`:\\[in\\] Index of the hash algorithm, starting from 0
 ### Returns
 Pointer to a static string or `NULL` if `i` is out of range
 """
@@ -13960,8 +14253,7 @@ Get the size of the resulting hash value in bytes.
 The maximum value this function will currently return is available as macro #[`AV_HASH_MAX_SIZE`](@ref).
 
 ### Parameters
-* `ctx`:\\[in\\] Hash context 
-
+* `ctx`:\\[in\\] Hash context
 ### Returns
 Size of the hash value in bytes
 """
@@ -13981,8 +14273,18 @@ function av_hash_init(ctx)
     ccall((:av_hash_init, libavutil), Cvoid, (Ptr{AVHashContext},), ctx)
 end
 
-function av_hash_update(ctx, src, len::Integer)
-    ccall((:av_hash_update, libavutil), Cvoid, (Ptr{AVHashContext}, Ptr{UInt8}, Cint), ctx, src, len)
+"""
+    av_hash_update(ctx, src, len::Csize_t)
+
+Update a hash context with additional data.
+
+### Parameters
+* `ctx`:\\[in,out\\] Hash context
+* `src`:\\[in\\] Data to be added to the hash context
+* `len`:\\[in\\] Size of the additional data
+"""
+function av_hash_update(ctx, src, len::Csize_t)
+    ccall((:av_hash_update, libavutil), Cvoid, (Ptr{AVHashContext}, Ptr{UInt8}, Csize_t), ctx, src, len)
 end
 
 """
@@ -13995,10 +14297,8 @@ The minimum size of `dst` buffer is given by [`av_hash_get_size`](@ref)() or #[`
 It is not safe to update or finalize a hash context again, if it has already been finalized.
 
 ### Parameters
-* `ctx`:\\[in,out\\] Hash context 
-
+* `ctx`:\\[in,out\\] Hash context
 * `dst`:\\[out\\] Where the final hash value will be stored
-
 ### See also
 [`av_hash_final_bin`](@ref)() provides an alternative API
 """
@@ -14016,10 +14316,8 @@ It is not safe to update or finalize a hash context again, if it has already bee
 If `size` is smaller than the hash size (given by [`av_hash_get_size`](@ref)()), the hash is truncated; if size is larger, the buffer is padded with 0.
 
 ### Parameters
-* `ctx`:\\[in,out\\] Hash context 
-
-* `dst`:\\[out\\] Where the final hash value will be stored 
-
+* `ctx`:\\[in,out\\] Hash context
+* `dst`:\\[out\\] Where the final hash value will be stored
 * `size`:\\[in\\] Number of bytes to write to `dst`
 """
 function av_hash_final_bin(ctx, dst, size::Integer)
@@ -14038,10 +14336,8 @@ The string is always 0-terminated.
 If `size` is smaller than `2 * hash\\_size + 1`, where `hash_size` is the value returned by [`av_hash_get_size`](@ref)(), the string will be truncated.
 
 ### Parameters
-* `ctx`:\\[in,out\\] Hash context 
-
-* `dst`:\\[out\\] Where the string will be stored 
-
+* `ctx`:\\[in,out\\] Hash context
+* `dst`:\\[out\\] Where the string will be stored
 * `size`:\\[in\\] Maximum number of bytes to write to `dst`
 """
 function av_hash_final_hex(ctx, dst, size::Integer)
@@ -14060,10 +14356,8 @@ The string is always 0-terminated.
 If `size` is smaller than [`AV_BASE64_SIZE`](@ref)(hash\\_size), where `hash_size` is the value returned by [`av_hash_get_size`](@ref)(), the string will be truncated.
 
 ### Parameters
-* `ctx`:\\[in,out\\] Hash context 
-
-* `dst`:\\[out\\] Where the final hash value will be stored 
-
+* `ctx`:\\[in,out\\] Hash context
+* `dst`:\\[out\\] Where the final hash value will be stored
 * `size`:\\[in\\] Maximum number of bytes to write to `dst`
 """
 function av_hash_final_b64(ctx, dst, size::Integer)
@@ -14174,11 +14468,10 @@ end
 """
     av_dynamic_hdr_plus_create_side_data(frame)
 
-Allocate a complete [`AVDynamicHDRPlus`](@ref) and add it to the frame. 
+Allocate a complete [`AVDynamicHDRPlus`](@ref) and add it to the frame.
 
 ### Parameters
 * `frame`: The frame which side data is added to.
-
 ### Returns
 The [`AVDynamicHDRPlus`](@ref) structure to be filled by caller or NULL on failure.
 """
@@ -14186,6 +14479,158 @@ function av_dynamic_hdr_plus_create_side_data(frame)
     ccall((:av_dynamic_hdr_plus_create_side_data, libavutil), Ptr{AVDynamicHDRPlus}, (Ptr{AVFrame},), frame)
 end
 
+"""
+    av_dynamic_hdr_plus_from_t35(s, data, size::Csize_t)
+
+Parse the user data registered ITU-T T.35 to AVbuffer ([`AVDynamicHDRPlus`](@ref)). The T.35 buffer must begin with the application mode, skipping the country code, terminal provider codes, and application identifier.
+
+### Parameters
+* `s`: A pointer containing the decoded [`AVDynamicHDRPlus`](@ref) structure.
+* `data`: The byte array containing the raw ITU-T T.35 data.
+* `size`: Size of the data array in bytes.
+### Returns
+>= 0 on success. Otherwise, returns the appropriate [`AVERROR`](@ref).
+"""
+function av_dynamic_hdr_plus_from_t35(s, data, size::Csize_t)
+    ccall((:av_dynamic_hdr_plus_from_t35, libavutil), Cint, (Ptr{AVDynamicHDRPlus}, Ptr{UInt8}, Csize_t), s, data, size)
+end
+
+"""
+    av_dynamic_hdr_plus_to_t35(s, data, size)
+
+Serialize dynamic HDR10+ metadata to a user data registered ITU-T T.35 buffer, excluding the first 48 bytes of the header, and beginning with the application mode.
+
+### Parameters
+* `s`: A pointer containing the decoded [`AVDynamicHDRPlus`](@ref) structure.
+* `data[in,out]`: A pointer to pointer to a byte buffer to be filled with the serialized metadata. If *data is NULL, a buffer be will be allocated and a pointer to it stored in its place. The caller assumes ownership of the buffer. May be NULL, in which case the function will only store the required buffer size in *size.
+* `size[in,out]`: A pointer to a size to be set to the returned buffer's size. If *data is not NULL, *size must contain the size of the input buffer. May be NULL only if *data is NULL.
+### Returns
+>= 0 on success. Otherwise, returns the appropriate [`AVERROR`](@ref).
+"""
+function av_dynamic_hdr_plus_to_t35(s, data, size)
+    ccall((:av_dynamic_hdr_plus_to_t35, libavutil), Cint, (Ptr{AVDynamicHDRPlus}, Ptr{Ptr{UInt8}}, Ptr{Csize_t}), s, data, size)
+end
+
+"""
+    AVHDRVivid3SplineParams
+
+HDR Vivid three spline params.
+"""
+struct AVHDRVivid3SplineParams
+    th_mode::Cint
+    th_enable_mb::AVRational
+    th_enable::AVRational
+    th_delta1::AVRational
+    th_delta2::AVRational
+    enable_strength::AVRational
+end
+
+"""
+    AVHDRVividColorToneMappingParams
+
+Color tone mapping parameters at a processing window in a dynamic metadata for CUVA 005.1:2021.
+"""
+struct AVHDRVividColorToneMappingParams
+    data::NTuple{216, UInt8}
+end
+
+function Base.getproperty(x::Ptr{AVHDRVividColorToneMappingParams}, f::Symbol)
+    f === :targeted_system_display_maximum_luminance && return Ptr{AVRational}(x + 0)
+    f === :base_enable_flag && return Ptr{Cint}(x + 8)
+    f === :base_param_m_p && return Ptr{AVRational}(x + 12)
+    f === :base_param_m_m && return Ptr{AVRational}(x + 20)
+    f === :base_param_m_a && return Ptr{AVRational}(x + 28)
+    f === :base_param_m_b && return Ptr{AVRational}(x + 36)
+    f === :base_param_m_n && return Ptr{AVRational}(x + 44)
+    f === :base_param_k1 && return Ptr{Cint}(x + 52)
+    f === :base_param_k2 && return Ptr{Cint}(x + 56)
+    f === :base_param_k3 && return Ptr{Cint}(x + 60)
+    f === :base_param_Delta_enable_mode && return Ptr{Cint}(x + 64)
+    f === :base_param_Delta && return Ptr{AVRational}(x + 68)
+    f === :three_Spline_enable_flag && return Ptr{Cint}(x + 76)
+    f === :three_Spline_num && return Ptr{Cint}(x + 80)
+    f === :three_Spline_TH_mode && return Ptr{Cint}(x + 84)
+    f === :three_Spline_TH_enable_MB && return Ptr{AVRational}(x + 88)
+    f === :three_Spline_TH_enable && return Ptr{AVRational}(x + 96)
+    f === :three_Spline_TH_Delta1 && return Ptr{AVRational}(x + 104)
+    f === :three_Spline_TH_Delta2 && return Ptr{AVRational}(x + 112)
+    f === :three_Spline_enable_Strength && return Ptr{AVRational}(x + 120)
+    f === :three_spline && return Ptr{NTuple{2, AVHDRVivid3SplineParams}}(x + 128)
+    return getfield(x, f)
+end
+
+function Base.getproperty(x::AVHDRVividColorToneMappingParams, f::Symbol)
+    r = Ref{AVHDRVividColorToneMappingParams}(x)
+    ptr = Base.unsafe_convert(Ptr{AVHDRVividColorToneMappingParams}, r)
+    fptr = getproperty(ptr, f)
+    GC.@preserve r unsafe_load(fptr)
+end
+
+function Base.setproperty!(x::Ptr{AVHDRVividColorToneMappingParams}, f::Symbol, v)
+    unsafe_store!(getproperty(x, f), v)
+end
+
+"""
+    AVHDRVividColorTransformParams
+
+Color transform parameters at a processing window in a dynamic metadata for CUVA 005.1:2021.
+"""
+struct AVHDRVividColorTransformParams
+    minimum_maxrgb::AVRational
+    average_maxrgb::AVRational
+    variance_maxrgb::AVRational
+    maximum_maxrgb::AVRational
+    tone_mapping_mode_flag::Cint
+    tone_mapping_param_num::Cint
+    tm_params::NTuple{2, AVHDRVividColorToneMappingParams}
+    color_saturation_mapping_flag::Cint
+    color_saturation_num::Cint
+    color_saturation_gain::NTuple{8, AVRational}
+end
+
+"""
+    AVDynamicHDRVivid
+
+This struct represents dynamic metadata for color volume transform - CUVA 005.1:2021 standard
+
+To be used as payload of a [`AVFrameSideData`](@ref) or [`AVPacketSideData`](@ref) with the appropriate type.
+
+!!! note
+
+    The struct should be allocated with [`av_dynamic_hdr_vivid_alloc`](@ref)() and its size is not a part of the public ABI.
+"""
+struct AVDynamicHDRVivid
+    system_start_code::UInt8
+    num_windows::UInt8
+    params::NTuple{3, AVHDRVividColorTransformParams}
+end
+
+"""
+    av_dynamic_hdr_vivid_alloc(size)
+
+Allocate an [`AVDynamicHDRVivid`](@ref) structure and set its fields to default values. The resulting struct can be freed using [`av_freep`](@ref)().
+
+### Returns
+An [`AVDynamicHDRVivid`](@ref) filled with default values or NULL on failure.
+"""
+function av_dynamic_hdr_vivid_alloc(size)
+    ccall((:av_dynamic_hdr_vivid_alloc, libavutil), Ptr{AVDynamicHDRVivid}, (Ptr{Csize_t},), size)
+end
+
+"""
+    av_dynamic_hdr_vivid_create_side_data(frame)
+
+Allocate a complete [`AVDynamicHDRVivid`](@ref) and add it to the frame.
+
+### Parameters
+* `frame`: The frame which side data is added to.
+### Returns
+The [`AVDynamicHDRVivid`](@ref) structure to be filled by caller or NULL on failure.
+"""
+function av_dynamic_hdr_vivid_create_side_data(frame)
+    ccall((:av_dynamic_hdr_vivid_create_side_data, libavutil), Ptr{AVDynamicHDRVivid}, (Ptr{AVFrame},), frame)
+end
+
 """
     AVHMACType
 
@@ -14208,7 +14653,7 @@ mutable struct AVHMAC end
 """
     av_hmac_alloc(type::AVHMACType)
 
-Allocate an [`AVHMAC`](@ref) context. 
+Allocate an [`AVHMAC`](@ref) context.
 
 ### Parameters
 * `type`: The hash function used for the HMAC.
@@ -14220,7 +14665,7 @@ end
 """
     av_hmac_free(ctx)
 
-Free an [`AVHMAC`](@ref) context. 
+Free an [`AVHMAC`](@ref) context.
 
 ### Parameters
 * `ctx`: The context to free, may be NULL
@@ -14232,13 +14677,11 @@ end
 """
     av_hmac_init(ctx, key, keylen::Integer)
 
-Initialize an [`AVHMAC`](@ref) context with an authentication key. 
+Initialize an [`AVHMAC`](@ref) context with an authentication key.
 
 ### Parameters
-* `ctx`: The HMAC context 
-
-* `key`: The authentication key 
-
+* `ctx`: The HMAC context
+* `key`: The authentication key
 * `keylen`: The length of the key, in bytes
 """
 function av_hmac_init(ctx, key, keylen::Integer)
@@ -14248,13 +14691,11 @@ end
 """
     av_hmac_update(ctx, data, len::Integer)
 
-Hash data with the HMAC. 
+Hash data with the HMAC.
 
 ### Parameters
-* `ctx`: The HMAC context 
-
-* `data`: The data to hash 
-
+* `ctx`: The HMAC context
+* `data`: The data to hash
 * `len`: The length of the data, in bytes
 """
 function av_hmac_update(ctx, data, len::Integer)
@@ -14264,15 +14705,12 @@ end
 """
     av_hmac_final(ctx, out, outlen::Integer)
 
-Finish hashing and output the HMAC digest. 
+Finish hashing and output the HMAC digest.
 
 ### Parameters
-* `ctx`: The HMAC context 
-
-* `out`: The output buffer to write the digest into 
-
-* `outlen`: The length of the out buffer, in bytes 
-
+* `ctx`: The HMAC context
+* `out`: The output buffer to write the digest into
+* `outlen`: The length of the out buffer, in bytes
 ### Returns
 The number of bytes written to out, or a negative error code.
 """
@@ -14283,23 +14721,16 @@ end
 """
     av_hmac_calc(ctx, data, len::Integer, key, keylen::Integer, out, outlen::Integer)
 
-Hash an array of data with a key. 
+Hash an array of data with a key.
 
 ### Parameters
-* `ctx`: The HMAC context 
-
-* `data`: The data to hash 
-
-* `len`: The length of the data, in bytes 
-
-* `key`: The authentication key 
-
-* `keylen`: The length of the key, in bytes 
-
-* `out`: The output buffer to write the digest into 
-
-* `outlen`: The length of the out buffer, in bytes 
-
+* `ctx`: The HMAC context
+* `data`: The data to hash
+* `len`: The length of the data, in bytes
+* `key`: The authentication key
+* `keylen`: The length of the key, in bytes
+* `out`: The output buffer to write the digest into
+* `outlen`: The length of the out buffer, in bytes
 ### Returns
 The number of bytes written to out, or a negative error code.
 """
@@ -14356,8 +14787,7 @@ end
 Look up an [`AVHWDeviceType`](@ref) by name.
 
 ### Parameters
-* `name`: String name of the device type (case-insensitive). 
-
+* `name`: String name of the device type (case-insensitive).
 ### Returns
 The type from enum [`AVHWDeviceType`](@ref), or AV\\_HWDEVICE\\_TYPE\\_NONE if not found.
 """
@@ -14371,8 +14801,7 @@ end
 Get the string name of an [`AVHWDeviceType`](@ref).
 
 ### Parameters
-* `type`: Type from enum [`AVHWDeviceType`](@ref). 
-
+* `type`: Type from enum [`AVHWDeviceType`](@ref).
 ### Returns
 Pointer to a static string containing the name, or NULL if the type is not valid.
 """
@@ -14386,8 +14815,7 @@ end
 Iterate over supported device types.
 
 ### Parameters
-* `type`: AV\\_HWDEVICE\\_TYPE\\_NONE initially, then the previous type returned by this function in subsequent iterations. 
-
+* `prev`: AV\\_HWDEVICE\\_TYPE\\_NONE initially, then the previous type returned by this function in subsequent iterations.
 ### Returns
 The next usable device type from enum [`AVHWDeviceType`](@ref), or AV\\_HWDEVICE\\_TYPE\\_NONE if there are no more.
 """
@@ -14401,8 +14829,7 @@ end
 Allocate an [`AVHWDeviceContext`](@ref) for a given hardware type.
 
 ### Parameters
-* `type`: the type of the hardware device to allocate. 
-
+* `type`: the type of the hardware device to allocate.
 ### Returns
 a reference to the newly created [`AVHWDeviceContext`](@ref) on success or NULL on failure.
 """
@@ -14416,8 +14843,7 @@ end
 Finalize the device context before use. This function must be called after the context is filled with all the required information and before it is used in any way.
 
 ### Parameters
-* `ref`: a reference to the [`AVHWDeviceContext`](@ref) 
-
+* `ref`: a reference to the [`AVHWDeviceContext`](@ref)
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) code on failure
 """
@@ -14435,16 +14861,11 @@ This is a convenience function intended to cover the simple cases. Callers who n
 The returned context is already initialized and ready for use, the caller should not call [`av_hwdevice_ctx_init`](@ref)() on it. The user\\_opaque/free fields of the created [`AVHWDeviceContext`](@ref) are set by this function and should not be touched by the caller.
 
 ### Parameters
-* `device_ctx`: On success, a reference to the newly-created device context will be written here. The reference is owned by the caller and must be released with [`av_buffer_unref`](@ref)() when no longer needed. On failure, NULL will be written to this pointer. 
-
-* `type`: The type of the device to create. 
-
-* `device`: A type-specific string identifying the device to open. 
-
-* `opts`: A dictionary of additional (type-specific) options to use in opening the device. The dictionary remains owned by the caller. 
-
+* `device_ctx`: On success, a reference to the newly-created device context will be written here. The reference is owned by the caller and must be released with [`av_buffer_unref`](@ref)() when no longer needed. On failure, NULL will be written to this pointer.
+* `type`: The type of the device to create.
+* `device`: A type-specific string identifying the device to open.
+* `opts`: A dictionary of additional (type-specific) options to use in opening the device. The dictionary remains owned by the caller.
 * `flags`: currently unused
-
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) code on failure.
 """
@@ -14462,14 +14883,10 @@ If the source device is a device of the target type or was originally derived fr
 Otherwise, it will attempt to derive a new device from the given source device. If direct derivation to the new type is not implemented, it will attempt the same derivation from each ancestor of the source device in turn looking for an implemented derivation method.
 
 ### Parameters
-* `dst_ctx`: On success, a reference to the newly-created [`AVHWDeviceContext`](@ref). 
-
-* `type`: The type of the new device to create. 
-
-* `src_ctx`: A reference to an existing [`AVHWDeviceContext`](@ref) which will be used to create the new device. 
-
-* `flags`: Currently unused; should be set to zero. 
-
+* `dst_ctx`: On success, a reference to the newly-created [`AVHWDeviceContext`](@ref).
+* `type`: The type of the new device to create.
+* `src_ctx`: A reference to an existing [`AVHWDeviceContext`](@ref) which will be used to create the new device.
+* `flags`: Currently unused; should be set to zero.
 ### Returns
 Zero on success, a negative [`AVERROR`](@ref) code on failure.
 """
@@ -14485,16 +14902,11 @@ Create a new device of the specified type from an existing device.
 This function performs the same action as [`av_hwdevice_ctx_create_derived`](@ref), however, it is able to set options for the new device to be derived.
 
 ### Parameters
-* `dst_ctx`: On success, a reference to the newly-created [`AVHWDeviceContext`](@ref). 
-
-* `type`: The type of the new device to create. 
-
-* `src_ctx`: A reference to an existing [`AVHWDeviceContext`](@ref) which will be used to create the new device. 
-
-* `options`: Options for the new device to create, same format as in [`av_hwdevice_ctx_create`](@ref). 
-
-* `flags`: Currently unused; should be set to zero. 
-
+* `dst_ctx`: On success, a reference to the newly-created [`AVHWDeviceContext`](@ref).
+* `type`: The type of the new device to create.
+* `src_ctx`: A reference to an existing [`AVHWDeviceContext`](@ref) which will be used to create the new device.
+* `options`: Options for the new device to create, same format as in [`av_hwdevice_ctx_create`](@ref).
+* `flags`: Currently unused; should be set to zero.
 ### Returns
 Zero on success, a negative [`AVERROR`](@ref) code on failure.
 """
@@ -14508,8 +14920,7 @@ end
 Allocate an [`AVHWFramesContext`](@ref) tied to a given device context.
 
 ### Parameters
-* `device_ctx`: a reference to a [`AVHWDeviceContext`](@ref). This function will make a new reference for internal use, the one passed to the function remains owned by the caller. 
-
+* `device_ctx`: a reference to a [`AVHWDeviceContext`](@ref). This function will make a new reference for internal use, the one passed to the function remains owned by the caller.
 ### Returns
 a reference to the newly created [`AVHWFramesContext`](@ref) on success or NULL on failure.
 """
@@ -14523,8 +14934,7 @@ end
 Finalize the context before use. This function must be called after the context is filled with all the required information and before it is attached to any frames.
 
 ### Parameters
-* `ref`: a reference to the [`AVHWFramesContext`](@ref) 
-
+* `ref`: a reference to the [`AVHWFramesContext`](@ref)
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) code on failure
 """
@@ -14538,12 +14948,9 @@ end
 Allocate a new frame attached to the given [`AVHWFramesContext`](@ref).
 
 ### Parameters
-* `hwframe_ctx`: a reference to an [`AVHWFramesContext`](@ref) 
-
-* `frame`: an empty (freshly allocated or unreffed) frame to be filled with newly allocated buffers. 
-
-* `flags`: currently unused, should be set to zero 
-
+* `hwframe_ctx`: a reference to an [`AVHWFramesContext`](@ref)
+* `frame`: an empty (freshly allocated or unreffed) frame to be filled with newly allocated buffers.
+* `flags`: currently unused, should be set to zero
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) code on failure
 """
@@ -14563,12 +14970,9 @@ dst may be "clean" (i.e. with data/buf pointers unset), in which case the data b
 The two frames must have matching allocated dimensions (i.e. equal to [`AVHWFramesContext`](@ref).width/height), since not all device types support transferring a sub-rectangle of the whole surface. The display dimensions (i.e. [`AVFrame`](@ref).width/height) may be smaller than the allocated dimensions, but also have to be equal for both frames. When the display dimensions are smaller than the allocated dimensions, the content of the padding in the destination frame is unspecified.
 
 ### Parameters
-* `dst`: the destination frame. dst is not touched on failure. 
-
-* `src`: the source frame. 
-
-* `flags`: currently unused, should be set to zero 
-
+* `dst`: the destination frame. dst is not touched on failure.
+* `src`: the source frame.
+* `flags`: currently unused, should be set to zero
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) error code on failure.
 """
@@ -14586,14 +14990,10 @@ const AV_HWFRAME_TRANSFER_DIRECTION_TO = 1 % UInt32
 Get a list of possible source or target formats usable in [`av_hwframe_transfer_data`](@ref)().
 
 ### Parameters
-* `hwframe_ctx`: the frame context to obtain the information for 
-
-* `dir`: the direction of the transfer 
-
-* `formats`: the pointer to the output format list will be written here. The list is terminated with AV\\_PIX\\_FMT\\_NONE and must be freed by the caller when no longer needed using [`av_free`](@ref)(). If this function returns successfully, the format list will have at least one item (not counting the terminator). On failure, the contents of this pointer are unspecified. 
-
-* `flags`: currently unused, should be set to zero 
-
+* `hwframe_ctx`: the frame context to obtain the information for
+* `dir`: the direction of the transfer
+* `formats`: the pointer to the output format list will be written here. The list is terminated with AV\\_PIX\\_FMT\\_NONE and must be freed by the caller when no longer needed using [`av_free`](@ref)(). If this function returns successfully, the format list will have at least one item (not counting the terminator). On failure, the contents of this pointer are unspecified.
+* `flags`: currently unused, should be set to zero
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) code on failure.
 """
@@ -14621,8 +15021,7 @@ end
 Allocate a HW-specific configuration structure for a given HW device. After use, the user must free all members as required by the specific hardware structure being used, then free the structure itself with [`av_free`](@ref)().
 
 ### Parameters
-* `device_ctx`: a reference to the associated [`AVHWDeviceContext`](@ref). 
-
+* `device_ctx`: a reference to the associated [`AVHWDeviceContext`](@ref).
 ### Returns
 The newly created HW-specific configuration structure on success or NULL on failure.
 """
@@ -14636,10 +15035,8 @@ end
 Get the constraints on HW frames given a device and the HW-specific configuration to be used with that device. If no HW-specific configuration is provided, returns the maximum possible capabilities of the device.
 
 ### Parameters
-* `ref`: a reference to the associated [`AVHWDeviceContext`](@ref). 
-
-* `hwconfig`: a filled HW-specific configuration structure, or NULL to return the maximum possible capabilities of the device. 
-
+* `ref`: a reference to the associated [`AVHWDeviceContext`](@ref).
+* `hwconfig`: a filled HW-specific configuration structure, or NULL to return the maximum possible capabilities of the device.
 ### Returns
 [`AVHWFramesConstraints`](@ref) structure describing the constraints on the device, or NULL if not available.
 """
@@ -14660,11 +15057,11 @@ function av_hwframe_constraints_free(constraints)
 end
 
 """
-    __JL_Ctag_779
+    __JL_Ctag_697
 
 Flags to apply to frame mappings.
 """
-const __JL_Ctag_779 = UInt32
+const __JL_Ctag_697 = UInt32
 const AV_HWFRAME_MAP_READ = 1 % UInt32
 const AV_HWFRAME_MAP_WRITE = 2 % UInt32
 const AV_HWFRAME_MAP_OVERWRITE = 4 % UInt32
@@ -14685,13 +15082,12 @@ If src has a hwframe context but dst does not, then the src frame is mapped to n
 
 A return value of [`AVERROR`](@ref)(ENOSYS) indicates that the mapping is not possible with the given arguments and hwframe setup, while other return values indicate that it failed somehow.
 
-### Parameters
-* `dst`: Destination frame, to contain the mapping. 
-
-* `src`: Source frame, to be mapped. 
-
-* `flags`: Some combination of AV\\_HWFRAME\\_MAP\\_* flags. 
+On failure, the destination frame will be left blank, except for the hw\\_frames\\_ctx/format fields thay may have been set by the caller - those will be preserved as they were.
 
+### Parameters
+* `dst`: Destination frame, to contain the mapping.
+* `src`: Source frame, to be mapped.
+* `flags`: Some combination of AV\\_HWFRAME\\_MAP\\_* flags.
 ### Returns
 Zero on success, negative [`AVERROR`](@ref) code on failure.
 """
@@ -14707,14 +15103,11 @@ Create and initialise an [`AVHWFramesContext`](@ref) as a mapping of another exi
 [`av_hwframe_ctx_init`](@ref)() should not be called after this.
 
 ### Parameters
-* `derived_frame_ctx`: On success, a reference to the newly created [`AVHWFramesContext`](@ref). 
-
-* `derived_device_ctx`: A reference to the device to create the new [`AVHWFramesContext`](@ref) on. 
-
-* `source_frame_ctx`: A reference to an existing [`AVHWFramesContext`](@ref) which will be mapped to the derived context. 
-
-* `flags`: Some combination of AV\\_HWFRAME\\_MAP\\_* flags, defining the mapping parameters to apply to frames which are allocated in the derived device. 
-
+* `derived_frame_ctx`: On success, a reference to the newly created [`AVHWFramesContext`](@ref).
+* `format`: The [`AVPixelFormat`](@ref) for the derived context.
+* `derived_device_ctx`: A reference to the device to create the new [`AVHWFramesContext`](@ref) on.
+* `source_frame_ctx`: A reference to an existing [`AVHWFramesContext`](@ref) which will be mapped to the derived context.
+* `flags`: Some combination of AV\\_HWFRAME\\_MAP\\_* flags, defining the mapping parameters to apply to frames which are allocated in the derived device.
 ### Returns
 Zero on success, negative [`AVERROR`](@ref) code on failure.
 """
@@ -14749,16 +15142,163 @@ struct AVD3D11VAFramesContext
     texture::Ptr{Cint}
     BindFlags::Cint
     MiscFlags::Cint
-end
-
-"""
-    __JL_Ctag_781
+    texture_infos::Ptr{AVD3D11FrameDescriptor}
+end
+
+"""
+    __JL_Ctag_699
+
+`
+ * API-specific header for AV_HWDEVICE_TYPE_DRM.
+ *
+ * Internal frame allocation is not currently supported - all frames
+ * must be allocated by the user.  Thus AVHWFramesContext is always
+ * NULL, though this may change if support for frame allocation is
+ * added in future.
+ */
+
+enum {
+    /**
+     * The maximum number of layers/planes in a DRM frame.
+     */
+    AV_DRM_MAX_PLANES = 4
+};
+
+/**
+ * DRM object descriptor.
+ *
+ * Describes a single DRM object, addressing it as a PRIME file
+ * descriptor.
+ */
+typedef struct AVDRMObjectDescriptor {
+    /**
+     * DRM PRIME fd for the object.
+     */
+    int fd;
+    /**
+     * Total size of the object.
+     *
+     * (This includes any parts not which do not contain image data.)
+     */
+    size_t size;
+    /**
+     * Format modifier applied to the object (DRM_FORMAT_MOD_*).
+     *
+     * If the format modifier is unknown then this should be set to
+     * DRM_FORMAT_MOD_INVALID.
+     */
+    uint64_t format_modifier;
+} AVDRMObjectDescriptor;
+
+/**
+ * DRM plane descriptor.
+ *
+ * Describes a single plane of a layer, which is contained within
+ * a single object.
+ */
+typedef struct AVDRMPlaneDescriptor {
+    /**
+     * Index of the object containing this plane in the objects
+     * array of the enclosing frame descriptor.
+     */
+    int object_index;
+    /**
+     * Offset within that object of this plane.
+     */
+    ptrdiff_t offset;
+    /**
+     * Pitch (linesize) of this plane.
+     */
+    ptrdiff_t pitch;
+} AVDRMPlaneDescriptor;
+
+/**
+ * DRM layer descriptor.
+ *
+ * Describes a single layer within a frame.  This has the structure
+ * defined by its format, and will contain one or more planes.
+ */
+typedef struct AVDRMLayerDescriptor {
+    /**
+     * Format of the layer (DRM_FORMAT_*).
+     */
+    uint32_t format;
+    /**
+     * Number of planes in the layer.
+     *
+     * This must match the number of planes required by format.
+     */
+    int nb_planes;
+    /**
+     * Array of planes in this layer.
+     */
+    AVDRMPlaneDescriptor planes[AV_DRM_MAX_PLANES];
+} AVDRMLayerDescriptor;
+
+/**
+ * DRM frame descriptor.
+ *
+ * This is used as the data pointer for AV_PIX_FMT_DRM_PRIME frames.
+ * It is also used by user-allocated frame pools - allocating in
+ * AVHWFramesContext.pool must return AVBufferRefs which contain
+ * an object of this type.
+ *
+ * The fields of this structure should be set such it can be
+ * imported directly by EGL using the EGL_EXT_image_dma_buf_import
+ * and EGL_EXT_image_dma_buf_import_modifiers extensions.
+ * (Note that the exact layout of a particular format may vary between
+ * platforms - we only specify that the same platform should be able
+ * to import it.)
+ *
+ * The total number of planes must not exceed AV_DRM_MAX_PLANES, and
+ * the order of the planes by increasing layer index followed by
+ * increasing plane index must be the same as the order which would
+ * be used for the data pointers in the equivalent software format.
+ */
+typedef struct AVDRMFrameDescriptor {
+    /**
+     * Number of DRM objects making up this frame.
+     */
+    int nb_objects;
+    /**
+     * Array of objects making up the frame.
+     */
+    AVDRMObjectDescriptor objects[AV_DRM_MAX_PLANES];
+    /**
+     * Number of layers in the frame.
+     */
+    int nb_layers;
+    /**
+     * Array of layers in the frame.
+     */
+    AVDRMLayerDescriptor layers[AV_DRM_MAX_PLANES];
+} AVDRMFrameDescriptor;
+
+/**
+ * DRM device.
+ *
+ * Allocated as AVHWDeviceContext.hwctx.
+ */
+typedef struct AVDRMDeviceContext {
+    /**
+     * File descriptor of DRM device.
+     *
+     * This is used as the device to create frames on, and may also be
+     * used in some derivation and mapping operations.
+     *
+     * If no device is required, set to -1.
+     */
+    int fd;
+} AVDRMDeviceContext;
+
+#endif /* AVUTIL_HWCONTEXT_DRM_H */
+`
 
 API-specific header for AV\\_HWDEVICE\\_TYPE\\_DRM.
 
 Internal frame allocation is not currently supported - all frames must be allocated by the user. Thus [`AVHWFramesContext`](@ref) is always NULL, though this may change if support for frame allocation is added in future.
 """
-const __JL_Ctag_781 = UInt32
+const __JL_Ctag_699 = UInt32
 const AV_DRM_MAX_PLANES = 4 % UInt32
 
 """
@@ -14849,6 +15389,8 @@ Allocated as [`AVHWDeviceContext`](@ref).hwctx
 """
 struct AVMediaCodecDeviceContext
     surface::Ptr{Cvoid}
+    native_window::Ptr{Cvoid}
+    create_window::Cint
 end
 
 struct AVOpenCLFrameDescriptor
@@ -14868,6 +15410,7 @@ end
 
 struct AVQSVDeviceContext
     session::Cint
+    loader::Ptr{Cvoid}
 end
 
 struct AVQSVFramesContext
@@ -14877,7 +15420,102 @@ struct AVQSVFramesContext
 end
 
 """
-    __JL_Ctag_805
+    __JL_Ctag_723
+
+`
+ * API-specific header for AV_HWDEVICE_TYPE_VAAPI.
+ *
+ * Dynamic frame pools are supported, but note that any pool used as a render
+ * target is required to be of fixed size in order to be be usable as an
+ * argument to vaCreateContext().
+ *
+ * For user-allocated pools, AVHWFramesContext.pool must return AVBufferRefs
+ * with the data pointer set to a VASurfaceID.
+ */
+
+enum {
+    /**
+     * The quirks field has been set by the user and should not be detected
+     * automatically by av_hwdevice_ctx_init().
+     */
+    AV_VAAPI_DRIVER_QUIRK_USER_SET = (1 << 0),
+    /**
+     * The driver does not destroy parameter buffers when they are used by
+     * vaRenderPicture().  Additional code will be required to destroy them
+     * separately afterwards.
+     */
+    AV_VAAPI_DRIVER_QUIRK_RENDER_PARAM_BUFFERS = (1 << 1),
+
+    /**
+     * The driver does not support the VASurfaceAttribMemoryType attribute,
+     * so the surface allocation code will not try to use it.
+     */
+    AV_VAAPI_DRIVER_QUIRK_ATTRIB_MEMTYPE = (1 << 2),
+
+    /**
+     * The driver does not support surface attributes at all.
+     * The surface allocation code will never pass them to surface allocation,
+     * and the results of the vaQuerySurfaceAttributes() call will be faked.
+     */
+    AV_VAAPI_DRIVER_QUIRK_SURFACE_ATTRIBUTES = (1 << 3),
+};
+
+/**
+ * VAAPI connection details.
+ *
+ * Allocated as AVHWDeviceContext.hwctx
+ */
+typedef struct AVVAAPIDeviceContext {
+    /**
+     * The VADisplay handle, to be filled by the user.
+     */
+    VADisplay display;
+    /**
+     * Driver quirks to apply - this is filled by av_hwdevice_ctx_init(),
+     * with reference to a table of known drivers, unless the
+     * AV_VAAPI_DRIVER_QUIRK_USER_SET bit is already present.  The user
+     * may need to refer to this field when performing any later
+     * operations using VAAPI with the same VADisplay.
+     */
+    unsigned int driver_quirks;
+} AVVAAPIDeviceContext;
+
+/**
+ * VAAPI-specific data associated with a frame pool.
+ *
+ * Allocated as AVHWFramesContext.hwctx.
+ */
+typedef struct AVVAAPIFramesContext {
+    /**
+     * Set by the user to apply surface attributes to all surfaces in
+     * the frame pool.  If null, default settings are used.
+     */
+    VASurfaceAttrib *attributes;
+    int           nb_attributes;
+    /**
+     * The surfaces IDs of all surfaces in the pool after creation.
+     * Only valid if AVHWFramesContext.initial_pool_size was positive.
+     * These are intended to be used as the render_targets arguments to
+     * vaCreateContext().
+     */
+    VASurfaceID     *surface_ids;
+    int           nb_surfaces;
+} AVVAAPIFramesContext;
+
+/**
+ * VAAPI hardware pipeline configuration details.
+ *
+ * Allocated with av_hwdevice_hwconfig_alloc().
+ */
+typedef struct AVVAAPIHWConfig {
+    /**
+     * ID of a VAAPI pipeline configuration.
+     */
+    VAConfigID config_id;
+} AVVAAPIHWConfig;
+
+#endif /* AVUTIL_HWCONTEXT_VAAPI_H */
+`
 
 API-specific header for AV\\_HWDEVICE\\_TYPE\\_VAAPI.
 
@@ -14885,7 +15523,7 @@ Dynamic frame pools are supported, but note that any pool used as a render targe
 
 For user-allocated pools, [`AVHWFramesContext`](@ref).pool must return AVBufferRefs with the data pointer set to a VASurfaceID.
 """
-const __JL_Ctag_805 = UInt32
+const __JL_Ctag_723 = UInt32
 const AV_VAAPI_DRIVER_QUIRK_USER_SET = 1 % UInt32
 const AV_VAAPI_DRIVER_QUIRK_RENDER_PARAM_BUFFERS = 2 % UInt32
 const AV_VAAPI_DRIVER_QUIRK_ATTRIB_MEMTYPE = 4 % UInt32
@@ -14914,7 +15552,7 @@ This struct is allocated as [`AVHWDeviceContext`](@ref).hwctx
 """
 struct AVVDPAUDeviceContext
     device::VdpDevice
-    get_proc_address::Ptr{Cvoid}
+    get_proc_address::Ptr{VdpGetProcAddress}
 end
 
 """
@@ -14939,6 +15577,43 @@ function av_map_videotoolbox_format_from_pixfmt2(pix_fmt::AVPixelFormat, full_ra
     ccall((:av_map_videotoolbox_format_from_pixfmt2, libavutil), UInt32, (AVPixelFormat, Cint), pix_fmt, full_range)
 end
 
+function av_map_videotoolbox_chroma_loc_from_av(loc::AVChromaLocation)
+    ccall((:av_map_videotoolbox_chroma_loc_from_av, libavutil), Cint, (AVChromaLocation,), loc)
+end
+
+function av_map_videotoolbox_color_matrix_from_av(space::AVColorSpace)
+    ccall((:av_map_videotoolbox_color_matrix_from_av, libavutil), Cint, (AVColorSpace,), space)
+end
+
+function av_map_videotoolbox_color_primaries_from_av(pri::AVColorPrimaries)
+    ccall((:av_map_videotoolbox_color_primaries_from_av, libavutil), Cint, (AVColorPrimaries,), pri)
+end
+
+function av_map_videotoolbox_color_trc_from_av(trc::AVColorTransferCharacteristic)
+    ccall((:av_map_videotoolbox_color_trc_from_av, libavutil), Cint, (AVColorTransferCharacteristic,), trc)
+end
+
+function av_vt_pixbuf_set_attachments(log_ctx, pixbuf::Integer, src)
+    ccall((:av_vt_pixbuf_set_attachments, libavutil), Cint, (Ptr{Cvoid}, Cint, Ptr{AVFrame}), log_ctx, pixbuf, src)
+end
+
+mutable struct AVVkFrameInternal end
+
+struct AVVkFrame
+    img::NTuple{8, VkImage}
+    tiling::VkImageTiling
+    mem::NTuple{8, VkDeviceMemory}
+    size::NTuple{8, Csize_t}
+    flags::VkMemoryPropertyFlagBits
+    access::NTuple{8, VkAccessFlagBits}
+    layout::NTuple{8, VkImageLayout}
+    sem::NTuple{8, VkSemaphore}
+    sem_value::NTuple{8, UInt64}
+    internal::Ptr{AVVkFrameInternal}
+    offset::NTuple{8, Cptrdiff_t}
+    queue_family::NTuple{8, UInt32}
+end
+
 """
     AVVulkanDeviceContext
 
@@ -14946,22 +15621,39 @@ Main Vulkan context, allocated as [`AVHWDeviceContext`](@ref).hwctx. All of thes
 """
 struct AVVulkanDeviceContext
     alloc::Ptr{VkAllocationCallbacks}
+    get_proc_addr::PFN_vkGetInstanceProcAddr
     inst::VkInstance
     phys_dev::VkPhysicalDevice
     act_dev::VkDevice
+    device_features::VkPhysicalDeviceFeatures2
+    enabled_inst_extensions::Ptr{Cstring}
+    nb_enabled_inst_extensions::Cint
+    enabled_dev_extensions::Ptr{Cstring}
+    nb_enabled_dev_extensions::Cint
     queue_family_index::Cint
     nb_graphics_queues::Cint
     queue_family_tx_index::Cint
     nb_tx_queues::Cint
     queue_family_comp_index::Cint
     nb_comp_queues::Cint
-    enabled_inst_extensions::Ptr{Cstring}
-    nb_enabled_inst_extensions::Cint
-    enabled_dev_extensions::Ptr{Cstring}
-    nb_enabled_dev_extensions::Cint
-    device_features::VkPhysicalDeviceFeatures2
+    queue_family_encode_index::Cint
+    nb_encode_queues::Cint
+    queue_family_decode_index::Cint
+    nb_decode_queues::Cint
+    lock_queue::Ptr{Cvoid}
+    unlock_queue::Ptr{Cvoid}
 end
 
+"""
+    AVVkFrameFlags
+
+Defines the behaviour of frame allocation.
+"""
+const AVVkFrameFlags = UInt32
+const AV_VK_FRAME_FLAG_NONE = 1 % UInt32
+const AV_VK_FRAME_FLAG_CONTIGUOUS_MEMORY = 2 % UInt32
+const AV_VK_FRAME_FLAG_DISABLE_MULTIPLANE = 4 % UInt32
+
 """
     AVVulkanFramesContext
 
@@ -14972,26 +15664,18 @@ struct AVVulkanFramesContext
     usage::VkImageUsageFlagBits
     create_pnext::Ptr{Cvoid}
     alloc_pnext::NTuple{8, Ptr{Cvoid}}
-end
-
-mutable struct AVVkFrameInternal end
-
-struct AVVkFrame
-    img::NTuple{8, VkImage}
-    tiling::VkImageTiling
-    mem::NTuple{8, VkDeviceMemory}
-    size::NTuple{8, Csize_t}
-    flags::VkMemoryPropertyFlagBits
-    access::NTuple{8, VkAccessFlagBits}
-    layout::NTuple{8, VkImageLayout}
-    sem::NTuple{8, VkSemaphore}
-    internal::Ptr{AVVkFrameInternal}
+    flags::AVVkFrameFlags
+    img_flags::VkImageCreateFlags
+    format::NTuple{8, VkFormat}
+    nb_layers::Cint
+    lock_frame::Ptr{Cvoid}
+    unlock_frame::Ptr{Cvoid}
 end
 
 """
     av_vk_frame_alloc()
 
-Allocates a single [`AVVkFrame`](@ref) and initializes everything as 0. 
+Allocates a single [`AVVkFrame`](@ref) and initializes everything as 0.
 
 !!! note
 
@@ -15004,37 +15688,18 @@ end
 """
     av_vkfmt_from_pixfmt(p::AVPixelFormat)
 
-Returns the format of each image up to the number of planes for a given sw\\_format. Returns NULL on unsupported formats.
+Returns the optimal per-plane Vulkan format for a given sw\\_format, one for each plane. Returns NULL on unsupported formats.
 """
 function av_vkfmt_from_pixfmt(p::AVPixelFormat)
     ccall((:av_vkfmt_from_pixfmt, libavutil), Ptr{VkFormat}, (AVPixelFormat,), p)
 end
 
 struct AVComponentDescriptor
-    data::NTuple{32, UInt8}
-end
-
-function Base.getproperty(x::Ptr{AVComponentDescriptor}, f::Symbol)
-    f === :plane && return Ptr{Cint}(x + 0)
-    f === :step && return Ptr{Cint}(x + 4)
-    f === :offset && return Ptr{Cint}(x + 8)
-    f === :shift && return Ptr{Cint}(x + 12)
-    f === :depth && return Ptr{Cint}(x + 16)
-    f === :step_minus1 && return Ptr{Cint}(x + 20)
-    f === :depth_minus1 && return Ptr{Cint}(x + 24)
-    f === :offset_plus1 && return Ptr{Cint}(x + 28)
-    return getfield(x, f)
-end
-
-function Base.getproperty(x::AVComponentDescriptor, f::Symbol)
-    r = Ref{AVComponentDescriptor}(x)
-    ptr = Base.unsafe_convert(Ptr{AVComponentDescriptor}, r)
-    fptr = getproperty(ptr, f)
-    GC.@preserve r unsafe_load(fptr)
-end
-
-function Base.setproperty!(x::Ptr{AVComponentDescriptor}, f::Symbol, v)
-    unsafe_store!(getproperty(x, f), v)
+    plane::Cint
+    step::Cint
+    offset::Cint
+    shift::Cint
+    depth::Cint
 end
 
 """
@@ -15064,9 +15729,9 @@ Compute the max pixel step for each plane of an image with a format described by
 The pixel step is the distance in bytes between the first byte of the group of bytes which describe a pixel component and the first byte of the successive group in the same plane for the same component.
 
 ### Parameters
-* `max_pixsteps`: an array which is filled with the max pixel step for each plane. Since a plane may contain different pixel components, the computed max\\_pixsteps[plane] is relative to the component in the plane with the max pixel step. 
-
+* `max_pixsteps`: an array which is filled with the max pixel step for each plane. Since a plane may contain different pixel components, the computed max\\_pixsteps[plane] is relative to the component in the plane with the max pixel step.
 * `max_pixstep_comps`: an array which is filled with the component for each plane which has the max pixel step. May be NULL.
+* `pixdesc`: the [`AVPixFmtDescriptor`](@ref) for the image, describing its format
 """
 function av_image_fill_max_pixsteps(max_pixsteps, max_pixstep_comps, pixdesc)
     ccall((:av_image_fill_max_pixsteps, libavutil), Cvoid, (Ptr{Cint}, Ptr{Cint}, Ptr{AVPixFmtDescriptor}), max_pixsteps, max_pixstep_comps, pixdesc)
@@ -15090,8 +15755,9 @@ end
 Fill plane linesizes for an image with pixel format pix\\_fmt and width width.
 
 ### Parameters
-* `linesizes`: array to be filled with the linesize for each plane 
-
+* `linesizes`: array to be filled with the linesize for each plane
+* `pix_fmt`: the [`AVPixelFormat`](@ref) of the image
+* `width`: width of the image in pixels
 ### Returns
 >= 0 in case of success, a negative error code otherwise
 """
@@ -15109,10 +15775,10 @@ Fill plane sizes for an image with pixel format pix\\_fmt and height height.
     The linesize parameters have the type ptrdiff\\_t here, while they are int for [`av_image_fill_linesizes`](@ref)().
 
 ### Parameters
-* `size`: the array to be filled with the size of each image plane 
-
-* `linesizes`: the array containing the linesize for each plane, should be filled by [`av_image_fill_linesizes`](@ref)() 
-
+* `size`: the array to be filled with the size of each image plane
+* `pix_fmt`: the [`AVPixelFormat`](@ref) of the image
+* `height`: height of the image in pixels
+* `linesizes`: the array containing the linesize for each plane, should be filled by [`av_image_fill_linesizes`](@ref)()
 ### Returns
 >= 0 in case of success, a negative error code otherwise
 """
@@ -15126,12 +15792,11 @@ end
 Fill plane data pointers for an image with pixel format pix\\_fmt and height height.
 
 ### Parameters
-* `data`: pointers array to be filled with the pointer for each image plane 
-
-* `ptr`: the pointer to a buffer which will contain the image 
-
-* `linesizes`: the array containing the linesize for each plane, should be filled by [`av_image_fill_linesizes`](@ref)() 
-
+* `data`: pointers array to be filled with the pointer for each image plane
+* `pix_fmt`: the [`AVPixelFormat`](@ref) of the image
+* `height`: height of the image in pixels
+* `ptr`: the pointer to a buffer which will contain the image
+* `linesizes`: the array containing the linesize for each plane, should be filled by [`av_image_fill_linesizes`](@ref)()
 ### Returns
 the size in bytes required for the image buffer, a negative error code in case of failure
 """
@@ -15145,8 +15810,12 @@ end
 Allocate an image with size w and h and pixel format pix\\_fmt, and fill pointers and linesizes accordingly. The allocated image buffer has to be freed by using [`av_freep`](@ref)(&pointers[0]).
 
 ### Parameters
-* `align`: the value to use for buffer size alignment 
-
+* `pointers`: array to be filled with the pointer for each image plane
+* `linesizes`: the array filled with the linesize for each plane
+* `w`: width of the image in pixels
+* `h`: height of the image in pixels
+* `pix_fmt`: the [`AVPixelFormat`](@ref) of the image
+* `align`: the value to use for buffer size alignment
 ### Returns
 the size in bytes required for the image buffer, a negative error code in case of failure
 """
@@ -15162,28 +15831,65 @@ Copy image plane from src to dst. That is, copy "height" number of lines of "byt
 bytewidth must be contained by both absolute values of dst\\_linesize and src\\_linesize, otherwise the function behavior is undefined.
 
 ### Parameters
-* `dst_linesize`: linesize for the image plane in dst 
-
+* `dst`: destination plane to copy to
+* `dst_linesize`: linesize for the image plane in dst
+* `src`: source plane to copy from
 * `src_linesize`: linesize for the image plane in src
+* `height`: height (number of lines) of the plane
 """
 function av_image_copy_plane(dst, dst_linesize::Integer, src, src_linesize::Integer, bytewidth::Integer, height::Integer)
     ccall((:av_image_copy_plane, libavutil), Cvoid, (Ptr{UInt8}, Cint, Ptr{UInt8}, Cint, Cint, Cint), dst, dst_linesize, src, src_linesize, bytewidth, height)
 end
 
+"""
+    av_image_copy_plane_uc_from(dst, dst_linesize::Cptrdiff_t, src, src_linesize::Cptrdiff_t, bytewidth::Cptrdiff_t, height::Integer)
+
+Copy image data located in uncacheable (e.g. GPU mapped) memory. Where available, this function will use special functionality for reading from such memory, which may result in greatly improved performance compared to plain [`av_image_copy_plane`](@ref)().
+
+bytewidth must be contained by both absolute values of dst\\_linesize and src\\_linesize, otherwise the function behavior is undefined.
+
+!!! note
+
+    The linesize parameters have the type ptrdiff\\_t here, while they are int for [`av_image_copy_plane`](@ref)().
+
+!!! note
+
+    On x86, the linesizes currently need to be aligned to the cacheline size (i.e. 64) to get improved performance.
+"""
+function av_image_copy_plane_uc_from(dst, dst_linesize::Cptrdiff_t, src, src_linesize::Cptrdiff_t, bytewidth::Cptrdiff_t, height::Integer)
+    ccall((:av_image_copy_plane_uc_from, libavutil), Cvoid, (Ptr{UInt8}, Cptrdiff_t, Ptr{UInt8}, Cptrdiff_t, Cptrdiff_t, Cint), dst, dst_linesize, src, src_linesize, bytewidth, height)
+end
+
 """
     av_image_copy(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
 
 Copy image in src\\_data to dst\\_data.
 
 ### Parameters
-* `dst_linesizes`: linesizes for the image in dst\\_data 
-
+* `dst_data`: destination image data buffer to copy to
+* `dst_linesizes`: linesizes for the image in dst\\_data
+* `src_data`: source image data buffer to copy from
 * `src_linesizes`: linesizes for the image in src\\_data
+* `pix_fmt`: the [`AVPixelFormat`](@ref) of the image
+* `width`: width of the image in pixels
+* `height`: height of the image in pixels
 """
 function av_image_copy(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
     ccall((:av_image_copy, libavutil), Cvoid, (Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{Ptr{UInt8}}, Ptr{Cint}, AVPixelFormat, Cint, Cint), dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height)
 end
 
+"""
+    av_image_copy2(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
+
+Wrapper around [`av_image_copy`](@ref)() to workaround the limitation that the conversion from uint8\\_t * const * to const uint8\\_t * const * is not performed automatically in C.
+
+### See also
+[`av_image_copy`](@ref)()
+"""
+function av_image_copy2(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
+    ccall((:av_image_copy2, libavutil), Cvoid, (Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{Ptr{UInt8}}, Ptr{Cint}, AVPixelFormat, Cint, Cint), dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height)
+end
+
 """
     av_image_copy_uc_from(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
 
@@ -15193,7 +15899,7 @@ The data pointers and the linesizes must be aligned to the maximum required by t
 
 !!! note
 
-    The linesize parameters have the type ptrdiff\\_t here, while they are int for [`av_image_copy`](@ref)(). 
+    The linesize parameters have the type ptrdiff\\_t here, while they are int for [`av_image_copy`](@ref)().
 
 !!! note
 
@@ -15213,20 +15919,13 @@ The fields of the given image are filled in by using the src address which point
 To allocate the buffer and fill in the dst\\_data and dst\\_linesize in one call, use [`av_image_alloc`](@ref)().
 
 ### Parameters
-* `dst_data`: data pointers to be filled in 
-
-* `dst_linesize`: linesizes for the image in dst\\_data to be filled in 
-
-* `src`: buffer which will contain or contains the actual image data, can be NULL 
-
-* `pix_fmt`: the pixel format of the image 
-
-* `width`: the width of the image in pixels 
-
-* `height`: the height of the image in pixels 
-
-* `align`: the value used in src for linesize alignment 
-
+* `dst_data`: data pointers to be filled in
+* `dst_linesize`: linesizes for the image in dst\\_data to be filled in
+* `src`: buffer which will contain or contains the actual image data, can be NULL
+* `pix_fmt`: the pixel format of the image
+* `width`: the width of the image in pixels
+* `height`: the height of the image in pixels
+* `align`: the value used in src for linesize alignment
 ### Returns
 the size in bytes required for src, a negative error code in case of failure
 """
@@ -15240,14 +15939,10 @@ end
 Return the size in bytes of the amount of data required to store an image with the given parameters.
 
 ### Parameters
-* `pix_fmt`: the pixel format of the image 
-
-* `width`: the width of the image in pixels 
-
-* `height`: the height of the image in pixels 
-
-* `align`: the assumed linesize alignment 
-
+* `pix_fmt`: the pixel format of the image
+* `width`: the width of the image in pixels
+* `height`: the height of the image in pixels
+* `align`: the assumed linesize alignment
 ### Returns
 the buffer size in bytes, a negative error code in case of failure
 """
@@ -15263,22 +15958,14 @@ Copy image data from an image into a buffer.
 [`av_image_get_buffer_size`](@ref)() can be used to compute the required size for the buffer to fill.
 
 ### Parameters
-* `dst`: a buffer into which picture data will be copied 
-
-* `dst_size`: the size in bytes of dst 
-
-* `src_data`: pointers containing the source image data 
-
-* `src_linesize`: linesizes for the image in src\\_data 
-
-* `pix_fmt`: the pixel format of the source image 
-
-* `width`: the width of the source image in pixels 
-
-* `height`: the height of the source image in pixels 
-
-* `align`: the assumed linesize alignment for dst 
-
+* `dst`: a buffer into which picture data will be copied
+* `dst_size`: the size in bytes of dst
+* `src_data`: pointers containing the source image data
+* `src_linesize`: linesizes for the image in src\\_data
+* `pix_fmt`: the pixel format of the source image
+* `width`: the width of the source image in pixels
+* `height`: the height of the source image in pixels
+* `align`: the assumed linesize alignment for dst
 ### Returns
 the number of bytes written to dst, or a negative value (error code) on error
 """
@@ -15292,14 +15979,10 @@ end
 Check if the given dimension of an image is valid, meaning that all bytes of the image can be addressed with a signed int.
 
 ### Parameters
-* `w`: the width of the picture 
-
-* `h`: the height of the picture 
-
-* `log_offset`: the offset to sum to the log level for logging with log\\_ctx 
-
-* `log_ctx`: the parent logging context, it may be NULL 
-
+* `w`: the width of the picture
+* `h`: the height of the picture
+* `log_offset`: the offset to sum to the log level for logging with log\\_ctx
+* `log_ctx`: the parent logging context, it may be NULL
 ### Returns
 >= 0 if valid, a negative error code otherwise
 """
@@ -15313,18 +15996,12 @@ end
 Check if the given dimension of an image is valid, meaning that all bytes of a plane of an image with the specified pix\\_fmt can be addressed with a signed int.
 
 ### Parameters
-* `w`: the width of the picture 
-
-* `h`: the height of the picture 
-
-* `max_pixels`: the maximum number of pixels the user wants to accept 
-
-* `pix_fmt`: the pixel format, can be AV\\_PIX\\_FMT\\_NONE if unknown. 
-
-* `log_offset`: the offset to sum to the log level for logging with log\\_ctx 
-
-* `log_ctx`: the parent logging context, it may be NULL 
-
+* `w`: the width of the picture
+* `h`: the height of the picture
+* `max_pixels`: the maximum number of pixels the user wants to accept
+* `pix_fmt`: the pixel format, can be AV\\_PIX\\_FMT\\_NONE if unknown.
+* `log_offset`: the offset to sum to the log level for logging with log\\_ctx
+* `log_ctx`: the parent logging context, it may be NULL
 ### Returns
 >= 0 if valid, a negative error code otherwise
 """
@@ -15340,12 +16017,9 @@ Check if the given sample aspect ratio of an image is valid.
 It is considered invalid if the denominator is 0 or if applying the ratio to the image size would make the smaller dimension less than 1. If the sar numerator is 0, it is considered unknown and will return as valid.
 
 ### Parameters
-* `w`: width of the image 
-
-* `h`: height of the image 
-
-* `sar`: sample aspect ratio of the image 
-
+* `w`: width of the image
+* `h`: height of the image
+* `sar`: sample aspect ratio of the image
 ### Returns
 0 if valid, a negative [`AVERROR`](@ref) code otherwise
 """
@@ -15365,18 +16039,12 @@ This can return an error if the pixel format is not supported. Normally, all non
 Passing NULL for dst\\_data is allowed. Then the function returns whether the operation would have succeeded. (It can return an error if the pix\\_fmt is not supported.)
 
 ### Parameters
-* `dst_data`: data pointers to destination image 
-
-* `dst_linesize`: linesizes for the destination image 
-
-* `pix_fmt`: the pixel format of the image 
-
-* `range`: the color range of the image (important for colorspaces such as YUV) 
-
-* `width`: the width of the image in pixels 
-
-* `height`: the height of the image in pixels 
-
+* `dst_data`: data pointers to destination image
+* `dst_linesize`: linesizes for the destination image
+* `pix_fmt`: the pixel format of the image
+* `range`: the color range of the image (important for colorspaces such as YUV)
+* `width`: the width of the image in pixels
+* `height`: the height of the image in pixels
 ### Returns
 0 if the image data was cleared, a negative [`AVERROR`](@ref) code otherwise
 """
@@ -15594,7 +16262,7 @@ end
 """
     AVLFG
 
-Context structure for the Lagged Fibonacci PRNG. The exact layout, types and content of this struct may change and should not be accessed directly. Only its sizeof() is guranteed to stay the same to allow easy instanciation.
+Context structure for the Lagged Fibonacci PRNG. The exact layout, types and content of this struct may change and should not be accessed directly. Only its `sizeof()` is guaranteed to stay the same to allow easy instanciation.
 """
 struct AVLFG
     state::NTuple{64, Cuint}
@@ -15610,7 +16278,8 @@ end
 
 Seed the state of the ALFG using binary data.
 
-Return value: 0 on success, negative value ([`AVERROR`](@ref)) on failure.
+### Returns
+0 on success, negative value ([`AVERROR`](@ref)) on failure.
 """
 function av_lfg_init_from_data(c, data, length::Integer)
     ccall((:av_lfg_init_from_data, libavutil), Cint, (Ptr{AVLFG}, Ptr{UInt8}, Cuint), c, data, length)
@@ -15644,6 +16313,7 @@ end
 Get the next two numbers generated by a Box-Muller Gaussian generator using the random numbers issued by lfg.
 
 ### Parameters
+* `lfg`: pointer to the contex structure
 * `out`: array where the two generated numbers are placed
 """
 function av_bmg_get(lfg, out)
@@ -15657,7 +16327,6 @@ Get the current log level
 
 ### Returns
 Current log level
-
 ### See also
 lavu\\_log\\_constants
 """
@@ -15672,7 +16341,6 @@ Set the log level
 
 ### Parameters
 * `level`: Logging level
-
 ### See also
 lavu\\_log\\_constants
 """
@@ -15691,7 +16359,6 @@ Set the logging callback
 
 ### Parameters
 * `callback`: A logging function with a compatible signature.
-
 ### See also
 [`av_log_default_callback`](@ref)
 """
@@ -15706,7 +16373,6 @@ Return the context name
 
 ### Parameters
 * `ctx`: The [`AVClass`](@ref) context
-
 ### Returns
 The [`AVClass`](@ref) class\\_name
 """
@@ -15729,19 +16395,15 @@ end
 """
     av_lzo1x_decode(out, outlen, in, inlen)
 
-Decodes LZO 1x compressed data. 
+Decodes LZO 1x compressed data.
 
 Make sure all buffers are appropriately padded, in must provide [`AV_LZO_INPUT_PADDING`](@ref), out must provide [`AV_LZO_OUTPUT_PADDING`](@ref) additional bytes.
 
 ### Parameters
-* `out`: output buffer 
-
-* `outlen`: size of output buffer, number of bytes left are returned here 
-
-* `in`: input buffer 
-
-* `inlen`: size of input buffer, number of bytes left are returned here 
-
+* `out`: output buffer
+* `outlen`: size of output buffer, number of bytes left are returned here
+* `in`: input buffer
+* `inlen`: size of input buffer, number of bytes left are returned here
 ### Returns
 0 on success, otherwise a combination of the error flags above
 """
@@ -15788,7 +16450,6 @@ Allocate a complete [`AVMasteringDisplayMetadata`](@ref) and add it to the frame
 
 ### Parameters
 * `frame`: The frame which side data is added to.
-
 ### Returns
 The [`AVMasteringDisplayMetadata`](@ref) structure to be filled by caller.
 """
@@ -15831,7 +16492,6 @@ Allocate a complete [`AVContentLightMetadata`](@ref) and add it to the frame.
 
 ### Parameters
 * `frame`: The frame which side data is added to.
-
 ### Returns
 The [`AVContentLightMetadata`](@ref) structure to be filled by caller.
 """
@@ -15858,8 +16518,8 @@ const AV_ROUND_PASS_MINMAX = 8192 % UInt32
 Compute the greatest common divisor of two integer operands.
 
 ### Parameters
-* `a,b`: Operands 
-
+* `a`: Operand
+* `b`: Operand
 ### Returns
 GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0; if a == 0 and b == 0, returns 0.
 """
@@ -15888,7 +16548,7 @@ end
 
 Rescale a 64-bit integer with specified rounding.
 
-The operation is mathematically equivalent to `a * b / c`, but writing that directly can overflow, and does not support different rounding methods.
+The operation is mathematically equivalent to `a * b / c`, but writing that directly can overflow, and does not support different rounding methods. If the result is not representable then INT64\\_MIN is returned.
 
 ### See also
 [`av_rescale`](@ref)(), [`av_rescale_q`](@ref)(), [`av_rescale_q_rnd`](@ref)()
@@ -15957,10 +16617,9 @@ In other words, compare the least significant `log2(mod)` bits of integers `a` a
 ```
 
 ### Parameters
-* `a,b`: Operands 
-
-* `mod`: Divisor; must be a power of 2 
-
+* `a`: Operand
+* `b`: Operand
+* `mod`: Divisor; must be a power of 2
 ### Returns
 - a negative value if `a % mod < b % mod` - a positive value if `a % mod > b % mod` - zero if `a % mod == b % mod`
 """
@@ -15982,18 +16641,12 @@ The `last` parameter is a state variable that must be preserved for all subseque
     In the context of this function, "duration" is in term of samples, not seconds.
 
 ### Parameters
-* `in_tb`:\\[in\\] Input time base 
-
-* `in_ts`:\\[in\\] Input timestamp 
-
-* `fs_tb`:\\[in\\] Duration time base; typically this is finer-grained (greater) than `in_tb` and `out_tb` 
-
-* `duration`:\\[in\\] Duration till the next call to this function (i.e. duration of the current packet/frame) 
-
-* `last`:\\[in,out\\] Pointer to a timestamp expressed in terms of `fs_tb`, acting as a state variable 
-
-* `out_tb`:\\[in\\] Output timebase 
-
+* `in_tb`:\\[in\\] Input time base
+* `in_ts`:\\[in\\] Input timestamp
+* `fs_tb`:\\[in\\] Duration time base; typically this is finer-grained (greater) than `in_tb` and `out_tb`
+* `duration`:\\[in\\] Duration till the next call to this function (i.e. duration of the current packet/frame)
+* `last`:\\[in,out\\] Pointer to a timestamp expressed in terms of `fs_tb`, acting as a state variable
+* `out_tb`:\\[in\\] Output timebase
 ### Returns
 Timestamp expressed in terms of `out_tb`
 """
@@ -16009,18 +16662,24 @@ Add a value to a timestamp.
 This function guarantees that when the same value is repeatly added that no accumulation of rounding errors occurs.
 
 ### Parameters
-* `ts`:\\[in\\] Input timestamp 
-
-* `ts_tb`:\\[in\\] Input timestamp time base 
-
-* `inc`:\\[in\\] Value to be added 
-
+* `ts`:\\[in\\] Input timestamp
+* `ts_tb`:\\[in\\] Input timestamp time base
+* `inc`:\\[in\\] Value to be added
 * `inc_tb`:\\[in\\] Time base of `inc`
 """
 function av_add_stable(ts_tb::AVRational, ts::Int64, inc_tb::AVRational, inc::Int64)
     ccall((:av_add_stable, libavutil), Int64, (AVRational, Int64, AVRational, Int64), ts_tb, ts, inc_tb, inc)
 end
 
+"""
+    av_bessel_i0(x::Cdouble)
+
+0th order modified bessel function of the first kind.
+"""
+function av_bessel_i0(x::Cdouble)
+    ccall((:av_bessel_i0, libavutil), Cdouble, (Cdouble,), x)
+end
+
 mutable struct AVMD5 end
 
 """
@@ -16044,8 +16703,18 @@ function av_md5_init(ctx)
     ccall((:av_md5_init, libavutil), Cvoid, (Ptr{AVMD5},), ctx)
 end
 
-function av_md5_update(ctx, src, len::Integer)
-    ccall((:av_md5_update, libavutil), Cvoid, (Ptr{AVMD5}, Ptr{UInt8}, Cint), ctx, src, len)
+"""
+    av_md5_update(ctx, src, len::Csize_t)
+
+Update hash value.
+
+### Parameters
+* `ctx`: hash function context
+* `src`: input data to update hash with
+* `len`: input data length
+"""
+function av_md5_update(ctx, src, len::Csize_t)
+    ccall((:av_md5_update, libavutil), Cvoid, (Ptr{AVMD5}, Ptr{UInt8}, Csize_t), ctx, src, len)
 end
 
 """
@@ -16054,16 +16723,25 @@ end
 Finish hashing and output digest value.
 
 ### Parameters
-* `ctx`: hash function context 
-
+* `ctx`: hash function context
 * `dst`: buffer where output digest value is stored
 """
 function av_md5_final(ctx, dst)
     ccall((:av_md5_final, libavutil), Cvoid, (Ptr{AVMD5}, Ptr{UInt8}), ctx, dst)
 end
 
-function av_md5_sum(dst, src, len::Integer)
-    ccall((:av_md5_sum, libavutil), Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Cint), dst, src, len)
+"""
+    av_md5_sum(dst, src, len::Csize_t)
+
+Hash an array of data.
+
+### Parameters
+* `dst`: The output buffer to write the digest into
+* `src`: The data to hash
+* `len`: The length of the data, in bytes
+"""
+function av_md5_sum(dst, src, len::Csize_t)
+    ccall((:av_md5_sum, libavutil), Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Csize_t), dst, src, len)
 end
 
 """
@@ -16072,11 +16750,9 @@ end
 Allocate a memory block with alignment suitable for all memory accesses (including vectors if available on the CPU).
 
 ### Parameters
-* `size`: Size in bytes for the memory block to be allocated 
-
+* `size`: Size in bytes for the memory block to be allocated
 ### Returns
-Pointer to the allocated block, or `NULL` if the block cannot be allocated 
-
+Pointer to the allocated block, or `NULL` if the block cannot be allocated
 ### See also
 [`av_mallocz`](@ref)()
 """
@@ -16090,11 +16766,9 @@ end
 Allocate a memory block with alignment suitable for all memory accesses (including vectors if available on the CPU) and zero all the bytes of the block.
 
 ### Parameters
-* `size`: Size in bytes for the memory block to be allocated 
-
+* `size`: Size in bytes for the memory block to be allocated
 ### Returns
-Pointer to the allocated block, or `NULL` if it cannot be allocated 
-
+Pointer to the allocated block, or `NULL` if it cannot be allocated
 ### See also
 [`av_malloc`](@ref)()
 """
@@ -16110,13 +16784,10 @@ Allocate a memory block for an array with [`av_malloc`](@ref)().
 The allocated memory will have size `size * nmemb` bytes.
 
 ### Parameters
-* `nmemb`: Number of element 
-
-* `size`: Size of a single element 
-
+* `nmemb`: Number of element
+* `size`: Size of a single element
 ### Returns
-Pointer to the allocated block, or `NULL` if the block cannot be allocated 
-
+Pointer to the allocated block, or `NULL` if the block cannot be allocated
 ### See also
 [`av_malloc`](@ref)()
 """
@@ -16125,34 +16796,20 @@ function av_malloc_array(nmemb::Csize_t, size::Csize_t)
 end
 
 """
-    av_mallocz_array(nmemb::Csize_t, size::Csize_t)
+    av_calloc(nmemb::Csize_t, size::Csize_t)
 
 Allocate a memory block for an array with [`av_mallocz`](@ref)().
 
 The allocated memory will have size `size * nmemb` bytes.
 
 ### Parameters
-* `nmemb`: Number of elements 
-
-* `size`: Size of the single element 
-
+* `nmemb`: Number of elements
+* `size`: Size of the single element
 ### Returns
 Pointer to the allocated block, or `NULL` if the block cannot be allocated
-
 ### See also
 [`av_mallocz`](@ref)(), [`av_malloc_array`](@ref)()
 """
-function av_mallocz_array(nmemb::Csize_t, size::Csize_t)
-    ccall((:av_mallocz_array, libavutil), Ptr{Cvoid}, (Csize_t, Csize_t), nmemb, size)
-end
-
-"""
-    av_calloc(nmemb::Csize_t, size::Csize_t)
-
-Non-inlined equivalent of [`av_mallocz_array`](@ref)().
-
-Created for symmetry with the calloc() C function.
-"""
 function av_calloc(nmemb::Csize_t, size::Csize_t)
     ccall((:av_calloc, libavutil), Ptr{Cvoid}, (Csize_t, Csize_t), nmemb, size)
 end
@@ -16162,20 +16819,17 @@ end
 
 Allocate, reallocate, or free a block of memory.
 
-If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is zero, free the memory block pointed to by `ptr`. Otherwise, expand or shrink that block of memory according to `size`.
+If `ptr` is `NULL` and `size` > 0, allocate a new block. Otherwise, expand or shrink that block of memory according to `size`.
 
 !!! warning
 
-    Unlike [`av_malloc`](@ref)(), the returned pointer is not guaranteed to be correctly aligned. 
+    Unlike [`av_malloc`](@ref)(), the returned pointer is not guaranteed to be correctly aligned. The returned pointer must be freed after even if size is zero.
 
 ### Parameters
-* `ptr`: Pointer to a memory block already allocated with [`av_realloc`](@ref)() or `NULL` 
-
+* `ptr`: Pointer to a memory block already allocated with [`av_realloc`](@ref)() or `NULL`
 * `size`: Size in bytes of the memory block to be allocated or reallocated
-
 ### Returns
-Pointer to a newly-reallocated block or `NULL` if the block cannot be reallocated or the function is used to free the memory block
-
+Pointer to a newly-reallocated block or `NULL` if the block cannot be reallocated
 ### See also
 [`av_fast_realloc`](@ref)(), [`av_reallocp`](@ref)()
 """
@@ -16195,10 +16849,8 @@ If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is zero, fre
     Unlike [`av_malloc`](@ref)(), the allocated memory is not guaranteed to be correctly aligned.
 
 ### Parameters
-* `ptr`:\\[in,out\\] Pointer to a pointer to a memory block already allocated with [`av_realloc`](@ref)(), or a pointer to `NULL`. The pointer is updated on success, or freed on failure. 
-
+* `ptr`:\\[in,out\\] Pointer to a pointer to a memory block already allocated with [`av_realloc`](@ref)(), or a pointer to `NULL`. The pointer is updated on success, or freed on failure.
 * `size`:\\[in\\] Size in bytes for the memory block to be allocated or reallocated
-
 ### Returns
 Zero on success, an [`AVERROR`](@ref) error code on failure
 """
@@ -16211,7 +16863,7 @@ end
 
 Allocate, reallocate, or free a block of memory.
 
-This function does the same thing as [`av_realloc`](@ref)(), except: - It takes two size arguments and allocates `nelem * elsize` bytes, after checking the result of the multiplication for integer overflow. - It frees the input block in case of failure, thus avoiding the memory leak with the classic 
+This function does the same thing as [`av_realloc`](@ref)(), except: - It takes two size arguments and allocates `nelem * elsize` bytes, after checking the result of the multiplication for integer overflow. - It frees the input block in case of failure, thus avoiding the memory leak with the classic
 
 ```c++
 {.c}
@@ -16231,22 +16883,18 @@ end
 
 Allocate, reallocate, or free an array.
 
-If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is zero, free the memory block pointed to by `ptr`.
+If `ptr` is `NULL` and `nmemb` > 0, allocate a new block.
 
 !!! warning
 
-    Unlike [`av_malloc`](@ref)(), the allocated memory is not guaranteed to be correctly aligned. 
+    Unlike [`av_malloc`](@ref)(), the allocated memory is not guaranteed to be correctly aligned. The returned pointer must be freed after even if nmemb is zero.
 
 ### Parameters
-* `ptr`: Pointer to a memory block already allocated with [`av_realloc`](@ref)() or `NULL` 
-
-* `nmemb`: Number of elements in the array 
-
+* `ptr`: Pointer to a memory block already allocated with [`av_realloc`](@ref)() or `NULL`
+* `nmemb`: Number of elements in the array
 * `size`: Size of the single element of the array
-
 ### Returns
-Pointer to a newly-reallocated block or NULL if the block cannot be reallocated or the function is used to free the memory block
-
+Pointer to a newly-reallocated block or NULL if the block cannot be reallocated
 ### See also
 [`av_reallocp_array`](@ref)()
 """
@@ -16257,21 +16905,18 @@ end
 """
     av_reallocp_array(ptr, nmemb::Csize_t, size::Csize_t)
 
-Allocate, reallocate, or free an array through a pointer to a pointer.
+Allocate, reallocate an array through a pointer to a pointer.
 
-If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is zero, free the memory block pointed to by `*ptr`.
+If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block.
 
 !!! warning
 
-    Unlike [`av_malloc`](@ref)(), the allocated memory is not guaranteed to be correctly aligned.
+    Unlike [`av_malloc`](@ref)(), the allocated memory is not guaranteed to be correctly aligned. *ptr must be freed after even if nmemb is zero.
 
 ### Parameters
-* `ptr`:\\[in,out\\] Pointer to a pointer to a memory block already allocated with [`av_realloc`](@ref)(), or a pointer to `NULL`. The pointer is updated on success, or freed on failure. 
-
-* `nmemb`:\\[in\\] Number of elements 
-
+* `ptr`:\\[in,out\\] Pointer to a pointer to a memory block already allocated with [`av_realloc`](@ref)(), or a pointer to `NULL`. The pointer is updated on success, or freed on failure.
+* `nmemb`:\\[in\\] Number of elements
 * `size`:\\[in\\] Size of the single element
-
 ### Returns
 Zero on success, an [`AVERROR`](@ref) error code on failure
 """
@@ -16302,15 +16947,11 @@ A typical use pattern follows:
 ```
 
 ### Parameters
-* `ptr`:\\[in,out\\] Already allocated buffer, or `NULL` 
-
-* `size`:\\[in,out\\] Pointer to the size of buffer `ptr`. `*size` is updated to the new allocated size, in particular 0 in case of failure. 
-
-* `min_size`:\\[in\\] Desired minimal size of buffer `ptr` 
-
+* `ptr`:\\[in,out\\] Already allocated buffer, or `NULL`
+* `size`:\\[in,out\\] Pointer to the size of buffer `ptr`. `*size` is updated to the new allocated size, in particular 0 in case of failure.
+* `min_size`:\\[in\\] Desired minimal size of buffer `ptr`
 ### Returns
-`ptr` if the buffer is large enough, a pointer to newly reallocated buffer if the buffer was not large enough, or `NULL` in case of error 
-
+`ptr` if the buffer is large enough, a pointer to newly reallocated buffer if the buffer was not large enough, or `NULL` in case of error
 ### See also
 [`av_realloc`](@ref)(), [`av_fast_malloc`](@ref)()
 """
@@ -16338,12 +16979,9 @@ Contrary to [`av_fast_realloc`](@ref)(), the current buffer contents might not b
 ```
 
 ### Parameters
-* `ptr`:\\[in,out\\] Pointer to pointer to an already allocated buffer. `*ptr` will be overwritten with pointer to new buffer on success or `NULL` on failure 
-
-* `size`:\\[in,out\\] Pointer to the size of buffer `*ptr`. `*size` is updated to the new allocated size, in particular 0 in case of failure. 
-
-* `min_size`:\\[in\\] Desired minimal size of buffer `*ptr` 
-
+* `ptr`:\\[in,out\\] Pointer to pointer to an already allocated buffer. `*ptr` will be overwritten with pointer to new buffer on success or `NULL` on failure
+* `size`:\\[in,out\\] Pointer to the size of buffer `*ptr`. `*size` is updated to the new allocated size, in particular 0 in case of failure.
+* `min_size`:\\[in\\] Desired minimal size of buffer `*ptr`
 ### See also
 [`av_realloc`](@ref)(), [`av_fast_mallocz`](@ref)()
 """
@@ -16361,12 +16999,9 @@ Like [`av_fast_malloc`](@ref)(), but all newly allocated space is initially clea
 `*ptr` is allowed to be `NULL`, in which case allocation always happens if `size_needed` is greater than 0.
 
 ### Parameters
-* `ptr`:\\[in,out\\] Pointer to pointer to an already allocated buffer. `*ptr` will be overwritten with pointer to new buffer on success or `NULL` on failure 
-
-* `size`:\\[in,out\\] Pointer to the size of buffer `*ptr`. `*size` is updated to the new allocated size, in particular 0 in case of failure. 
-
-* `min_size`:\\[in\\] Desired minimal size of buffer `*ptr` 
-
+* `ptr`:\\[in,out\\] Pointer to pointer to an already allocated buffer. `*ptr` will be overwritten with pointer to new buffer on success or `NULL` on failure
+* `size`:\\[in,out\\] Pointer to the size of buffer `*ptr`. `*size` is updated to the new allocated size, in particular 0 in case of failure.
+* `min_size`:\\[in\\] Desired minimal size of buffer `*ptr`
 ### See also
 [`av_fast_malloc`](@ref)()
 """
@@ -16381,15 +17016,14 @@ Free a memory block which has been allocated with a function of [`av_malloc`](@r
 
 !!! note
 
-    `ptr = NULL` is explicitly allowed. 
+    `ptr = NULL` is explicitly allowed.
 
 !!! note
 
-    It is recommended that you use [`av_freep`](@ref)() instead, to prevent leaving behind dangling pointers. 
+    It is recommended that you use [`av_freep`](@ref)() instead, to prevent leaving behind dangling pointers.
 
 ### Parameters
 * `ptr`: Pointer to the memory block which should be freed.
-
 ### See also
 [`av_freep`](@ref)()
 """
@@ -16417,11 +17051,10 @@ Free a memory block which has been allocated with a function of [`av_malloc`](@r
 
 !!! note
 
-    `*ptr = NULL` is safe and leads to no action. 
+    `*ptr = NULL` is safe and leads to no action.
 
 ### Parameters
-* `ptr`: Pointer to the pointer to the memory block which should be freed 
-
+* `ptr`: Pointer to the pointer to the memory block which should be freed
 ### See also
 [`av_free`](@ref)()
 """
@@ -16435,11 +17068,9 @@ end
 Duplicate a string.
 
 ### Parameters
-* `s`: String to be duplicated 
-
+* `s`: String to be duplicated
 ### Returns
-Pointer to a newly-allocated string containing a copy of `s` or `NULL` if the string cannot be allocated 
-
+Pointer to a newly-allocated string containing a copy of `s` or `NULL` if the string cannot be allocated
 ### See also
 [`av_strndup`](@ref)()
 """
@@ -16453,10 +17084,8 @@ end
 Duplicate a substring of a string.
 
 ### Parameters
-* `s`: String to be duplicated 
-
-* `len`: Maximum length of the resulting string (not counting the terminating byte) 
-
+* `s`: String to be duplicated
+* `len`: Maximum length of the resulting string (not counting the terminating byte)
 ### Returns
 Pointer to a newly-allocated string containing a substring of `s` or `NULL` if the string cannot be allocated
 """
@@ -16470,10 +17099,8 @@ end
 Duplicate a buffer with [`av_malloc`](@ref)().
 
 ### Parameters
-* `p`: Buffer to be duplicated 
-
-* `size`: Size in bytes of the buffer copied 
-
+* `p`: Buffer to be duplicated
+* `size`: Size in bytes of the buffer copied
 ### Returns
 Pointer to a newly allocated buffer containing a copy of `p` or `NULL` if the buffer cannot be allocated
 """
@@ -16491,10 +17118,8 @@ Overlapping memcpy() implementation.
     `cnt > back` is valid, this will copy the bytes we just copied, thus creating a repeating pattern with a period length of `back`.
 
 ### Parameters
-* `dst`: Destination buffer 
-
-* `back`: Number of bytes back to start copying (i.e. the initial size of the overlapping window); must be > 0 
-
+* `dst`: Destination buffer
+* `back`: Number of bytes back to start copying (i.e. the initial size of the overlapping window); must be > 0
 * `cnt`: Number of bytes to copy; must be >= 0
 """
 function av_memcpy_backptr(dst, back::Integer, cnt::Integer)
@@ -16513,12 +17138,9 @@ The array is reallocated when its size reaches powers of 2. Therefore, the amort
 In case of success, the pointer to the array is updated in order to point to the new grown array, and the number pointed to by `nb_ptr` is incremented. In case of failure, the array is freed, `*tab\\_ptr` is set to `NULL` and `*nb\\_ptr` is set to 0.
 
 ### Parameters
-* `tab_ptr`:\\[in,out\\] Pointer to the array to grow 
-
-* `nb_ptr`:\\[in,out\\] Pointer to the number of elements in the array 
-
-* `elem`:\\[in\\] Element to add 
-
+* `tab_ptr`:\\[in,out\\] Pointer to the array to grow
+* `nb_ptr`:\\[in,out\\] Pointer to the number of elements in the array
+* `elem`:\\[in\\] Element to add
 ### See also
 [`av_dynarray_add_nofree`](@ref)(), [`av_dynarray2_add`](@ref)()
 """
@@ -16534,8 +17156,7 @@ Add an element to a dynamic array.
 Function has the same functionality as [`av_dynarray_add`](@ref)(), but it doesn't free memory on fails. It returns error code instead and leave current buffer untouched.
 
 ### Returns
->=0 on success, negative otherwise 
-
+>=0 on success, negative otherwise
 ### See also
 [`av_dynarray_add`](@ref)(), [`av_dynarray2_add`](@ref)()
 """
@@ -16553,17 +17174,12 @@ The array is reallocated when its number of elements reaches powers of 2. Theref
 In case of success, the pointer to the array is updated in order to point to the new grown array, and the number pointed to by `nb_ptr` is incremented. In case of failure, the array is freed, `*tab\\_ptr` is set to `NULL` and `*nb\\_ptr` is set to 0.
 
 ### Parameters
-* `tab_ptr`:\\[in,out\\] Pointer to the array to grow 
-
-* `nb_ptr`:\\[in,out\\] Pointer to the number of elements in the array 
-
-* `elem_size`:\\[in\\] Size in bytes of an element in the array 
-
+* `tab_ptr`:\\[in,out\\] Pointer to the array to grow
+* `nb_ptr`:\\[in,out\\] Pointer to the number of elements in the array
+* `elem_size`:\\[in\\] Size in bytes of an element in the array
 * `elem_data`:\\[in\\] Pointer to the data of the element to add. If `NULL`, the space of the newly added element is allocated but left uninitialized.
-
 ### Returns
-Pointer to the data of the element to copy in the newly allocated space 
-
+Pointer to the data of the element to copy in the newly allocated space
 ### See also
 [`av_dynarray_add`](@ref)(), [`av_dynarray_add_nofree`](@ref)()
 """
@@ -16577,10 +17193,9 @@ end
 Multiply two `size_t` values checking for overflow.
 
 ### Parameters
-* `a,b`:\\[in\\] Operands of multiplication 
-
-* `r`:\\[out\\] Pointer to the result of the operation 
-
+* `a`:\\[in\\] Operand of multiplication
+* `b`:\\[in\\] Operand of multiplication
+* `r`:\\[out\\] Pointer to the result of the operation
 ### Returns
 0 on success, [`AVERROR`](@ref)(EINVAL) on overflow
 """
@@ -16642,10 +17257,8 @@ end
 Initialize or reinitialize an [`AVMurMur3`](@ref) hash context with a seed.
 
 ### Parameters
-* `c`:\\[out\\] Hash context 
-
+* `c`:\\[out\\] Hash context
 * `seed`:\\[in\\] Random seed
-
 ### See also
 [`av_murmur3_init`](@ref)(), lavu_murmur3_seedinfo "Detailed description" on a discussion of seeds for MurmurHash3.
 """
@@ -16662,7 +17275,6 @@ Equivalent to [`av_murmur3_init_seeded`](@ref)() with a built-in seed.
 
 ### Parameters
 * `c`:\\[out\\] Hash context
-
 ### See also
 [`av_murmur3_init_seeded`](@ref)(), lavu_murmur3_seedinfo "Detailed description" on a discussion of seeds for MurmurHash3.
 """
@@ -16670,8 +17282,18 @@ function av_murmur3_init(c)
     ccall((:av_murmur3_init, libavutil), Cvoid, (Ptr{AVMurMur3},), c)
 end
 
-function av_murmur3_update(c, src, len::Integer)
-    ccall((:av_murmur3_update, libavutil), Cvoid, (Ptr{AVMurMur3}, Ptr{UInt8}, Cint), c, src, len)
+"""
+    av_murmur3_update(c, src, len::Csize_t)
+
+Update hash context with new data.
+
+### Parameters
+* `c`:\\[out\\] Hash context
+* `src`:\\[in\\] Input data to update hash with
+* `len`:\\[in\\] Number of bytes to read from `src`
+"""
+function av_murmur3_update(c, src, len::Csize_t)
+    ccall((:av_murmur3_update, libavutil), Cvoid, (Ptr{AVMurMur3}, Ptr{UInt8}, Csize_t), c, src, len)
 end
 
 """
@@ -16680,8 +17302,7 @@ end
 Finish hashing and output digest value.
 
 ### Parameters
-* `c`:\\[in,out\\] Hash context 
-
+* `c`:\\[in,out\\] Hash context
 * `dst`:\\[out\\] Buffer where output digest value is stored
 """
 function av_murmur3_final(c, dst)
@@ -16723,10 +17344,8 @@ end
 Show the obj options.
 
 ### Parameters
-* `req_flags`: requested flags for the options to show. Show only the options for which it is opt->flags & req\\_flags. 
-
-* `rej_flags`: rejected flags for the options to show. Show only the options for which it is !(opt->flags & req\\_flags). 
-
+* `req_flags`: requested flags for the options to show. Show only the options for which it is opt->flags & req\\_flags.
+* `rej_flags`: rejected flags for the options to show. Show only the options for which it is !(opt->flags & req\\_flags).
 * `av_log_obj`: log context to use for showing the options
 """
 function av_opt_show2(obj, av_log_obj, req_flags::Integer, rej_flags::Integer)
@@ -16751,10 +17370,8 @@ end
 Set the values of all [`AVOption`](@ref) fields to their default values. Only these [`AVOption`](@ref) fields for which (opt->flags & mask) == flags will have their default applied to s.
 
 ### Parameters
-* `s`: an [`AVOption`](@ref)-enabled struct (its first member must be a pointer to [`AVClass`](@ref)) 
-
-* `mask`: combination of AV\\_OPT\\_FLAG\\_* 
-
+* `s`: an [`AVOption`](@ref)-enabled struct (its first member must be a pointer to [`AVClass`](@ref))
+* `mask`: combination of AV\\_OPT\\_FLAG\\_*
 * `flags`: combination of AV\\_OPT\\_FLAG\\_*
 """
 function av_opt_set_defaults2(s, mask::Integer, flags::Integer)
@@ -16767,12 +17384,9 @@ end
 Parse the key/value pairs list in opts. For each key/value pair found, stores the value in the field in ctx that is named like the key. ctx must be an [`AVClass`](@ref) context, storing is done using AVOptions.
 
 ### Parameters
-* `opts`: options string to parse, may be NULL 
-
-* `key_val_sep`: a 0-terminated list of characters used to separate key from value 
-
-* `pairs_sep`: a 0-terminated list of characters used to separate two pairs from each other 
-
+* `opts`: options string to parse, may be NULL
+* `key_val_sep`: a 0-terminated list of characters used to separate key from value
+* `pairs_sep`: a 0-terminated list of characters used to separate two pairs from each other
 ### Returns
 the number of successfully set key/value pairs, or a negative value corresponding to an [`AVERROR`](@ref) code in case of error: [`AVERROR`](@ref)(EINVAL) if opts cannot be parsed, the error code issued by [`av_opt_set`](@ref)() if a key/value pair cannot be set
 """
@@ -16788,16 +17402,11 @@ Parse the key-value pairs list in opts. For each key=value pair found, set the v
 Options names must use only the following characters: a-z A-Z 0-9 - . / \\_ Separators must use characters distinct from option names and from each other.
 
 ### Parameters
-* `ctx`: the [`AVClass`](@ref) object to set options on 
-
-* `opts`: the options string, key-value pairs separated by a delimiter 
-
-* `shorthand`: a NULL-terminated array of options names for shorthand notation: if the first field in opts has no key part, the key is taken from the first element of shorthand; then again for the second, etc., until either opts is finished, shorthand is finished or a named option is found; after that, all options must be named 
-
-* `key_val_sep`: a 0-terminated list of characters used to separate key from value, for example '=' 
-
-* `pairs_sep`: a 0-terminated list of characters used to separate two pairs from each other, for example ':' or ',' 
-
+* `ctx`: the [`AVClass`](@ref) object to set options on
+* `opts`: the options string, key-value pairs separated by a delimiter
+* `shorthand`: a NULL-terminated array of options names for shorthand notation: if the first field in opts has no key part, the key is taken from the first element of shorthand; then again for the second, etc., until either opts is finished, shorthand is finished or a named option is found; after that, all options must be named
+* `key_val_sep`: a 0-terminated list of characters used to separate key from value, for example '='
+* `pairs_sep`: a 0-terminated list of characters used to separate two pairs from each other, for example ':' or ','
 ### Returns
 the number of successfully set key=value pairs, or a negative value corresponding to an [`AVERROR`](@ref) code in case of error: [`AVERROR`](@ref)(EINVAL) if opts cannot be parsed, the error code issued by av\\_set\\_string3() if a key/value pair cannot be set
 """
@@ -16820,10 +17429,8 @@ end
 Check whether a particular flag is set in a flags field.
 
 ### Parameters
-* `field_name`: the name of the flag field option 
-
-* `flag_name`: the name of the flag to check 
-
+* `field_name`: the name of the flag field option
+* `flag_name`: the name of the flag to check
 ### Returns
 non-zero if the flag is set, zero if the flag isn't set, isn't of the right type, or the flags field doesn't exist.
 """
@@ -16837,13 +17444,10 @@ end
 Set all the options from a given dictionary on an object.
 
 ### Parameters
-* `obj`: a struct whose first element is a pointer to [`AVClass`](@ref) 
-
+* `obj`: a struct whose first element is a pointer to [`AVClass`](@ref)
 * `options`: options to process. This dictionary will be freed and replaced by a new one containing all options not found in obj. Of course this new dictionary needs to be freed by caller with [`av_dict_free`](@ref)().
-
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) if some option was found in obj, but could not be set.
-
 ### See also
 [`av_dict_copy`](@ref)()
 """
@@ -16857,15 +17461,11 @@ end
 Set all the options from a given dictionary on an object.
 
 ### Parameters
-* `obj`: a struct whose first element is a pointer to [`AVClass`](@ref) 
-
-* `options`: options to process. This dictionary will be freed and replaced by a new one containing all options not found in obj. Of course this new dictionary needs to be freed by caller with [`av_dict_free`](@ref)(). 
-
+* `obj`: a struct whose first element is a pointer to [`AVClass`](@ref)
+* `options`: options to process. This dictionary will be freed and replaced by a new one containing all options not found in obj. Of course this new dictionary needs to be freed by caller with [`av_dict_free`](@ref)().
 * `search_flags`: A combination of AV\\_OPT\\_SEARCH\\_*.
-
 ### Returns
 0 on success, a negative [`AVERROR`](@ref) if some option was found in obj, but could not be set.
-
 ### See also
 [`av_dict_copy`](@ref)()
 """
@@ -16879,18 +17479,12 @@ end
 Extract a key-value pair from the beginning of a string.
 
 ### Parameters
-* `ropts`: pointer to the options string, will be updated to point to the rest of the string (one of the pairs\\_sep or the final NUL) 
-
-* `key_val_sep`: a 0-terminated list of characters used to separate key from value, for example '=' 
-
-* `pairs_sep`: a 0-terminated list of characters used to separate two pairs from each other, for example ':' or ',' 
-
-* `flags`: flags; see the AV\\_OPT\\_FLAG\\_* values below 
-
-* `rkey`: parsed key; must be freed using [`av_free`](@ref)() 
-
+* `ropts`: pointer to the options string, will be updated to point to the rest of the string (one of the pairs\\_sep or the final NUL)
+* `key_val_sep`: a 0-terminated list of characters used to separate key from value, for example '='
+* `pairs_sep`: a 0-terminated list of characters used to separate two pairs from each other, for example ':' or ','
+* `flags`: flags; see the AV\\_OPT\\_FLAG\\_* values below
+* `rkey`: parsed key; must be freed using [`av_free`](@ref)()
 * `rval`: parsed value; must be freed using [`av_free`](@ref)()
-
 ### Returns
 >=0 for success, or a negative value corresponding to an [`AVERROR`](@ref) code in case of error; in particular: [`AVERROR`](@ref)(EINVAL) if no key is present
 """
@@ -16898,7 +17492,7 @@ function av_opt_get_key_value(ropts, key_val_sep, pairs_sep, flags::Integer, rke
     ccall((:av_opt_get_key_value, libavutil), Cint, (Ptr{Cstring}, Cstring, Cstring, Cuint, Ptr{Cstring}, Ptr{Cstring}), ropts, key_val_sep, pairs_sep, flags, rkey, rval)
 end
 
-const __JL_Ctag_975 = UInt32
+const __JL_Ctag_851 = UInt32
 const AV_OPT_FLAG_IMPLICIT_KEY = 1 % UInt32
 
 """
@@ -16909,14 +17503,10 @@ const AV_OPT_FLAG_IMPLICIT_KEY = 1 % UInt32
 @{ This group of functions can be used to evaluate option strings and get numbers out of them. They do the same thing as [`av_opt_set`](@ref)(), except the result is written into the caller-supplied pointer.
 
 ### Parameters
-* `obj`: a struct whose first element is a pointer to [`AVClass`](@ref). 
-
-* `o`: an option for which the string is to be evaluated. 
-
-* `val`: string to be evaluated. 
-
+* `obj`: a struct whose first element is a pointer to [`AVClass`](@ref).
+* `o`: an option for which the string is to be evaluated.
+* `val`: string to be evaluated.
 * `*_out`: value of the string will be written here.
-
 ### Returns
 0 on success, a negative number on failure.
 """
@@ -16954,16 +17544,11 @@ Look for an option in an object. Consider only options which have all the specif
     Options found with [`AV_OPT_SEARCH_CHILDREN`](@ref) flag may not be settable directly with [`av_opt_set`](@ref)(). Use special calls which take an options [`AVDictionary`](@ref) (e.g. [`avformat_open_input`](@ref)()) to set options found with this flag.
 
 ### Parameters
-* `obj`:\\[in\\] A pointer to a struct whose first element is a pointer to an [`AVClass`](@ref). Alternatively a double pointer to an [`AVClass`](@ref), if [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) search flag is set. 
-
-* `name`:\\[in\\] The name of the option to look for. 
-
-* `unit`:\\[in\\] When searching for named constants, name of the unit it belongs to. 
-
-* `opt_flags`: Find only options with all the specified flags set (AV\\_OPT\\_FLAG). 
-
+* `obj`:\\[in\\] A pointer to a struct whose first element is a pointer to an [`AVClass`](@ref). Alternatively a double pointer to an [`AVClass`](@ref), if [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) search flag is set.
+* `name`:\\[in\\] The name of the option to look for.
+* `unit`:\\[in\\] When searching for named constants, name of the unit it belongs to.
+* `opt_flags`: Find only options with all the specified flags set (AV\\_OPT\\_FLAG).
 * `search_flags`: A combination of AV\\_OPT\\_SEARCH\\_*.
-
 ### Returns
 A pointer to the option found, or NULL if no option was found.
 """
@@ -16977,18 +17562,12 @@ end
 Look for an option in an object. Consider only options which have all the specified flags set.
 
 ### Parameters
-* `obj`:\\[in\\] A pointer to a struct whose first element is a pointer to an [`AVClass`](@ref). Alternatively a double pointer to an [`AVClass`](@ref), if [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) search flag is set. 
-
-* `name`:\\[in\\] The name of the option to look for. 
-
-* `unit`:\\[in\\] When searching for named constants, name of the unit it belongs to. 
-
-* `opt_flags`: Find only options with all the specified flags set (AV\\_OPT\\_FLAG). 
-
-* `search_flags`: A combination of AV\\_OPT\\_SEARCH\\_*. 
-
+* `obj`:\\[in\\] A pointer to a struct whose first element is a pointer to an [`AVClass`](@ref). Alternatively a double pointer to an [`AVClass`](@ref), if [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) search flag is set.
+* `name`:\\[in\\] The name of the option to look for.
+* `unit`:\\[in\\] When searching for named constants, name of the unit it belongs to.
+* `opt_flags`: Find only options with all the specified flags set (AV\\_OPT\\_FLAG).
+* `search_flags`: A combination of AV\\_OPT\\_SEARCH\\_*.
 * `target_obj`:\\[out\\] if non-NULL, an object to which the option belongs will be written here. It may be different from obj if [`AV_OPT_SEARCH_CHILDREN`](@ref) is present in search\\_flags. This parameter is ignored if search\\_flags contain [`AV_OPT_SEARCH_FAKE_OBJ`](@ref).
-
 ### Returns
 A pointer to the option found, or NULL if no option was found.
 """
@@ -17002,10 +17581,8 @@ end
 Iterate over all AVOptions belonging to obj.
 
 ### Parameters
-* `obj`: an AVOptions-enabled struct or a double pointer to an [`AVClass`](@ref) describing it. 
-
-* `prev`: result of the previous call to [`av_opt_next`](@ref)() on this object or NULL 
-
+* `obj`: an AVOptions-enabled struct or a double pointer to an [`AVClass`](@ref) describing it.
+* `prev`: result of the previous call to [`av_opt_next`](@ref)() on this object or NULL
 ### Returns
 next [`AVOption`](@ref) or NULL
 """
@@ -17019,8 +17596,7 @@ end
 Iterate over AVOptions-enabled children of obj.
 
 ### Parameters
-* `prev`: result of a previous call to this function or NULL 
-
+* `prev`: result of a previous call to this function or NULL
 ### Returns
 next AVOptions-enabled child or NULL
 """
@@ -17028,31 +17604,13 @@ function av_opt_child_next(obj, prev)
     ccall((:av_opt_child_next, libavutil), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), obj, prev)
 end
 
-"""
-    av_opt_child_class_next(parent, prev)
-
-Iterate over potential AVOptions-enabled children of parent.
-
-\\deprecated use [`av_opt_child_class_iterate`](@ref)
-
-### Parameters
-* `prev`: result of a previous call to this function or NULL 
-
-### Returns
-[`AVClass`](@ref) corresponding to next potential child or NULL
-"""
-function av_opt_child_class_next(parent, prev)
-    ccall((:av_opt_child_class_next, libavutil), Ptr{AVClass}, (Ptr{AVClass}, Ptr{AVClass}), parent, prev)
-end
-
 """
     av_opt_child_class_iterate(parent, iter)
 
 Iterate over potential AVOptions-enabled children of parent.
 
 ### Parameters
-* `iter`: a pointer where iteration state is stored. 
-
+* `iter`: a pointer where iteration state is stored.
 ### Returns
 [`AVClass`](@ref) corresponding to next potential child or NULL
 """
@@ -17068,14 +17626,10 @@ end
 @{ Those functions set the field of obj with the given name to value.
 
 ### Parameters
-* `obj`:\\[in\\] A struct whose first element is a pointer to an [`AVClass`](@ref). 
-
-* `name`:\\[in\\] the name of the field to set 
-
-* `val`:\\[in\\] The value to set. In case of [`av_opt_set`](@ref)() if the field is not of a string type, then the given string is parsed. SI postfixes and some named scalars are supported. If the field is of a numeric type, it has to be a numeric or named scalar. Behavior with more than one scalar and +- infix operators is undefined. If the field is of a flags type, it has to be a sequence of numeric scalars or named flags separated by '+' or '-'. Prefixing a flag with '+' causes it to be set without affecting the other flags; similarly, '-' unsets a flag. If the field is of a dictionary type, it has to be a ':' separated list of key=value parameters. Values containing ':' special characters must be escaped. 
-
+* `obj`:\\[in\\] A struct whose first element is a pointer to an [`AVClass`](@ref).
+* `name`:\\[in\\] the name of the field to set
+* `val`:\\[in\\] The value to set. In case of [`av_opt_set`](@ref)() if the field is not of a string type, then the given string is parsed. SI postfixes and some named scalars are supported. If the field is of a numeric type, it has to be a numeric or named scalar. Behavior with more than one scalar and +- infix operators is undefined. If the field is of a flags type, it has to be a sequence of numeric scalars or named flags separated by '+' or '-'. Prefixing a flag with '+' causes it to be set without affecting the other flags; similarly, '-' unsets a flag. If the field is of a dictionary type, it has to be a ':' separated list of key=value parameters. Values containing ':' special characters must be escaped.
 * `search_flags`: flags passed to [`av_opt_find2`](@ref). I.e. if [`AV_OPT_SEARCH_CHILDREN`](@ref) is passed here, then the option may be set on a child of obj.
-
 ### Returns
 0 if the value has been set, or an [`AVERROR`](@ref) code in case of error: [`AVERROR_OPTION_NOT_FOUND`](@ref) if no matching option exists [`AVERROR`](@ref)(ERANGE) if the value is out of range [`AVERROR`](@ref)(EINVAL) if the value is not valid
 """
@@ -17115,6 +17669,10 @@ function av_opt_set_channel_layout(obj, name, ch_layout::Int64, search_flags::In
     ccall((:av_opt_set_channel_layout, libavutil), Cint, (Ptr{Cvoid}, Cstring, Int64, Cint), obj, name, ch_layout, search_flags)
 end
 
+function av_opt_set_chlayout(obj, name, layout, search_flags::Integer)
+    ccall((:av_opt_set_chlayout, libavutil), Cint, (Ptr{Cvoid}, Cstring, Ptr{AVChannelLayout}, Cint), obj, name, layout, search_flags)
+end
+
 """
     av_opt_set_dict_val(obj, name, val, search_flags::Integer)
 
@@ -17142,14 +17700,10 @@ end
     if [`AV_OPT_ALLOW_NULL`](@ref) is set in search\\_flags in [`av_opt_get`](@ref), and the option is of type AV\\_OPT\\_TYPE\\_STRING, AV\\_OPT\\_TYPE\\_BINARY or AV\\_OPT\\_TYPE\\_DICT and is set to NULL, *out\\_val will be set to NULL instead of an allocated empty string.
 
 ### Parameters
-* `obj`:\\[in\\] a struct whose first element is a pointer to an [`AVClass`](@ref). 
-
-* `name`:\\[in\\] name of the option to get. 
-
-* `search_flags`:\\[in\\] flags passed to [`av_opt_find2`](@ref). I.e. if [`AV_OPT_SEARCH_CHILDREN`](@ref) is passed here, then the option may be found in a child of obj. 
-
-* `out_val`:\\[out\\] value of the option will be written here 
-
+* `obj`:\\[in\\] a struct whose first element is a pointer to an [`AVClass`](@ref).
+* `name`:\\[in\\] name of the option to get.
+* `search_flags`:\\[in\\] flags passed to [`av_opt_find2`](@ref). I.e. if [`AV_OPT_SEARCH_CHILDREN`](@ref) is passed here, then the option may be found in a child of obj.
+* `out_val`:\\[out\\] value of the option will be written here
 ### Returns
 >=0 on success, a negative error code otherwise
 """
@@ -17189,6 +17743,10 @@ function av_opt_get_channel_layout(obj, name, search_flags::Integer, ch_layout)
     ccall((:av_opt_get_channel_layout, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint, Ptr{Int64}), obj, name, search_flags, ch_layout)
 end
 
+function av_opt_get_chlayout(obj, name, search_flags::Integer, layout)
+    ccall((:av_opt_get_chlayout, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint, Ptr{AVChannelLayout}), obj, name, search_flags, layout)
+end
+
 """
     av_opt_get_dict_val(obj, name, search_flags::Integer, out_val)
 
@@ -17232,11 +17790,9 @@ The returned list may depend on other fields in obj like for example profile.
 The result must be freed with [`av_opt_freep_ranges`](@ref).
 
 ### Parameters
-* `flags`: is a bitmask of flags, undefined flags should not be set and should be ignored [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) indicates that the obj is a double pointer to a [`AVClass`](@ref) instead of a full instance [`AV_OPT_MULTI_COMPONENT_RANGE`](@ref) indicates that function may return more than one component, 
-
+* `flags`: is a bitmask of flags, undefined flags should not be set and should be ignored [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) indicates that the obj is a double pointer to a [`AVClass`](@ref) instead of a full instance [`AV_OPT_MULTI_COMPONENT_RANGE`](@ref) indicates that function may return more than one component,
 ### Returns
 number of compontents returned on success, a negative errro code otherwise
-
 ### See also
 [`AVOptionRanges`](@ref)
 """
@@ -17249,13 +17805,15 @@ end
 
 Copy options from src object into dest object.
 
-Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object. Original memory allocated for such options is freed unless both src and dest options points to the same memory.
+The underlying [`AVClass`](@ref) of both src and dest must coincide. The guarantee below does not apply if this is not fulfilled.
 
-### Parameters
-* `dest`: Object to copy from 
+Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object. Original memory allocated for such options is freed unless both src and dest options points to the same memory.
 
-* `src`: Object to copy into 
+Even on error it is guaranteed that allocated options from src and dest no longer alias each other afterwards; in particular calling [`av_opt_free`](@ref)() on both src and dest is safe afterwards if dest has been memdup'ed from src.
 
+### Parameters
+* `dest`: Object to copy from
+* `src`: Object to copy into
 ### Returns
 0 on success, negative on error
 """
@@ -17273,11 +17831,9 @@ This list is constructed without using the [`AVClass`](@ref).query\\_ranges() ca
 The result must be freed with av\\_opt\\_free\\_ranges.
 
 ### Parameters
-* `flags`: is a bitmask of flags, undefined flags should not be set and should be ignored [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) indicates that the obj is a double pointer to a [`AVClass`](@ref) instead of a full instance [`AV_OPT_MULTI_COMPONENT_RANGE`](@ref) indicates that function may return more than one component, 
-
+* `flags`: is a bitmask of flags, undefined flags should not be set and should be ignored [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) indicates that the obj is a double pointer to a [`AVClass`](@ref) instead of a full instance [`AV_OPT_MULTI_COMPONENT_RANGE`](@ref) indicates that function may return more than one component,
 ### Returns
 number of compontents returned on success, a negative errro code otherwise
-
 ### See also
 [`AVOptionRanges`](@ref)
 """
@@ -17290,16 +17846,13 @@ end
 
 Check if given option is set to its default value.
 
-Options o must belong to the obj. This function must not be called to check child's options state. 
+Options o must belong to the obj. This function must not be called to check child's options state.
 
 ### Parameters
-* `obj`: [`AVClass`](@ref) object to check option on 
-
-* `o`: option to be checked 
-
+* `obj`: [`AVClass`](@ref) object to check option on
+* `o`: option to be checked
 ### Returns
 >0 when option is set to its default, 0 when option is not set its default, <0 on error
-
 ### See also
 [`av_opt_is_set_to_default_by_name`](@ref)().
 """
@@ -17313,12 +17866,9 @@ end
 Check if given option is set to its default value.
 
 ### Parameters
-* `obj`: [`AVClass`](@ref) object to check option on 
-
-* `name`: option name 
-
-* `search_flags`: combination of AV\\_OPT\\_SEARCH\\_* 
-
+* `obj`: [`AVClass`](@ref) object to check option on
+* `name`: option name
+* `search_flags`: combination of AV\\_OPT\\_SEARCH\\_*
 ### Returns
 >0 when option is set to its default, 0 when option is not set its default, <0 on error
 """
@@ -17338,20 +17888,14 @@ Create a string containing object's serialized options. Such string may be passe
     Separators cannot be neither '\\' nor '\\0'. They also cannot be the same.
 
 ### Parameters
-* `obj`:\\[in\\] [`AVClass`](@ref) object to serialize 
-
-* `opt_flags`:\\[in\\] serialize options with all the specified flags set (AV\\_OPT\\_FLAG) 
-
-* `flags`:\\[in\\] combination of AV\\_OPT\\_SERIALIZE\\_* flags 
-
-* `buffer`:\\[out\\] Pointer to buffer that will be allocated with string containg serialized options. Buffer must be freed by the caller when is no longer needed. 
-
-* `key_val_sep`:\\[in\\] character used to separate key from value 
-
-* `pairs_sep`:\\[in\\] character used to separate two pairs from each other 
-
+* `obj`:\\[in\\] [`AVClass`](@ref) object to serialize
+* `opt_flags`:\\[in\\] serialize options with all the specified flags set (AV\\_OPT\\_FLAG)
+* `flags`:\\[in\\] combination of AV\\_OPT\\_SERIALIZE\\_* flags
+* `buffer`:\\[out\\] Pointer to buffer that will be allocated with string containg serialized options. Buffer must be freed by the caller when is no longer needed.
+* `key_val_sep`:\\[in\\] character used to separate key from value
+* `pairs_sep`:\\[in\\] character used to separate two pairs from each other
 ### Returns
->= 0 on success, negative on error 
+>= 0 on success, negative on error
 """
 function av_opt_serialize(obj, opt_flags::Integer, flags::Integer, buffer, key_val_sep::Cchar, pairs_sep::Cchar)
     ccall((:av_opt_serialize, libavutil), Cint, (Ptr{Cvoid}, Cint, Cint, Ptr{Cstring}, Cchar, Cchar), obj, opt_flags, flags, buffer, key_val_sep, pairs_sep)
@@ -17367,16 +17911,11 @@ Note that a ratio with infinite (1/0) or negative value is considered valid, so
 The undefined value can be expressed using the "0:0" string.
 
 ### Parameters
-* `q`:\\[in,out\\] pointer to the [`AVRational`](@ref) which will contain the ratio 
-
-* `str`:\\[in\\] the string to parse: it has to be a string in the format num:den, a float number or an expression 
-
-* `max`:\\[in\\] the maximum allowed numerator and denominator 
-
-* `log_offset`:\\[in\\] log level offset which is applied to the log level of log\\_ctx 
-
-* `log_ctx`:\\[in\\] parent logging context 
-
+* `q`:\\[in,out\\] pointer to the [`AVRational`](@ref) which will contain the ratio
+* `str`:\\[in\\] the string to parse: it has to be a string in the format num:den, a float number or an expression
+* `max`:\\[in\\] the maximum allowed numerator and denominator
+* `log_offset`:\\[in\\] log level offset which is applied to the log level of log\\_ctx
+* `log_ctx`:\\[in\\] parent logging context
 ### Returns
 >= 0 on success, a negative error code otherwise
 """
@@ -17390,12 +17929,9 @@ end
 Parse str and put in width\\_ptr and height\\_ptr the detected values.
 
 ### Parameters
-* `width_ptr`:\\[in,out\\] pointer to the variable which will contain the detected width value 
-
-* `height_ptr`:\\[in,out\\] pointer to the variable which will contain the detected height value 
-
-* `str`:\\[in\\] the string to parse: it has to be a string in the format width x height or a valid video size abbreviation. 
-
+* `width_ptr`:\\[in,out\\] pointer to the variable which will contain the detected width value
+* `height_ptr`:\\[in,out\\] pointer to the variable which will contain the detected height value
+* `str`:\\[in\\] the string to parse: it has to be a string in the format width x height or a valid video size abbreviation.
 ### Returns
 >= 0 on success, a negative error code otherwise
 """
@@ -17409,10 +17945,8 @@ end
 Parse str and store the detected values in *rate.
 
 ### Parameters
-* `rate`:\\[in,out\\] pointer to the [`AVRational`](@ref) which will contain the detected frame rate 
-
-* `str`:\\[in\\] the string to parse: it has to be a string in the format rate\\_num / rate\\_den, a float number or a valid video rate abbreviation 
-
+* `rate`:\\[in,out\\] pointer to the [`AVRational`](@ref) which will contain the detected frame rate
+* `str`:\\[in\\] the string to parse: it has to be a string in the format rate\\_num / rate\\_den, a float number or a valid video rate abbreviation
 ### Returns
 >= 0 on success, a negative error code otherwise
 """
@@ -17426,10 +17960,10 @@ end
 Put the RGBA values that correspond to color\\_string in rgba\\_color.
 
 ### Parameters
-* `color_string`: a string specifying a color. It can be the name of a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence, possibly followed by "" and a string representing the alpha component. The alpha component may be a string composed by "0x" followed by an hexadecimal number or a decimal number between 0.0 and 1.0, which represents the opacity value (0x00/0.0 means completely transparent, 0xff/1.0 completely opaque). If the alpha component is not specified then 0xff is assumed. The string "random" will result in a random color. 
-
-* `slen`: length of the initial part of color\\_string containing the color. It can be set to -1 if color\\_string is a null terminated string containing nothing else than the color. 
-
+* `rgba_color`: 4-elements array of uint8\\_t values, where the respective red, green, blue and alpha component values are written.
+* `color_string`: a string specifying a color. It can be the name of a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence, possibly followed by "@" and a string representing the alpha component. The alpha component may be a string composed by "0x" followed by an hexadecimal number or a decimal number between 0.0 and 1.0, which represents the opacity value (0x00/0.0 means completely transparent, 0xff/1.0 completely opaque). If the alpha component is not specified then 0xff is assumed. The string "random" will result in a random color.
+* `slen`: length of the initial part of color\\_string containing the color. It can be set to -1 if color\\_string is a null terminated string containing nothing else than the color.
+* `log_ctx`: a pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct (used for [`av_log`](@ref)()). Can be NULL.
 ### Returns
 >= 0 in case of success, a negative value in case of failure (for example if color\\_string cannot be parsed).
 """
@@ -17445,10 +17979,8 @@ Get the name of a color from the internal table of hard-coded named colors.
 This function is meant to enumerate the color names recognized by [`av_parse_color`](@ref)().
 
 ### Parameters
-* `color_idx`: index of the requested color, starting from 0 
-
-* `rgbp`: if not NULL, will point to a 3-elements array with the color value in RGB 
-
+* `color_idx`: index of the requested color, starting from 0
+* `rgb`: if not NULL, will point to a 3-elements array with the color value in RGB
 ### Returns
 the color name string or NULL if color\\_idx is not in the array
 """
@@ -17466,7 +17998,7 @@ Parse timestr and return in *time a corresponding number of microseconds.
  now
 ```
 
-If the value is "now" it takes the current time. Time is local time unless Z is appended, in which case it is interpreted as UTC. If the year-month-day part is not specified it takes the current year-month-day. - If a duration the syntax is: 
+If the value is "now" it takes the current time. Time is local time unless Z is appended, in which case it is interpreted as UTC. If the year-month-day part is not specified it takes the current year-month-day. - If a duration the syntax is:
 
 ```c++
  [-][HH:]MM:SS[.m...]
@@ -17475,11 +18007,8 @@ If the value is "now" it takes the current time. Time is local time unless Z is
 
 ### Parameters
 * `timeval`: puts here the number of microseconds corresponding to the string in timestr. If the string represents a duration, it is the number of microseconds contained in the time interval. If the string is a date, is the number of microseconds since 1st of January, 1970 up to the time of the parsed date. If timestr cannot be successfully parsed, set *time to INT64\\_MIN.
-
-* `timestr`: a string representing a date or a duration. - If a date the syntax is: 
-
-* `duration`: flag which tells how to interpret timestr, if not zero timestr is interpreted as a duration, otherwise as a date 
-
+* `timestr`: a string representing a date or a duration. - If a date the syntax is:
+* `duration`: flag which tells how to interpret timestr, if not zero timestr is interpreted as a duration, otherwise as a date
 ### Returns
 >= 0 in case of success, a negative value corresponding to an [`AVERROR`](@ref) code otherwise
 """
@@ -17505,7 +18034,7 @@ Simplified version of strptime
 
 Parse the input string p according to the format string fmt and store its results in the structure dt. This implementation supports only a subset of the formats supported by the standard strptime().
 
-The supported input field descriptors are listed below. - H: the hour as a decimal number, using a 24-hour clock, in the range '00' through '23' - J: hours as a decimal number, in the range '0' through INT\\_MAX - M: the minute as a decimal number, using a 24-hour clock, in the range '00' through '59' - S: the second as a decimal number, using a 24-hour clock, in the range '00' through '59' - Y: the year as a decimal number, using the Gregorian calendar - m: the month as a decimal number, in the range '1' through '12' - d: the day of the month as a decimal number, in the range '1' through '31' - T: alias for 'H:M:S' - %%: a literal '%'
+The supported input field descriptors are listed below. - `%H`: the hour as a decimal number, using a 24-hour clock, in the range '00' through '23' - `%J`: hours as a decimal number, in the range '0' through INT\\_MAX - `%M`: the minute as a decimal number, using a 24-hour clock, in the range '00' through '59' - `%S`: the second as a decimal number, using a 24-hour clock, in the range '00' through '59' - `%Y`: the year as a decimal number, using the Gregorian calendar - `%m`: the month as a decimal number, in the range '1' through '12' - `%d`: the day of the month as a decimal number, in the range '1' through '31' - `%T`: alias for `%H:%M:%S` - `%%`: a literal `%`
 
 ### Returns
 a pointer to the first character not processed in this function call. In case the input string contains more characters than required by the format string the return value points right after the last consumed input character. In case the whole input string is consumed the return value points to the null byte at the end of the string. On failure NULL is returned.
@@ -17560,7 +18089,6 @@ Iterate over all pixel format descriptors known to libavutil.
 
 ### Parameters
 * `prev`: previous descriptor. NULL to get the first descriptor.
-
 ### Returns
 next descriptor or NULL after the last descriptor
 """
@@ -17584,12 +18112,9 @@ end
 Utility function to access log2\\_chroma\\_w log2\\_chroma\\_h from the pixel format [`AVPixFmtDescriptor`](@ref).
 
 ### Parameters
-* `pix_fmt`:\\[in\\] the pixel format 
-
-* `h_shift`:\\[out\\] store log2\\_chroma\\_w (horizontal/width shift) 
-
+* `pix_fmt`:\\[in\\] the pixel format
+* `h_shift`:\\[out\\] store log2\\_chroma\\_w (horizontal/width shift)
 * `v_shift`:\\[out\\] store log2\\_chroma\\_h (vertical/height shift)
-
 ### Returns
 0 on success, [`AVERROR`](@ref)(ENOSYS) on invalid or unknown pixel format
 """
@@ -17707,6 +18232,36 @@ function av_chroma_location_from_name(name)
     ccall((:av_chroma_location_from_name, libavutil), Cint, (Cstring,), name)
 end
 
+"""
+    av_chroma_location_enum_to_pos(xpos, ypos, pos::AVChromaLocation)
+
+Converts [`AVChromaLocation`](@ref) to swscale x/y chroma position.
+
+The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256
+
+### Parameters
+* `xpos`: horizontal chroma sample position
+* `ypos`: vertical chroma sample position
+"""
+function av_chroma_location_enum_to_pos(xpos, ypos, pos::AVChromaLocation)
+    ccall((:av_chroma_location_enum_to_pos, libavutil), Cint, (Ptr{Cint}, Ptr{Cint}, AVChromaLocation), xpos, ypos, pos)
+end
+
+"""
+    av_chroma_location_pos_to_enum(xpos::Integer, ypos::Integer)
+
+Converts swscale x/y chroma position to [`AVChromaLocation`](@ref).
+
+The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256
+
+### Parameters
+* `xpos`: horizontal chroma sample position
+* `ypos`: vertical chroma sample position
+"""
+function av_chroma_location_pos_to_enum(xpos::Integer, ypos::Integer)
+    ccall((:av_chroma_location_pos_to_enum, libavutil), AVChromaLocation, (Cint, Cint), xpos, ypos)
+end
+
 """
     av_get_pix_fmt(name)
 
@@ -17738,10 +18293,8 @@ end
 Print in buf the string corresponding to the pixel format with number pix\\_fmt, or a header if pix\\_fmt is negative.
 
 ### Parameters
-* `buf`: the buffer where to write the string 
-
-* `buf_size`: the size of buf 
-
+* `buf`: the buffer where to write the string
+* `buf_size`: the size of buf
 * `pix_fmt`: the number of the pixel format to print the corresponding info string, or a negative value to print the corresponding header.
 """
 function av_get_pix_fmt_string(buf, buf_size::Integer, pix_fmt::AVPixelFormat)
@@ -17754,20 +18307,13 @@ end
 Read a line from an image, and write the values of the pixel format component c to dst.
 
 ### Parameters
-* `data`: the array containing the pointers to the planes of the image 
-
-* `linesize`: the array containing the linesizes of the image 
-
-* `desc`: the pixel format descriptor for the image 
-
-* `x`: the horizontal coordinate of the first pixel to read 
-
-* `y`: the vertical coordinate of the first pixel to read 
-
-* `w`: the width of the line to read, that is the number of values to write to dst 
-
-* `read_pal_component`: if not zero and the format is a paletted format writes the values corresponding to the palette component c in data[1] to dst, rather than the palette indexes in data[0]. The behavior is undefined if the format is not paletted. 
-
+* `data`: the array containing the pointers to the planes of the image
+* `linesize`: the array containing the linesizes of the image
+* `desc`: the pixel format descriptor for the image
+* `x`: the horizontal coordinate of the first pixel to read
+* `y`: the vertical coordinate of the first pixel to read
+* `w`: the width of the line to read, that is the number of values to write to dst
+* `read_pal_component`: if not zero and the format is a paletted format writes the values corresponding to the palette component c in data[1] to dst, rather than the palette indexes in data[0]. The behavior is undefined if the format is not paletted.
 * `dst_element_size`: size of elements in dst array (2 or 4 byte)
 """
 function av_read_image_line2(dst, data, linesize, desc, x::Integer, y::Integer, c::Integer, w::Integer, read_pal_component::Integer, dst_element_size::Integer)
@@ -17784,20 +18330,13 @@ end
 Write the values from src to the pixel format component c of an image line.
 
 ### Parameters
-* `src`: array containing the values to write 
-
-* `data`: the array containing the pointers to the planes of the image to write into. It is supposed to be zeroed. 
-
-* `linesize`: the array containing the linesizes of the image 
-
-* `desc`: the pixel format descriptor for the image 
-
-* `x`: the horizontal coordinate of the first pixel to write 
-
-* `y`: the vertical coordinate of the first pixel to write 
-
-* `w`: the width of the line to write, that is the number of values to write to the image line 
-
+* `src`: array containing the values to write
+* `data`: the array containing the pointers to the planes of the image to write into. It is supposed to be zeroed.
+* `linesize`: the array containing the linesizes of the image
+* `desc`: the pixel format descriptor for the image
+* `x`: the horizontal coordinate of the first pixel to write
+* `y`: the vertical coordinate of the first pixel to write
+* `w`: the width of the line to write, that is the number of values to write to the image line
 * `src_element_size`: size of elements in src array (2 or 4 byte)
 """
 function av_write_image_line2(src, data, linesize, desc, x::Integer, y::Integer, c::Integer, w::Integer, src_element_size::Integer)
@@ -17815,7 +18354,6 @@ Utility function to swap the endianness of a pixel format.
 
 ### Parameters
 * `pix_fmt`:\\[in\\] the pixel format
-
 ### Returns
 pixel format with swapped endianness if it exists, otherwise AV\\_PIX\\_FMT\\_NONE
 """
@@ -17829,12 +18367,9 @@ end
 Compute what kind of losses will occur when converting from one specific pixel format to another. When converting from one pixel format to another, information loss may occur. For example, when converting from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when converting from some formats to other formats. These losses can involve loss of chroma, but also loss of resolution, loss of color depth, loss due to the color space conversion, loss of the alpha bits or loss due to color quantization. av\\_get\\_fix\\_fmt\\_loss() informs you about the various types of losses which will occur when converting from one pixel format to another.
 
 ### Parameters
-* `dst_pix_fmt`:\\[in\\] destination pixel format 
-
-* `src_pix_fmt`:\\[in\\] source pixel format 
-
-* `has_alpha`:\\[in\\] Whether the source pixel format alpha channel is used. 
-
+* `dst_pix_fmt`:\\[in\\] destination pixel format
+* `src_pix_fmt`:\\[in\\] source pixel format
+* `has_alpha`:\\[in\\] Whether the source pixel format alpha channel is used.
 ### Returns
 Combination of flags informing you what kind of losses will occur (maximum loss for an invalid dst\\_pix\\_fmt).
 """
@@ -17848,12 +18383,9 @@ end
 Compute what kind of losses will occur when converting from one specific pixel format to another. When converting from one pixel format to another, information loss may occur. For example, when converting from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when converting from some formats to other formats. These losses can involve loss of chroma, but also loss of resolution, loss of color depth, loss due to the color space conversion, loss of the alpha bits or loss due to color quantization. av\\_get\\_fix\\_fmt\\_loss() informs you about the various types of losses which will occur when converting from one pixel format to another.
 
 ### Parameters
-* `dst_pix_fmt`:\\[in\\] destination pixel format 
-
-* `src_pix_fmt`:\\[in\\] source pixel format 
-
-* `has_alpha`:\\[in\\] Whether the source pixel format alpha channel is used. 
-
+* `dst_pix_fmt`:\\[in\\] destination pixel format
+* `src_pix_fmt`:\\[in\\] source pixel format
+* `has_alpha`:\\[in\\] Whether the source pixel format alpha channel is used.
 ### Returns
 Combination of flags informing you what kind of losses will occur (maximum loss for an invalid dst\\_pix\\_fmt).
 """
@@ -17873,14 +18405,10 @@ const av_pixelutils_sad_fn = Ptr{Cvoid}
 Get a potentially optimized pointer to a Sum-of-absolute-differences function (see the [`av_pixelutils_sad_fn`](@ref) prototype).
 
 ### Parameters
-* `w_bits`: 1<<w\\_bits is the requested width of the block size 
-
-* `h_bits`: 1<<h\\_bits is the requested height of the block size 
-
-* `aligned`: If set to 2, the returned sad function will assume src1 and src2 addresses are aligned on the block size. If set to 1, the returned sad function will assume src1 is aligned on the block size. If set to 0, the returned sad function assume no particular alignment. 
-
+* `w_bits`: 1<<w\\_bits is the requested width of the block size
+* `h_bits`: 1<<h\\_bits is the requested height of the block size
+* `aligned`: If set to 2, the returned sad function will assume src1 and src2 addresses are aligned on the block size. If set to 1, the returned sad function will assume src1 is aligned on the block size. If set to 0, the returned sad function assume no particular alignment.
 * `log_ctx`: context used for logging, can be NULL
-
 ### Returns
 a pointer to the SAD function or NULL in case of error (because of invalid parameters)
 """
@@ -17897,6 +18425,23 @@ function av_get_random_seed()
     ccall((:av_get_random_seed, libavutil), UInt32, ())
 end
 
+"""
+    av_random_bytes(buf, len::Csize_t)
+
+Generate cryptographically secure random data, i.e. suitable for use as encryption keys and similar.
+
+\\retval0 success, len bytes of random data was written into buf
+
+\\retval"a negative [`AVERROR`](@ref) code" random data could not be generated
+
+### Parameters
+* `buf`: buffer into which the random data will be written
+* `len`: size of buf in bytes
+"""
+function av_random_bytes(buf, len::Csize_t)
+    ccall((:av_random_bytes, libavutil), Cint, (Ptr{UInt8}, Csize_t), buf, len)
+end
+
 """
     av_make_q(num::Integer, den::Integer)
 
@@ -17906,7 +18451,7 @@ Useful for compilers that do not support compound literals.
 
 !!! note
 
-    The return value is not reduced. 
+    The return value is not reduced.
 
 ### See also
 [`av_reduce`](@ref)()
@@ -17921,10 +18466,8 @@ end
 Compare two rationals.
 
 ### Parameters
-* `a`: First rational 
-
+* `a`: First rational
 * `b`: Second rational
-
 ### Returns
 One of the following values: - 0 if `a == b` - 1 if `a > b` - -1 if `a < b` - `INT_MIN` if one of the values is of the form `0 / 0`
 """
@@ -17935,14 +18478,12 @@ end
 """
     av_q2d(a::AVRational)
 
-Convert an [`AVRational`](@ref) to a `double`. 
+Convert an [`AVRational`](@ref) to a `double`.
 
 ### Parameters
-* `a`: [`AVRational`](@ref) to convert 
-
+* `a`: [`AVRational`](@ref) to convert
 ### Returns
-`a` in floating-point form 
-
+`a` in floating-point form
 ### See also
 [`av_d2q`](@ref)()
 """
@@ -17958,16 +18499,11 @@ Reduce a fraction.
 This is useful for framerate calculations.
 
 ### Parameters
-* `dst_num`:\\[out\\] Destination numerator 
-
-* `dst_den`:\\[out\\] Destination denominator 
-
-* `num`:\\[in\\] Source numerator 
-
-* `den`:\\[in\\] Source denominator 
-
-* `max`:\\[in\\] Maximum allowed values for `dst_num` & `dst_den` 
-
+* `dst_num`:\\[out\\] Destination numerator
+* `dst_den`:\\[out\\] Destination denominator
+* `num`:\\[in\\] Source numerator
+* `den`:\\[in\\] Source denominator
+* `max`:\\[in\\] Maximum allowed values for `dst_num` & `dst_den`
 ### Returns
 1 if the operation is exact, 0 otherwise
 """
@@ -17978,13 +18514,11 @@ end
 """
     av_mul_q(b::AVRational, c::AVRational)
 
-Multiply two rationals. 
+Multiply two rationals.
 
 ### Parameters
-* `b`: First rational 
-
-* `c`: Second rational 
-
+* `b`: First rational
+* `c`: Second rational
 ### Returns
 b*c
 """
@@ -17995,13 +18529,11 @@ end
 """
     av_div_q(b::AVRational, c::AVRational)
 
-Divide one rational by another. 
+Divide one rational by another.
 
 ### Parameters
-* `b`: First rational 
-
-* `c`: Second rational 
-
+* `b`: First rational
+* `c`: Second rational
 ### Returns
 b/c
 """
@@ -18012,13 +18544,11 @@ end
 """
     av_add_q(b::AVRational, c::AVRational)
 
-Add two rationals. 
+Add two rationals.
 
 ### Parameters
-* `b`: First rational 
-
-* `c`: Second rational 
-
+* `b`: First rational
+* `c`: Second rational
 ### Returns
 b+c
 """
@@ -18029,13 +18559,11 @@ end
 """
     av_sub_q(b::AVRational, c::AVRational)
 
-Subtract one rational from another. 
+Subtract one rational from another.
 
 ### Parameters
-* `b`: First rational 
-
-* `c`: Second rational 
-
+* `b`: First rational
+* `c`: Second rational
 ### Returns
 b-c
 """
@@ -18046,11 +18574,10 @@ end
 """
     av_inv_q(q::AVRational)
 
-Invert a rational. 
+Invert a rational.
 
 ### Parameters
-* `q`: value 
-
+* `q`: value
 ### Returns
 1 / q
 """
@@ -18066,13 +18593,10 @@ Convert a double precision floating point number to a rational.
 In case of infinity, the returned value is expressed as `{1, 0}` or `{-1, 0}` depending on the sign.
 
 ### Parameters
-* `d`: `double` to convert 
-
-* `max`: Maximum allowed numerator and denominator 
-
+* `d`: `double` to convert
+* `max`: Maximum allowed numerator and denominator
 ### Returns
-`d` in [`AVRational`](@ref) form 
-
+`d` in [`AVRational`](@ref) form
 ### See also
 [`av_q2d`](@ref)()
 """
@@ -18086,10 +18610,9 @@ end
 Find which of the two rationals is closer to another rational.
 
 ### Parameters
-* `q`: Rational to be compared against 
-
-* `q1,q2`: Rationals to be tested 
-
+* `q`: Rational to be compared against
+* `q1`: Rational to be tested
+* `q2`: Rational to be tested
 ### Returns
 One of the following values: - 1 if `q1` is nearer to `q` than `q2` - -1 if `q2` is nearer to `q` than `q1` - 0 if they have the same distance
 """
@@ -18103,10 +18626,8 @@ end
 Find the value in a list of rationals nearest a given reference rational.
 
 ### Parameters
-* `q`: Reference rational 
-
-* `q_list`: Array of rationals terminated by `{0, 0}` 
-
+* `q`: Reference rational
+* `q_list`: Array of rationals terminated by `{0, 0}`
 ### Returns
 Index of the nearest value found in the array
 """
@@ -18124,10 +18645,9 @@ Convert an [`AVRational`](@ref) to a IEEE 32-bit `float` expressed in fixed-poin
     The returned value is platform-indepedant.
 
 ### Parameters
-* `q`: Rational to be converted 
-
+* `q`: Rational to be converted
 ### Returns
-Equivalent floating-point value, expressed as an unsigned 32-bit integer. 
+Equivalent floating-point value, expressed as an unsigned 32-bit integer.
 """
 function av_q2intfloat(q::AVRational)
     ccall((:av_q2intfloat, libavutil), UInt32, (AVRational,), q)
@@ -18172,10 +18692,10 @@ end
 Initializes an [`AVRC4`](@ref) context.
 
 ### Parameters
-* `key_bits`: must be a multiple of 8 
-
-* `decrypt`: 0 for encryption, 1 for decryption, currently has no effect 
-
+* `d`: pointer to the [`AVRC4`](@ref) context
+* `key`: buffer containig the key
+* `key_bits`: must be a multiple of 8
+* `decrypt`: 0 for encryption, 1 for decryption, currently has no effect
 ### Returns
 zero on success, negative value otherwise
 """
@@ -18189,14 +18709,11 @@ end
 Encrypts / decrypts using the RC4 algorithm.
 
 ### Parameters
-* `count`: number of bytes 
-
-* `dst`: destination array, can be equal to src 
-
-* `src`: source array, can be equal to dst, may be NULL 
-
-* `iv`: not (yet) used for RC4, should be NULL 
-
+* `d`: pointer to the [`AVRC4`](@ref) context
+* `count`: number of bytes
+* `dst`: destination array, can be equal to src
+* `src`: source array, can be equal to dst, may be NULL
+* `iv`: not (yet) used for RC4, should be NULL
 * `decrypt`: 0 for encryption, 1 for decryption, not (yet) used
 """
 function av_rc4_crypt(d, dst, src, count::Integer, iv, decrypt::Integer)
@@ -18232,10 +18749,8 @@ end
 Initialize RIPEMD hashing.
 
 ### Parameters
-* `context`: pointer to the function context (of size av\\_ripemd\\_size) 
-
-* `bits`: number of bits in digest (128, 160, 256 or 320 bits) 
-
+* `context`: pointer to the function context (of size av\\_ripemd\\_size)
+* `bits`: number of bits in digest (128, 160, 256 or 320 bits)
 ### Returns
 zero if initialization succeeded, -1 otherwise
 """
@@ -18243,8 +18758,18 @@ function av_ripemd_init(context, bits::Integer)
     ccall((:av_ripemd_init, libavutil), Cint, (Ptr{AVRIPEMD}, Cint), context, bits)
 end
 
-function av_ripemd_update(context, data, len::Integer)
-    ccall((:av_ripemd_update, libavutil), Cvoid, (Ptr{AVRIPEMD}, Ptr{UInt8}, Cuint), context, data, len)
+"""
+    av_ripemd_update(context, data, len::Csize_t)
+
+Update hash value.
+
+### Parameters
+* `context`: hash function context
+* `data`: input data to update hash with
+* `len`: input data length
+"""
+function av_ripemd_update(context, data, len::Csize_t)
+    ccall((:av_ripemd_update, libavutil), Cvoid, (Ptr{AVRIPEMD}, Ptr{UInt8}, Csize_t), context, data, len)
 end
 
 """
@@ -18253,8 +18778,7 @@ end
 Finish hashing and output digest value.
 
 ### Parameters
-* `context`: hash function context 
-
+* `context`: hash function context
 * `digest`: buffer where output digest value is stored
 """
 function av_ripemd_final(context, digest)
@@ -18322,12 +18846,9 @@ end
 Generate a string corresponding to the sample format with sample\\_fmt, or a header if sample\\_fmt is negative.
 
 ### Parameters
-* `buf`: the buffer where to write the string 
-
-* `buf_size`: the size of buf 
-
-* `sample_fmt`: the number of the sample format to print the corresponding info string, or a negative value to print the corresponding header. 
-
+* `buf`: the buffer where to write the string
+* `buf_size`: the size of buf
+* `sample_fmt`: the number of the sample format to print the corresponding info string, or a negative value to print the corresponding header.
 ### Returns
 the pointer to the filled buffer or NULL if sample\\_fmt is unknown or in case of other errors
 """
@@ -18341,8 +18862,7 @@ end
 Return number of bytes per sample.
 
 ### Parameters
-* `sample_fmt`: the sample format 
-
+* `sample_fmt`: the sample format
 ### Returns
 number of bytes per sample or zero if unknown for the given sample format
 """
@@ -18356,8 +18876,7 @@ end
 Check if the sample format is planar.
 
 ### Parameters
-* `sample_fmt`: the sample format to inspect 
-
+* `sample_fmt`: the sample format to inspect
 ### Returns
 1 if the sample format is planar, 0 if it is interleaved
 """
@@ -18371,16 +18890,11 @@ end
 Get the required buffer size for the given audio parameters.
 
 ### Parameters
-* `linesize`:\\[out\\] calculated linesize, may be NULL 
-
-* `nb_channels`: the number of channels 
-
-* `nb_samples`: the number of samples in a single channel 
-
-* `sample_fmt`: the sample format 
-
-* `align`: buffer size alignment (0 = default, 1 = no alignment) 
-
+* `linesize`:\\[out\\] calculated linesize, may be NULL
+* `nb_channels`: the number of channels
+* `nb_samples`: the number of samples in a single channel
+* `sample_fmt`: the sample format
+* `align`: buffer size alignment (0 = default, 1 = no alignment)
 ### Returns
 required buffer size, or negative error code on failure
 """
@@ -18399,26 +18913,16 @@ The value pointed to by linesize is set to the aligned size of each channel's da
 
 The buffer in buf must be big enough to contain all the samples (use [`av_samples_get_buffer_size`](@ref)() to compute its minimum size), otherwise the audio\\_data pointers will point to invalid data.
 
-\\todo return minimum size in bytes required for the buffer in case of success at the next bump
-
 ### Parameters
-* `audio_data`:\\[out\\] array to be filled with the pointer for each channel 
-
-* `linesize`:\\[out\\] calculated linesize, may be NULL 
-
-* `buf`: the pointer to a buffer containing the samples 
-
-* `nb_channels`: the number of channels 
-
-* `nb_samples`: the number of samples in a single channel 
-
-* `sample_fmt`: the sample format 
-
-* `align`: buffer size alignment (0 = default, 1 = no alignment) 
-
+* `audio_data`:\\[out\\] array to be filled with the pointer for each channel
+* `linesize`:\\[out\\] calculated linesize, may be NULL
+* `buf`: the pointer to a buffer containing the samples
+* `nb_channels`: the number of channels
+* `nb_samples`: the number of samples in a single channel
+* `sample_fmt`: the sample format
+* `align`: buffer size alignment (0 = default, 1 = no alignment)
 ### Returns
->=0 on success or a negative error code on failure 
-
+minimum size in bytes required for the buffer on success, or a negative error code on failure
 ### See also
 enum [`AVSampleFormat`](@ref) The documentation for [`AVSampleFormat`](@ref) describes the data layout.
 """
@@ -18431,22 +18935,17 @@ end
 
 Allocate a samples buffer for nb\\_samples samples, and fill data pointers and linesize accordingly. The allocated samples buffer can be freed by using [`av_freep`](@ref)(&audio\\_data[0]) Allocated data will be initialized to silence.
 
-\\todo return the size of the allocated buffer in case of success at the next bump 
+\\todo return the size of the allocated buffer in case of success at the next bump
 
 ### Parameters
-* `audio_data`:\\[out\\] array to be filled with the pointer for each channel 
-
-* `linesize`:\\[out\\] aligned size for audio buffer(s), may be NULL 
-
-* `nb_channels`: number of audio channels 
-
-* `nb_samples`: number of samples per channel 
-
-* `align`: buffer size alignment (0 = default, 1 = no alignment) 
-
+* `audio_data`:\\[out\\] array to be filled with the pointer for each channel
+* `linesize`:\\[out\\] aligned size for audio buffer(s), may be NULL
+* `nb_channels`: number of audio channels
+* `nb_samples`: number of samples per channel
+* `sample_fmt`: the sample format
+* `align`: buffer size alignment (0 = default, 1 = no alignment)
 ### Returns
->=0 on success or a negative error code on failure 
-
+>=0 on success or a negative error code on failure
 ### See also
 enum [`AVSampleFormat`](@ref) The documentation for [`AVSampleFormat`](@ref) describes the data layout., [`av_samples_fill_arrays`](@ref)(), [`av_samples_alloc_array_and_samples`](@ref)()
 """
@@ -18474,18 +18973,12 @@ end
 Copy samples from src to dst.
 
 ### Parameters
-* `dst`: destination array of pointers to data planes 
-
-* `src`: source array of pointers to data planes 
-
-* `dst_offset`: offset in samples at which the data will be written to dst 
-
-* `src_offset`: offset in samples at which the data will be read from src 
-
-* `nb_samples`: number of samples to be copied 
-
-* `nb_channels`: number of audio channels 
-
+* `dst`: destination array of pointers to data planes
+* `src`: source array of pointers to data planes
+* `dst_offset`: offset in samples at which the data will be written to dst
+* `src_offset`: offset in samples at which the data will be read from src
+* `nb_samples`: number of samples to be copied
+* `nb_channels`: number of audio channels
 * `sample_fmt`: audio sample format
 """
 function av_samples_copy(dst, src, dst_offset::Integer, src_offset::Integer, nb_samples::Integer, nb_channels::Integer, sample_fmt::AVSampleFormat)
@@ -18498,14 +18991,10 @@ end
 Fill an audio buffer with silence.
 
 ### Parameters
-* `audio_data`: array of pointers to data planes 
-
-* `offset`: offset in samples at which to start filling 
-
-* `nb_samples`: number of samples to fill 
-
-* `nb_channels`: number of audio channels 
-
+* `audio_data`: array of pointers to data planes
+* `offset`: offset in samples at which to start filling
+* `nb_samples`: number of samples to fill
+* `nb_channels`: number of audio channels
 * `sample_fmt`: audio sample format
 """
 function av_samples_set_silence(audio_data, offset::Integer, nb_samples::Integer, nb_channels::Integer, sample_fmt::AVSampleFormat)
@@ -18529,10 +19018,8 @@ end
 Initialize SHA-1 or SHA-2 hashing.
 
 ### Parameters
-* `context`: pointer to the function context (of size av\\_sha\\_size) 
-
-* `bits`: number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits) 
-
+* `context`: pointer to the function context (of size av\\_sha\\_size)
+* `bits`: number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)
 ### Returns
 zero if initialization succeeded, -1 otherwise
 """
@@ -18540,8 +19027,18 @@ function av_sha_init(context, bits::Integer)
     ccall((:av_sha_init, libavutil), Cint, (Ptr{AVSHA}, Cint), context, bits)
 end
 
-function av_sha_update(ctx, data, len::Integer)
-    ccall((:av_sha_update, libavutil), Cvoid, (Ptr{AVSHA}, Ptr{UInt8}, Cuint), ctx, data, len)
+"""
+    av_sha_update(ctx, data, len::Csize_t)
+
+Update hash value.
+
+### Parameters
+* `ctx`: hash function context
+* `data`: input data to update hash with
+* `len`: input data length
+"""
+function av_sha_update(ctx, data, len::Csize_t)
+    ccall((:av_sha_update, libavutil), Cvoid, (Ptr{AVSHA}, Ptr{UInt8}, Csize_t), ctx, data, len)
 end
 
 """
@@ -18550,8 +19047,7 @@ end
 Finish hashing and output digest value.
 
 ### Parameters
-* `context`: hash function context 
-
+* `context`: hash function context
 * `digest`: buffer where output digest value is stored
 """
 function av_sha_final(context, digest)
@@ -18575,10 +19071,8 @@ end
 Initialize SHA-2 512 hashing.
 
 ### Parameters
-* `context`: pointer to the function context (of size av\\_sha512\\_size) 
-
-* `bits`: number of bits in digest (224, 256, 384 or 512 bits) 
-
+* `context`: pointer to the function context (of size av\\_sha512\\_size)
+* `bits`: number of bits in digest (224, 256, 384 or 512 bits)
 ### Returns
 zero if initialization succeeded, -1 otherwise
 """
@@ -18586,8 +19080,18 @@ function av_sha512_init(context, bits::Integer)
     ccall((:av_sha512_init, libavutil), Cint, (Ptr{AVSHA512}, Cint), context, bits)
 end
 
-function av_sha512_update(context, data, len::Integer)
-    ccall((:av_sha512_update, libavutil), Cvoid, (Ptr{AVSHA512}, Ptr{UInt8}, Cuint), context, data, len)
+"""
+    av_sha512_update(context, data, len::Csize_t)
+
+Update hash value.
+
+### Parameters
+* `context`: hash function context
+* `data`: input data to update hash with
+* `len`: input data length
+"""
+function av_sha512_update(context, data, len::Csize_t)
+    ccall((:av_sha512_update, libavutil), Cvoid, (Ptr{AVSHA512}, Ptr{UInt8}, Csize_t), context, data, len)
 end
 
 """
@@ -18596,8 +19100,7 @@ end
 Finish hashing and output digest value.
 
 ### Parameters
-* `context`: hash function context 
-
+* `context`: hash function context
 * `digest`: buffer where output digest value is stored
 """
 function av_sha512_final(context, digest)
@@ -18653,18 +19156,12 @@ end
 Convert the bounding fields from an AVSphericalVideo from 0.32 fixed point to pixels.
 
 ### Parameters
-* `map`: The AVSphericalVideo map to read bound values from. 
-
-* `width`: Width of the current frame or stream. 
-
-* `height`: Height of the current frame or stream. 
-
-* `left`: Pixels from the left edge. 
-
-* `top`: Pixels from the top edge. 
-
-* `right`: Pixels from the right edge. 
-
+* `map`: The AVSphericalVideo map to read bound values from.
+* `width`: Width of the current frame or stream.
+* `height`: Height of the current frame or stream.
+* `left`: Pixels from the left edge.
+* `top`: Pixels from the top edge.
+* `right`: Pixels from the right edge.
 * `bottom`: Pixels from the bottom edge.
 """
 function av_spherical_tile_bounds(map, width::Csize_t, height::Csize_t, left, top, right, bottom)
@@ -18678,7 +19175,6 @@ Provide a human-readable name of a given [`AVSphericalProjection`](@ref).
 
 ### Parameters
 * `projection`: The input [`AVSphericalProjection`](@ref).
-
 ### Returns
 The name of the [`AVSphericalProjection`](@ref), or "unknown".
 """
@@ -18693,7 +19189,6 @@ Get the [`AVSphericalProjection`](@ref) form a human-readable name.
 
 ### Parameters
 * `name`: The input string.
-
 ### Returns
 The [`AVSphericalProjection`](@ref) value, or -1 if not found.
 """
@@ -18760,7 +19255,6 @@ Allocate a complete [`AVFrameSideData`](@ref) and add it to the frame.
 
 ### Parameters
 * `frame`: The frame which side data is added to.
-
 ### Returns
 The [`AVStereo3D`](@ref) structure to be filled by caller.
 """
@@ -18775,7 +19269,6 @@ Provide a human-readable name of a given stereo3d type.
 
 ### Parameters
 * `type`: The input stereo3d type value.
-
 ### Returns
 The name of the stereo3d value, or "unknown".
 """
@@ -18790,7 +19283,6 @@ Get the [`AVStereo3DType`](@ref) form a human-readable name.
 
 ### Parameters
 * `name`: The input string.
-
 ### Returns
 The [`AVStereo3DType`](@ref) value, or -1 if not found.
 """
@@ -18815,10 +19307,8 @@ end
 Initialize an [`AVTEA`](@ref) context.
 
 ### Parameters
-* `ctx`: an [`AVTEA`](@ref) context 
-
-* `key`: a key of 16 bytes used for encryption/decryption 
-
+* `ctx`: an [`AVTEA`](@ref) context
+* `key`: a key of 16 bytes used for encryption/decryption
 * `rounds`: the number of rounds in TEA (64 is the "standard")
 """
 function av_tea_init(ctx, key, rounds::Integer)
@@ -18831,16 +19321,11 @@ end
 Encrypt or decrypt a buffer using a previously initialized context.
 
 ### Parameters
-* `ctx`: an [`AVTEA`](@ref) context 
-
-* `dst`: destination array, can be equal to src 
-
-* `src`: source array, can be equal to dst 
-
-* `count`: number of 8 byte blocks 
-
-* `iv`: initialization vector for CBC mode, if NULL then ECB will be used 
-
+* `ctx`: an [`AVTEA`](@ref) context
+* `dst`: destination array, can be equal to src
+* `src`: source array, can be equal to dst
+* `count`: number of 8 byte blocks
+* `iv`: initialization vector for CBC mode, if NULL then ECB will be used
 * `decrypt`: 0 for encryption, 1 for decryption
 """
 function av_tea_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)
@@ -18858,12 +19343,9 @@ const AV_THREAD_MESSAGE_NONBLOCK = 1 % UInt32
 Allocate a new message queue.
 
 ### Parameters
-* `mq`: pointer to the message queue 
-
-* `nelem`: maximum number of elements in the queue 
-
-* `elsize`: size of each element in the queue 
-
+* `mq`: pointer to the message queue
+* `nelem`: maximum number of elements in the queue
+* `elsize`: size of each element in the queue
 ### Returns
 >=0 for success; <0 for error, in particular [`AVERROR`](@ref)(ENOSYS) if lavu was built without thread support
 """
@@ -18987,8 +19469,7 @@ end
 Sleep for a period of time. Although the duration is expressed in microseconds, the actual delay may be rounded to the precision of the system timer.
 
 ### Parameters
-* `usec`: Number of microseconds to sleep. 
-
+* `usec`: Number of microseconds to sleep.
 ### Returns
 zero on success or (negative) error code.
 """
@@ -19018,12 +19499,10 @@ Adjust frame number for NTSC drop frame time code.
     adjustment is only valid for multiples of NTSC 29.97
 
 ### Parameters
-* `framenum`: frame number to adjust 
-
-* `fps`: frame per second, multiples of 30 
-
+* `framenum`: frame number to adjust
+* `fps`: frame per second, multiples of 30
 ### Returns
-adjusted frame number 
+adjusted frame number
 """
 function av_timecode_adjust_ntsc_framenum2(framenum::Integer, fps::Integer)
     ccall((:av_timecode_adjust_ntsc_framenum2, libavutil), Cint, (Cint, Cint), framenum, fps)
@@ -19034,29 +19513,27 @@ end
 
 Convert frame number to SMPTE 12M binary representation.
 
-See SMPTE ST 314M-2005 Sec 4.4.2.2.1 "Time code pack (TC)" the format description as follows: bits 0-5: hours, in BCD(6bits) bits 6: BGF1 bits 7: BGF2 (NTSC) or FIELD (PAL) bits 8-14: minutes, in BCD(7bits) bits 15: BGF0 (NTSC) or BGF2 (PAL) bits 16-22: seconds, in BCD(7bits) bits 23: FIELD (NTSC) or BGF0 (PAL) bits 24-29: frames, in BCD(6bits) bits 30: drop frame flag (0: non drop, 1: drop) bits 31: color frame flag (0: unsync mode, 1: sync mode) 
+See SMPTE ST 314M-2005 Sec 4.4.2.2.1 "Time code pack (TC)" the format description as follows: bits 0-5: hours, in BCD(6bits) bits 6: BGF1 bits 7: BGF2 (NTSC) or FIELD (PAL) bits 8-14: minutes, in BCD(7bits) bits 15: BGF0 (NTSC) or BGF2 (PAL) bits 16-22: seconds, in BCD(7bits) bits 23: FIELD (NTSC) or BGF0 (PAL) bits 24-29: frames, in BCD(6bits) bits 30: drop frame flag (0: non drop, 1: drop) bits 31: color frame flag (0: unsync mode, 1: sync mode)
 
 !!! note
 
-    BCD numbers (6 or 7 bits): 4 or 5 lower bits for units, 2 higher bits for tens. 
+    BCD numbers (6 or 7 bits): 4 or 5 lower bits for units, 2 higher bits for tens.
 
 !!! note
 
-    Frame number adjustment is automatically done in case of drop timecode, you do NOT have to call [`av_timecode_adjust_ntsc_framenum2`](@ref)(). 
+    Frame number adjustment is automatically done in case of drop timecode, you do NOT have to call [`av_timecode_adjust_ntsc_framenum2`](@ref)().
 
 !!! note
 
-    The frame number is relative to tc->start. 
+    The frame number is relative to tc->start.
 
 !!! note
 
     Color frame (CF) and binary group flags (BGF) bits are set to zero.
 
 ### Parameters
-* `tc`: timecode data correctly initialized 
-
-* `framenum`: frame number 
-
+* `tc`: timecode data correctly initialized
+* `framenum`: frame number
 ### Returns
 the SMPTE binary representation
 """
@@ -19070,18 +19547,12 @@ end
 Convert sei info to SMPTE 12M binary representation.
 
 ### Parameters
-* `rate`: frame rate in rational form 
-
-* `drop`: drop flag 
-
-* `hh`: hour 
-
-* `mm`: minute 
-
-* `ss`: second 
-
-* `ff`: frame number 
-
+* `rate`: frame rate in rational form
+* `drop`: drop flag
+* `hh`: hour
+* `mm`: minute
+* `ss`: second
+* `ff`: frame number
 ### Returns
 the SMPTE binary representation
 """
@@ -19096,19 +19567,16 @@ Load timecode string in buf.
 
 !!! note
 
-    Timecode representation can be a negative timecode and have more than 24 hours, but will only be honored if the flags are correctly set. 
+    Timecode representation can be a negative timecode and have more than 24 hours, but will only be honored if the flags are correctly set.
 
 !!! note
 
     The frame number is relative to tc->start.
 
 ### Parameters
-* `buf`: destination buffer, must be at least [`AV_TIMECODE_STR_SIZE`](@ref) long 
-
-* `tc`: timecode data correctly initialized 
-
-* `framenum`: frame number 
-
+* `buf`: destination buffer, must be at least [`AV_TIMECODE_STR_SIZE`](@ref) long
+* `tc`: timecode data correctly initialized
+* `framenum`: frame number
 ### Returns
 the buf parameter
 """
@@ -19124,16 +19592,11 @@ Get the timecode string from the SMPTE timecode format.
 In contrast to [`av_timecode_make_smpte_tc_string`](@ref) this function supports 50/60 fps timecodes by using the field bit.
 
 ### Parameters
-* `buf`: destination buffer, must be at least [`AV_TIMECODE_STR_SIZE`](@ref) long 
-
-* `rate`: frame rate of the timecode 
-
-* `tcsmpte`: the 32-bit SMPTE timecode 
-
-* `prevent_df`: prevent the use of a drop flag when it is known the DF bit is arbitrary 
-
-* `skip_field`: prevent the use of a field flag when it is known the field bit is arbitrary (e.g. because it is used as PC flag) 
-
+* `buf`: destination buffer, must be at least [`AV_TIMECODE_STR_SIZE`](@ref) long
+* `rate`: frame rate of the timecode
+* `tcsmpte`: the 32-bit SMPTE timecode
+* `prevent_df`: prevent the use of a drop flag when it is known the DF bit is arbitrary
+* `skip_field`: prevent the use of a field flag when it is known the field bit is arbitrary (e.g. because it is used as PC flag)
 ### Returns
 the buf parameter
 """
@@ -19147,12 +19610,9 @@ end
 Get the timecode string from the SMPTE timecode format.
 
 ### Parameters
-* `buf`: destination buffer, must be at least [`AV_TIMECODE_STR_SIZE`](@ref) long 
-
-* `tcsmpte`: the 32-bit SMPTE timecode 
-
-* `prevent_df`: prevent the use of a drop flag when it is known the DF bit is arbitrary 
-
+* `buf`: destination buffer, must be at least [`AV_TIMECODE_STR_SIZE`](@ref) long
+* `tcsmpte`: the 32-bit SMPTE timecode
+* `prevent_df`: prevent the use of a drop flag when it is known the DF bit is arbitrary
 ### Returns
 the buf parameter
 """
@@ -19166,10 +19626,8 @@ end
 Get the timecode string from the 25-bit timecode format (MPEG GOP format).
 
 ### Parameters
-* `buf`: destination buffer, must be at least [`AV_TIMECODE_STR_SIZE`](@ref) long 
-
-* `tc25bit`: the 25-bits timecode 
-
+* `buf`: destination buffer, must be at least [`AV_TIMECODE_STR_SIZE`](@ref) long
+* `tc25bit`: the 25-bits timecode
 ### Returns
 the buf parameter
 """
@@ -19183,16 +19641,11 @@ end
 Init a timecode struct with the passed parameters.
 
 ### Parameters
-* `log_ctx`: a pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct (used for [`av_log`](@ref)) 
-
-* `tc`: pointer to an allocated [`AVTimecode`](@ref) 
-
-* `rate`: frame rate in rational form 
-
-* `flags`: miscellaneous flags such as drop frame, +24 hours, ... (see [`AVTimecodeFlag`](@ref)) 
-
-* `frame_start`: the first frame number 
-
+* `log_ctx`: a pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct (used for [`av_log`](@ref))
+* `tc`: pointer to an allocated [`AVTimecode`](@ref)
+* `rate`: frame rate in rational form
+* `flags`: miscellaneous flags such as drop frame, +24 hours, ... (see [`AVTimecodeFlag`](@ref))
+* `frame_start`: the first frame number
 ### Returns
 0 on success, [`AVERROR`](@ref) otherwise
 """
@@ -19206,22 +19659,14 @@ end
 Init a timecode struct from the passed timecode components.
 
 ### Parameters
-* `log_ctx`: a pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct (used for [`av_log`](@ref)) 
-
-* `tc`: pointer to an allocated [`AVTimecode`](@ref) 
-
-* `rate`: frame rate in rational form 
-
-* `flags`: miscellaneous flags such as drop frame, +24 hours, ... (see [`AVTimecodeFlag`](@ref)) 
-
-* `hh`: hours 
-
-* `mm`: minutes 
-
-* `ss`: seconds 
-
-* `ff`: frames 
-
+* `log_ctx`: a pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct (used for [`av_log`](@ref))
+* `tc`: pointer to an allocated [`AVTimecode`](@ref)
+* `rate`: frame rate in rational form
+* `flags`: miscellaneous flags such as drop frame, +24 hours, ... (see [`AVTimecodeFlag`](@ref))
+* `hh`: hours
+* `mm`: minutes
+* `ss`: seconds
+* `ff`: frames
 ### Returns
 0 on success, [`AVERROR`](@ref) otherwise
 """
@@ -19232,17 +19677,13 @@ end
 """
     av_timecode_init_from_string(tc, rate::AVRational, str, log_ctx)
 
-Parse timecode representation (hh:mm:ss[:;.]ff).
-
-### Parameters
-* `log_ctx`: a pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct (used for [`av_log`](@ref)). 
-
-* `tc`: pointer to an allocated [`AVTimecode`](@ref) 
-
-* `rate`: frame rate in rational form 
-
-* `str`: timecode string which will determine the frame start 
+Parse timecode representation (hh:mm:ss[:;.]ff).
 
+### Parameters
+* `log_ctx`: a pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct (used for [`av_log`](@ref)).
+* `tc`: pointer to an allocated [`AVTimecode`](@ref)
+* `rate`: frame rate in rational form
+* `str`: timecode string which will determine the frame start
 ### Returns
 0 on success, [`AVERROR`](@ref) otherwise
 """
@@ -19268,10 +19709,8 @@ end
 Fill the provided buffer with a string containing a timestamp representation.
 
 ### Parameters
-* `buf`: a buffer with size in bytes of at least [`AV_TS_MAX_STRING_SIZE`](@ref) 
-
-* `ts`: the timestamp to represent 
-
+* `buf`: a buffer with size in bytes of at least [`AV_TS_MAX_STRING_SIZE`](@ref)
+* `ts`: the timestamp to represent
 ### Returns
 the buffer in input
 """
@@ -19285,12 +19724,9 @@ end
 Fill the provided buffer with a string containing a timestamp time representation.
 
 ### Parameters
-* `buf`: a buffer with size in bytes of at least [`AV_TS_MAX_STRING_SIZE`](@ref) 
-
-* `ts`: the timestamp to represent 
-
-* `tb`: the timebase of the timestamp 
-
+* `buf`: a buffer with size in bytes of at least [`AV_TS_MAX_STRING_SIZE`](@ref)
+* `ts`: the timestamp to represent
+* `tb`: the timebase of the timestamp
 ### Returns
 the buffer in input
 """
@@ -19321,15 +19757,12 @@ end
 """
     av_tree_find(root, key, cmp, next)
 
-Find an element. 
+Find an element.
 
 ### Parameters
-* `root`: a pointer to the root node of the tree 
-
-* `next`: If next is not NULL, then next[0] will contain the previous element and next[1] the next element. If either does not exist, then the corresponding entry in next is unchanged. 
-
-* `cmp`: compare function used to compare elements in the tree, API identical to that of Standard C's qsort It is guaranteed that the first and only the first argument to cmp() will be the key parameter to [`av_tree_find`](@ref)(), thus it could if the user wants, be a different type (like an opaque context). 
-
+* `root`: a pointer to the root node of the tree
+* `next`: If next is not NULL, then next[0] will contain the previous element and next[1] the next element. If either does not exist, then the corresponding entry in next is unchanged.
+* `cmp`: compare function used to compare elements in the tree, API identical to that of Standard C's qsort It is guaranteed that the first and only the first argument to cmp() will be the key parameter to [`av_tree_find`](@ref)(), thus it could if the user wants, be a different type (like an opaque context).
 ### Returns
 An element with cmp(key, elem) == 0 or NULL if no such element exists in the tree.
 """
@@ -19362,14 +19795,10 @@ If *next is NULL, then the supplied element will be removed if it exists. If *ne
 ```
 
 ### Parameters
-* `rootp`: A pointer to a pointer to the root node of the tree; note that the root node can change during insertions, this is required to keep the tree balanced. 
-
-* `key`: pointer to the element key to insert in the tree 
-
-* `next`: Used to allocate and free AVTreeNodes. For insertion the user must set it to an allocated and zeroed object of at least av\\_tree\\_node\\_size bytes size. [`av_tree_insert`](@ref)() will set it to NULL if it has been consumed. For deleting elements *next is set to NULL by the user and [`av_tree_insert`](@ref)() will set it to the [`AVTreeNode`](@ref) which was used for the removed element. This allows the use of flat arrays, which have lower overhead compared to many malloced elements. You might want to define a function like: 
-
-* `cmp`: compare function used to compare elements in the tree, API identical to that of Standard C's qsort 
-
+* `rootp`: A pointer to a pointer to the root node of the tree; note that the root node can change during insertions, this is required to keep the tree balanced.
+* `key`: pointer to the element key to insert in the tree
+* `next`: Used to allocate and free AVTreeNodes. For insertion the user must set it to an allocated and zeroed object of at least av\\_tree\\_node\\_size bytes size. [`av_tree_insert`](@ref)() will set it to NULL if it has been consumed. For deleting elements *next is set to NULL by the user and [`av_tree_insert`](@ref)() will set it to the [`AVTreeNode`](@ref) which was used for the removed element. This allows the use of flat arrays, which have lower overhead compared to many malloced elements. You might want to define a function like:
+* `cmp`: compare function used to compare elements in the tree, API identical to that of Standard C's qsort
 ### Returns
 If no insertion happened, the found element; if an insertion or removal happened, then either key or NULL will be returned. Which one it is depends on the tree state and the implementation. You should make no assumptions that it's one or the other in the code.
 """
@@ -19414,10 +19843,8 @@ end
 Initialize an [`AVTWOFISH`](@ref) context.
 
 ### Parameters
-* `ctx`: an [`AVTWOFISH`](@ref) context 
-
-* `key`: a key of size ranging from 1 to 32 bytes used for encryption/decryption 
-
+* `ctx`: an [`AVTWOFISH`](@ref) context
+* `key`: a key of size ranging from 1 to 32 bytes used for encryption/decryption
 * `key_bits`: number of keybits: 128, 192, 256 If less than the required, padded with zeroes to nearest valid value; return value is 0 if key\\_bits is 128/192/256, -1 if less than 0, 1 otherwise
 """
 function av_twofish_init(ctx, key, key_bits::Integer)
@@ -19430,16 +19857,11 @@ end
 Encrypt or decrypt a buffer using a previously initialized context
 
 ### Parameters
-* `ctx`: an [`AVTWOFISH`](@ref) context 
-
-* `dst`: destination array, can be equal to src 
-
-* `src`: source array, can be equal to dst 
-
-* `count`: number of 16 byte blocks 
-
-* `iv`: initialization vector for CBC mode, NULL for ECB mode 
-
+* `ctx`: an [`AVTWOFISH`](@ref) context
+* `dst`: destination array, can be equal to src
+* `src`: source array, can be equal to dst
+* `count`: number of 16 byte blocks
+* `iv`: initialization vector for CBC mode, NULL for ECB mode
 * `decrypt`: 0 for encryption, 1 for decryption
 """
 function av_twofish_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)
@@ -19465,11 +19887,24 @@ end
 
 const AVTXType = UInt32
 const AV_TX_FLOAT_FFT = 0 % UInt32
-const AV_TX_FLOAT_MDCT = 1 % UInt32
 const AV_TX_DOUBLE_FFT = 2 % UInt32
-const AV_TX_DOUBLE_MDCT = 3 % UInt32
 const AV_TX_INT32_FFT = 4 % UInt32
+const AV_TX_FLOAT_MDCT = 1 % UInt32
+const AV_TX_DOUBLE_MDCT = 3 % UInt32
 const AV_TX_INT32_MDCT = 5 % UInt32
+const AV_TX_FLOAT_RDFT = 6 % UInt32
+const AV_TX_DOUBLE_RDFT = 7 % UInt32
+const AV_TX_INT32_RDFT = 8 % UInt32
+const AV_TX_FLOAT_DCT = 9 % UInt32
+const AV_TX_DOUBLE_DCT = 10 % UInt32
+const AV_TX_INT32_DCT = 11 % UInt32
+const AV_TX_FLOAT_DCT_I = 12 % UInt32
+const AV_TX_DOUBLE_DCT_I = 13 % UInt32
+const AV_TX_INT32_DCT_I = 14 % UInt32
+const AV_TX_FLOAT_DST_I = 15 % UInt32
+const AV_TX_DOUBLE_DST_I = 16 % UInt32
+const AV_TX_INT32_DST_I = 17 % UInt32
+const AV_TX_NB = 18 % UInt32
 
 # typedef void ( * av_tx_fn ) ( AVTXContext * s , void * out , void * in , ptrdiff_t stride )
 """
@@ -19479,15 +19914,12 @@ Function pointer to a function to perform the transform.
 
     Using a different context than the one allocated during [`av_tx_init`](@ref)() is not allowed.
 
-The out and in arrays must be aligned to the maximum required by the CPU architecture. The stride must follow the constraints the transform type has specified.
+The out and in arrays must be aligned to the maximum required by the CPU architecture unless the AV\\_TX\\_UNALIGNED flag was set in [`av_tx_init`](@ref)(). The stride must follow the constraints the transform type has specified.
 
 ### Parameters
-* `s`: the transform context 
-
-* `out`: the output array 
-
-* `in`: the input array 
-
+* `s`: the transform context
+* `out`: the output array
+* `in`: the input array
 * `stride`: the input or output stride in bytes
 """
 const av_tx_fn = Ptr{Cvoid}
@@ -19499,6 +19931,10 @@ Flags for [`av_tx_init`](@ref)()
 """
 const AVTXFlags = UInt32
 const AV_TX_INPLACE = 1 % UInt32
+const AV_TX_UNALIGNED = 2 % UInt32
+const AV_TX_FULL_IMDCT = 4 % UInt32
+const AV_TX_REAL_TO_REAL = 8 % UInt32
+const AV_TX_REAL_TO_IMAGINARY = 16 % UInt32
 
 """
     av_tx_init(ctx, tx, type::AVTXType, inv::Integer, len::Integer, scale, flags::UInt64)
@@ -19506,20 +19942,13 @@ const AV_TX_INPLACE = 1 % UInt32
 Initialize a transform context with the given configuration (i)MDCTs with an odd length are currently not supported.
 
 ### Parameters
-* `ctx`: the context to allocate, will be NULL on error 
-
-* `tx`: pointer to the transform function pointer to set 
-
-* `type`: type the type of transform 
-
-* `inv`: whether to do an inverse or a forward transform 
-
-* `len`: the size of the transform in samples 
-
-* `scale`: pointer to the value to scale the output if supported by type 
-
+* `ctx`: the context to allocate, will be NULL on error
+* `tx`: pointer to the transform function pointer to set
+* `type`: type the type of transform
+* `inv`: whether to do an inverse or a forward transform
+* `len`: the size of the transform in samples
+* `scale`: pointer to the value to scale the output if supported by type
 * `flags`: a bitmask of [`AVTXFlags`](@ref) or 0
-
 ### Returns
 0 on success, negative error code on failure
 """
@@ -19530,12 +19959,117 @@ end
 """
     av_tx_uninit(ctx)
 
-Frees a context and sets ctx to NULL, does nothing when ctx == NULL
+Frees a context and sets *ctx to NULL, does nothing when *ctx == NULL.
 """
 function av_tx_uninit(ctx)
     ccall((:av_tx_uninit, libavutil), Cvoid, (Ptr{Ptr{AVTXContext}},), ctx)
 end
 
+const AVUUID = NTuple{16, UInt8}
+
+"""
+    av_uuid_parse(in, uu)
+
+Parses a string representation of a UUID formatted according to IETF RFC 4122 into an [`AVUUID`](@ref). The parsing is case-insensitive. The string must be 37 characters long, including the terminating NUL character.
+
+Example string representation: "2fceebd0-7017-433d-bafb-d073a7116696"
+
+### Parameters
+* `in`:\\[in\\] String representation of a UUID, e.g. 2fceebd0-7017-433d-bafb-d073a7116696
+* `uu`:\\[out\\] [`AVUUID`](@ref)
+### Returns
+A non-zero value in case of an error.
+"""
+function av_uuid_parse(in, uu)
+    ccall((:av_uuid_parse, libavutil), Cint, (Cstring, Ptr{Cuchar}), in, uu)
+end
+
+"""
+    av_uuid_urn_parse(in, uu)
+
+Parses a URN representation of a UUID, as specified at IETF RFC 4122, into an [`AVUUID`](@ref). The parsing is case-insensitive. The string must be 46 characters long, including the terminating NUL character.
+
+Example string representation: "urn:uuid:2fceebd0-7017-433d-bafb-d073a7116696"
+
+### Parameters
+* `in`:\\[in\\] URN UUID
+* `uu`:\\[out\\] [`AVUUID`](@ref)
+### Returns
+A non-zero value in case of an error.
+"""
+function av_uuid_urn_parse(in, uu)
+    ccall((:av_uuid_urn_parse, libavutil), Cint, (Cstring, Ptr{Cuchar}), in, uu)
+end
+
+"""
+    av_uuid_parse_range(in_start, in_end, uu)
+
+Parses a string representation of a UUID formatted according to IETF RFC 4122 into an [`AVUUID`](@ref). The parsing is case-insensitive.
+
+### Parameters
+* `in_start`:\\[in\\] Pointer to the first character of the string representation
+* `in_end`:\\[in\\] Pointer to the character after the last character of the string representation. That memory location is never accessed. It is an error if `in\\_end - in\\_start != 36`.
+* `uu`:\\[out\\] [`AVUUID`](@ref)
+### Returns
+A non-zero value in case of an error.
+"""
+function av_uuid_parse_range(in_start, in_end, uu)
+    ccall((:av_uuid_parse_range, libavutil), Cint, (Cstring, Cstring, Ptr{Cuchar}), in_start, in_end, uu)
+end
+
+"""
+    av_uuid_unparse(uu, out)
+
+Serializes a [`AVUUID`](@ref) into a string representation according to IETF RFC 4122. The string is lowercase and always 37 characters long, including the terminating NUL character.
+
+### Parameters
+* `uu`:\\[in\\] [`AVUUID`](@ref)
+* `out`:\\[out\\] Pointer to an array of no less than 37 characters.
+"""
+function av_uuid_unparse(uu, out)
+    ccall((:av_uuid_unparse, libavutil), Cvoid, (Ptr{Cuchar}, Cstring), uu, out)
+end
+
+"""
+    av_uuid_equal(uu1, uu2)
+
+Compares two UUIDs for equality.
+
+### Parameters
+* `uu1`:\\[in\\] [`AVUUID`](@ref)
+* `uu2`:\\[in\\] [`AVUUID`](@ref)
+### Returns
+Nonzero if uu1 and uu2 are identical, 0 otherwise
+"""
+function av_uuid_equal(uu1, uu2)
+    ccall((:av_uuid_equal, libavutil), Cint, (Ptr{Cuchar}, Ptr{Cuchar}), uu1, uu2)
+end
+
+"""
+    av_uuid_copy(dest, src)
+
+Copies the bytes of src into dest.
+
+### Parameters
+* `dest`:\\[out\\] [`AVUUID`](@ref)
+* `src`:\\[in\\] [`AVUUID`](@ref)
+"""
+function av_uuid_copy(dest, src)
+    ccall((:av_uuid_copy, libavutil), Cvoid, (Ptr{Cuchar}, Ptr{Cuchar}), dest, src)
+end
+
+"""
+    av_uuid_nil(uu)
+
+Sets a UUID to the nil UUID, i.e. a UUID with have all its 128 bits set to zero.
+
+### Parameters
+* `uu`:\\[in,out\\] UUID to be set to the nil UUID
+"""
+function av_uuid_nil(uu)
+    ccall((:av_uuid_nil, libavutil), Cvoid, (Ptr{Cuchar},), uu)
+end
+
 const AVVideoEncParamsType = Int32
 const AV_VIDEO_ENC_PARAMS_NONE = -1 % Int32
 const AV_VIDEO_ENC_PARAMS_VP9 = 0 % Int32
@@ -19571,6 +20105,17 @@ struct AVVideoBlockParams
     delta_qp::Int32
 end
 
+"""
+    av_video_enc_params_block(par, idx::Integer)
+
+Get the block at the specified {
+
+```c++
+ idx}. Must be between 0 and nb_blocks - 1.
+ 
+
+```
+"""
 function av_video_enc_params_block(par, idx::Integer)
     ccall((:av_video_enc_params_block, libavutil), Ptr{AVVideoBlockParams}, (Ptr{AVVideoEncParams}, Cuint), par, idx)
 end
@@ -19610,12 +20155,132 @@ function av_video_enc_params_create_side_data(frame, type::AVVideoEncParamsType,
     ccall((:av_video_enc_params_create_side_data, libavutil), Ptr{AVVideoEncParams}, (Ptr{AVFrame}, AVVideoEncParamsType, Cuint), frame, type, nb_blocks)
 end
 
+struct AVVideoRect
+    x::UInt32
+    y::UInt32
+    width::UInt32
+    height::UInt32
+end
+
+const AVVideoHintType = UInt32
+const AV_VIDEO_HINT_TYPE_CONSTANT = 0 % UInt32
+const AV_VIDEO_HINT_TYPE_CHANGED = 1 % UInt32
+
+struct AVVideoHint
+    nb_rects::Csize_t
+    rect_offset::Csize_t
+    rect_size::Csize_t
+    type::AVVideoHintType
+end
+
+function av_video_hint_rects(hints)
+    ccall((:av_video_hint_rects, libavutil), Ptr{AVVideoRect}, (Ptr{AVVideoHint},), hints)
+end
+
+function av_video_hint_get_rect(hints, idx::Csize_t)
+    ccall((:av_video_hint_get_rect, libavutil), Ptr{AVVideoRect}, (Ptr{AVVideoHint}, Csize_t), hints, idx)
+end
+
 """
-    AVXTEA
+    av_video_hint_alloc(nb_rects::Csize_t, out_size)
+
+Allocate memory for the [`AVVideoHint`](@ref) struct along with an nb\\_rects-sized arrays of [`AVVideoRect`](@ref).
+
+The side data contains a list of rectangles for the portions of the frame which changed from the last encoded one (and the remainder are assumed to be changed), or, alternately (depending on the type parameter) the unchanged ones (and the remanining ones are those which changed). Macroblocks will thus be hinted either to be P\\_SKIP-ped or go through the regular encoding procedure.
+
+It's responsibility of the caller to fill the AVRects accordingly, and to set the proper [`AVVideoHintType`](@ref) field.
 
+### Parameters
+* `out_size`: if non-NULL, the size in bytes of the resulting data array is written here
+### Returns
+newly allocated [`AVVideoHint`](@ref) struct (must be freed by the caller using [`av_free`](@ref)()) on success, NULL on memory allocation failure
+"""
+function av_video_hint_alloc(nb_rects::Csize_t, out_size)
+    ccall((:av_video_hint_alloc, libavutil), Ptr{AVVideoHint}, (Csize_t, Ptr{Csize_t}), nb_rects, out_size)
+end
+
+"""
+    av_video_hint_create_side_data(frame, nb_rects::Csize_t)
+
+Same as [`av_video_hint_alloc`](@ref)(), except newly-allocated [`AVVideoHint`](@ref) is attached as side data of type AV\\_FRAME\\_DATA\\_VIDEO\\_HINT\\_INFO to frame.
+"""
+function av_video_hint_create_side_data(frame, nb_rects::Csize_t)
+    ccall((:av_video_hint_create_side_data, libavutil), Ptr{AVVideoHint}, (Ptr{AVFrame}, Csize_t), frame, nb_rects)
+end
 
+"""
+    AVXTEA
 
-Public header for libavutil XTEA algorithm 
+`
+ * @brief Public header for libavutil XTEA algorithm
+ * @defgroup lavu_xtea XTEA
+ * @ingroup lavu_crypto
+ * @{
+ */
+
+typedef struct AVXTEA {
+    uint32_t key[16];
+} AVXTEA;
+
+/**
+ * Allocate an AVXTEA context.
+ */
+AVXTEA *av_xtea_alloc(void);
+
+/**
+ * Initialize an AVXTEA context.
+ *
+ * @param ctx an AVXTEA context
+ * @param key a key of 16 bytes used for encryption/decryption,
+ *            interpreted as big endian 32 bit numbers
+ */
+void av_xtea_init(struct AVXTEA *ctx, const uint8_t key[16]);
+
+/**
+ * Initialize an AVXTEA context.
+ *
+ * @param ctx an AVXTEA context
+ * @param key a key of 16 bytes used for encryption/decryption,
+ *            interpreted as little endian 32 bit numbers
+ */
+void av_xtea_le_init(struct AVXTEA *ctx, const uint8_t key[16]);
+
+/**
+ * Encrypt or decrypt a buffer using a previously initialized context,
+ * in big endian format.
+ *
+ * @param ctx an AVXTEA context
+ * @param dst destination array, can be equal to src
+ * @param src source array, can be equal to dst
+ * @param count number of 8 byte blocks
+ * @param iv initialization vector for CBC mode, if NULL then ECB will be used
+ * @param decrypt 0 for encryption, 1 for decryption
+ */
+void av_xtea_crypt(struct AVXTEA *ctx, uint8_t *dst, const uint8_t *src,
+                   int count, uint8_t *iv, int decrypt);
+
+/**
+ * Encrypt or decrypt a buffer using a previously initialized context,
+ * in little endian format.
+ *
+ * @param ctx an AVXTEA context
+ * @param dst destination array, can be equal to src
+ * @param src source array, can be equal to dst
+ * @param count number of 8 byte blocks
+ * @param iv initialization vector for CBC mode, if NULL then ECB will be used
+ * @param decrypt 0 for encryption, 1 for decryption
+ */
+void av_xtea_le_crypt(struct AVXTEA *ctx, uint8_t *dst, const uint8_t *src,
+                      int count, uint8_t *iv, int decrypt);
+
+/**
+ * @}
+ */
+
+#endif /* AVUTIL_XTEA_H */
+`
+
+Public header for libavutil XTEA algorithm
 
 ` lavu_xtea XTEA`
 
@@ -19642,8 +20307,7 @@ end
 Initialize an [`AVXTEA`](@ref) context.
 
 ### Parameters
-* `ctx`: an [`AVXTEA`](@ref) context 
-
+* `ctx`: an [`AVXTEA`](@ref) context
 * `key`: a key of 16 bytes used for encryption/decryption, interpreted as big endian 32 bit numbers
 """
 function av_xtea_init(ctx, key)
@@ -19656,8 +20320,7 @@ end
 Initialize an [`AVXTEA`](@ref) context.
 
 ### Parameters
-* `ctx`: an [`AVXTEA`](@ref) context 
-
+* `ctx`: an [`AVXTEA`](@ref) context
 * `key`: a key of 16 bytes used for encryption/decryption, interpreted as little endian 32 bit numbers
 """
 function av_xtea_le_init(ctx, key)
@@ -19670,16 +20333,11 @@ end
 Encrypt or decrypt a buffer using a previously initialized context, in big endian format.
 
 ### Parameters
-* `ctx`: an [`AVXTEA`](@ref) context 
-
-* `dst`: destination array, can be equal to src 
-
-* `src`: source array, can be equal to dst 
-
-* `count`: number of 8 byte blocks 
-
-* `iv`: initialization vector for CBC mode, if NULL then ECB will be used 
-
+* `ctx`: an [`AVXTEA`](@ref) context
+* `dst`: destination array, can be equal to src
+* `src`: source array, can be equal to dst
+* `count`: number of 8 byte blocks
+* `iv`: initialization vector for CBC mode, if NULL then ECB will be used
 * `decrypt`: 0 for encryption, 1 for decryption
 """
 function av_xtea_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)
@@ -19692,16 +20350,11 @@ end
 Encrypt or decrypt a buffer using a previously initialized context, in little endian format.
 
 ### Parameters
-* `ctx`: an [`AVXTEA`](@ref) context 
-
-* `dst`: destination array, can be equal to src 
-
-* `src`: source array, can be equal to dst 
-
-* `count`: number of 8 byte blocks 
-
-* `iv`: initialization vector for CBC mode, if NULL then ECB will be used 
-
+* `ctx`: an [`AVXTEA`](@ref) context
+* `dst`: destination array, can be equal to src
+* `src`: source array, can be equal to dst
+* `count`: number of 8 byte blocks
+* `iv`: initialization vector for CBC mode, if NULL then ECB will be used
 * `decrypt`: 0 for encryption, 1 for decryption
 """
 function av_xtea_le_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)
@@ -19789,8 +20442,7 @@ end
     sws_isSupportedEndiannessConversion(pix_fmt::AVPixelFormat)
 
 ### Parameters
-* `pix_fmt`:\\[in\\] the pixel format 
-
+* `pix_fmt`:\\[in\\] the pixel format
 ### Returns
 a positive value if an endianness conversion for pix\\_fmt is supported, 0 otherwise.
 """
@@ -19838,24 +20490,16 @@ Allocate and return an [`SwsContext`](@ref). You need it to perform scaling/conv
     this function is to be removed after a saner alternative is written
 
 ### Parameters
-* `srcW`: the width of the source image 
-
-* `srcH`: the height of the source image 
-
-* `srcFormat`: the source image format 
-
-* `dstW`: the width of the destination image 
-
-* `dstH`: the height of the destination image 
-
-* `dstFormat`: the destination image format 
-
-* `flags`: specify which algorithm and options to use for rescaling 
-
-* `param`: extra parameters to tune the used scaler For [`SWS_BICUBIC`](@ref) param[0] and [1] tune the shape of the basis function, param[0] tunes f(1) and param[1] f´(1) For [`SWS_GAUSS`](@ref) param[0] tunes the exponent and thus cutoff frequency For [`SWS_LANCZOS`](@ref) param[0] tunes the width of the window function 
-
+* `srcW`: the width of the source image
+* `srcH`: the height of the source image
+* `srcFormat`: the source image format
+* `dstW`: the width of the destination image
+* `dstH`: the height of the destination image
+* `dstFormat`: the destination image format
+* `flags`: specify which algorithm and options to use for rescaling
+* `param`: extra parameters to tune the used scaler For [`SWS_BICUBIC`](@ref) param[0] and [1] tune the shape of the basis function, param[0] tunes f(1) and param[1] f´(1) For [`SWS_GAUSS`](@ref) param[0] tunes the exponent and thus cutoff frequency For [`SWS_LANCZOS`](@ref) param[0] tunes the width of the window function
 ### Returns
-a pointer to an allocated context, or NULL in case of error 
+a pointer to an allocated context, or NULL in case of error
 """
 function sws_getContext(srcW::Integer, srcH::Integer, srcFormat::AVPixelFormat, dstW::Integer, dstH::Integer, dstFormat::AVPixelFormat, flags::Integer, srcFilter, dstFilter, param)
     ccall((:sws_getContext, libswscale), Ptr{SwsContext}, (Cint, Cint, AVPixelFormat, Cint, Cint, AVPixelFormat, Cint, Ptr{SwsFilter}, Ptr{SwsFilter}, Ptr{Cdouble}), srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param)
@@ -19869,47 +20513,134 @@ Scale the image slice in srcSlice and put the resulting scaled slice in the imag
 Slices have to be provided in sequential order, either in top-bottom or bottom-top order. If slices are provided in non-sequential order the behavior of the function is undefined.
 
 ### Parameters
-* `c`: the scaling context previously created with [`sws_getContext`](@ref)() 
+* `c`: the scaling context previously created with [`sws_getContext`](@ref)()
+* `srcSlice`: the array containing the pointers to the planes of the source slice
+* `srcStride`: the array containing the strides for each plane of the source image
+* `srcSliceY`: the position in the source image of the slice to process, that is the number (counted starting from zero) in the image of the first row of the slice
+* `srcSliceH`: the height of the source slice, that is the number of rows in the slice
+* `dst`: the array containing the pointers to the planes of the destination image
+* `dstStride`: the array containing the strides for each plane of the destination image
+### Returns
+the height of the output slice
+"""
+function sws_scale(c, srcSlice, srcStride, srcSliceY::Integer, srcSliceH::Integer, dst, dstStride)
+    ccall((:sws_scale, libswscale), Cint, (Ptr{SwsContext}, Ptr{Ptr{UInt8}}, Ptr{Cint}, Cint, Cint, Ptr{Ptr{UInt8}}, Ptr{Cint}), c, srcSlice, srcStride, srcSliceY, srcSliceH, dst, dstStride)
+end
+
+"""
+    sws_scale_frame(c, dst, src)
+
+Scale source data from src and write the output to dst.
 
-* `srcSlice`: the array containing the pointers to the planes of the source slice 
+This is merely a convenience wrapper around - [`sws_frame_start`](@ref)() - [`sws_send_slice`](@ref)(0, src->height) - [`sws_receive_slice`](@ref)(0, dst->height) - [`sws_frame_end`](@ref)()
+
+### Parameters
+* `c`: The scaling context
+* `dst`: The destination frame. See documentation for [`sws_frame_start`](@ref)() for more details.
+* `src`: The source frame.
+### Returns
+0 on success, a negative [`AVERROR`](@ref) code on failure
+"""
+function sws_scale_frame(c, dst, src)
+    ccall((:sws_scale_frame, libswscale), Cint, (Ptr{SwsContext}, Ptr{AVFrame}, Ptr{AVFrame}), c, dst, src)
+end
 
-* `srcStride`: the array containing the strides for each plane of the source image 
+"""
+    sws_frame_start(c, dst, src)
 
-* `srcSliceY`: the position in the source image of the slice to process, that is the number (counted starting from zero) in the image of the first row of the slice 
+Initialize the scaling process for a given pair of source/destination frames. Must be called before any calls to [`sws_send_slice`](@ref)() and [`sws_receive_slice`](@ref)().
 
-* `srcSliceH`: the height of the source slice, that is the number of rows in the slice 
+This function will retain references to src and dst, so they must both use refcounted buffers (if allocated by the caller, in case of dst).
 
-* `dst`: the array containing the pointers to the planes of the destination image 
+The data buffers may either be already allocated by the caller or left clear, in which case they will be allocated by the scaler. The latter may have performance advantages - e.g. in certain cases some output planes may be references to input planes, rather than copies.
 
-* `dstStride`: the array containing the strides for each plane of the destination image 
+Output data will be written into this frame in successful [`sws_receive_slice`](@ref)() calls.
 
+### Parameters
+* `c`: The scaling context
+* `dst`: The destination frame.
+* `src`: The source frame. The data buffers must be allocated, but the frame data does not have to be ready at this point. Data availability is then signalled by [`sws_send_slice`](@ref)().
 ### Returns
-the height of the output slice
+0 on success, a negative [`AVERROR`](@ref) code on failure
+### See also
+[`sws_frame_end`](@ref)()
 """
-function sws_scale(c, srcSlice, srcStride, srcSliceY::Integer, srcSliceH::Integer, dst, dstStride)
-    ccall((:sws_scale, libswscale), Cint, (Ptr{SwsContext}, Ptr{Ptr{UInt8}}, Ptr{Cint}, Cint, Cint, Ptr{Ptr{UInt8}}, Ptr{Cint}), c, srcSlice, srcStride, srcSliceY, srcSliceH, dst, dstStride)
+function sws_frame_start(c, dst, src)
+    ccall((:sws_frame_start, libswscale), Cint, (Ptr{SwsContext}, Ptr{AVFrame}, Ptr{AVFrame}), c, dst, src)
 end
 
 """
-    sws_setColorspaceDetails(c, inv_table, srcRange::Integer, table, dstRange::Integer, brightness::Integer, contrast::Integer, saturation::Integer)
+    sws_frame_end(c)
+
+Finish the scaling process for a pair of source/destination frames previously submitted with [`sws_frame_start`](@ref)(). Must be called after all [`sws_send_slice`](@ref)() and [`sws_receive_slice`](@ref)() calls are done, before any new [`sws_frame_start`](@ref)() calls.
+
+### Parameters
+* `c`: The scaling context
+"""
+function sws_frame_end(c)
+    ccall((:sws_frame_end, libswscale), Cvoid, (Ptr{SwsContext},), c)
+end
+
+"""
+    sws_send_slice(c, slice_start::Integer, slice_height::Integer)
+
+Indicate that a horizontal slice of input data is available in the source frame previously provided to [`sws_frame_start`](@ref)(). The slices may be provided in any order, but may not overlap. For vertically subsampled pixel formats, the slices must be aligned according to subsampling.
 
 ### Parameters
-* `dstRange`: flag indicating the while-black range of the output (1=jpeg / 0=mpeg) 
+* `c`: The scaling context
+* `slice_start`: first row of the slice
+* `slice_height`: number of rows in the slice
+### Returns
+a non-negative number on success, a negative [`AVERROR`](@ref) code on failure.
+"""
+function sws_send_slice(c, slice_start::Integer, slice_height::Integer)
+    ccall((:sws_send_slice, libswscale), Cint, (Ptr{SwsContext}, Cuint, Cuint), c, slice_start, slice_height)
+end
+
+"""
+    sws_receive_slice(c, slice_start::Integer, slice_height::Integer)
 
-* `srcRange`: flag indicating the while-black range of the input (1=jpeg / 0=mpeg) 
+Request a horizontal slice of the output data to be written into the frame previously provided to [`sws_frame_start`](@ref)().
 
-* `table`: the yuv2rgb coefficients describing the output yuv space, normally ff\\_yuv2rgb\\_coeffs[x] 
+### Parameters
+* `c`: The scaling context
+* `slice_start`: first row of the slice; must be a multiple of [`sws_receive_slice_alignment`](@ref)()
+* `slice_height`: number of rows in the slice; must be a multiple of [`sws_receive_slice_alignment`](@ref)(), except for the last slice (i.e. when slice\\_start+slice\\_height is equal to output frame height)
+### Returns
+a non-negative number if the data was successfully written into the output [`AVERROR`](@ref)(EAGAIN) if more input data needs to be provided before the output can be produced another negative [`AVERROR`](@ref) code on other kinds of scaling failure
+"""
+function sws_receive_slice(c, slice_start::Integer, slice_height::Integer)
+    ccall((:sws_receive_slice, libswscale), Cint, (Ptr{SwsContext}, Cuint, Cuint), c, slice_start, slice_height)
+end
 
-* `inv_table`: the yuv2rgb coefficients describing the input yuv space, normally ff\\_yuv2rgb\\_coeffs[x] 
+"""
+    sws_receive_slice_alignment(c)
 
-* `brightness`: 16.16 fixed point brightness correction 
+Get the alignment required for slices
 
-* `contrast`: 16.16 fixed point contrast correction 
+### Parameters
+* `c`: The scaling context
+### Returns
+alignment required for output slices requested with [`sws_receive_slice`](@ref)(). Slice offsets and sizes passed to [`sws_receive_slice`](@ref)() must be multiples of the value returned from this function.
+"""
+function sws_receive_slice_alignment(c)
+    ccall((:sws_receive_slice_alignment, libswscale), Cuint, (Ptr{SwsContext},), c)
+end
 
-* `saturation`: 16.16 fixed point saturation correction 
+"""
+    sws_setColorspaceDetails(c, inv_table, srcRange::Integer, table, dstRange::Integer, brightness::Integer, contrast::Integer, saturation::Integer)
 
+### Parameters
+* `c`: the scaling context
+* `dstRange`: flag indicating the while-black range of the output (1=jpeg / 0=mpeg)
+* `srcRange`: flag indicating the while-black range of the input (1=jpeg / 0=mpeg)
+* `table`: the yuv2rgb coefficients describing the output yuv space, normally ff\\_yuv2rgb\\_coeffs[x]
+* `inv_table`: the yuv2rgb coefficients describing the input yuv space, normally ff\\_yuv2rgb\\_coeffs[x]
+* `brightness`: 16.16 fixed point brightness correction
+* `contrast`: 16.16 fixed point contrast correction
+* `saturation`: 16.16 fixed point saturation correction
 ### Returns
--1 if not supported
+A negative error code on error, non negative otherwise. If `[`LIBSWSCALE_VERSION_MAJOR`](@ref) < 7`, returns -1 if not supported.
 """
 function sws_setColorspaceDetails(c, inv_table, srcRange::Integer, table, dstRange::Integer, brightness::Integer, contrast::Integer, saturation::Integer)
     ccall((:sws_setColorspaceDetails, libswscale), Cint, (Ptr{SwsContext}, Ptr{Cint}, Cint, Ptr{Cint}, Cint, Cint, Cint, Cint), c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation)
@@ -19919,7 +20650,7 @@ end
     sws_getColorspaceDetails(c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation)
 
 ### Returns
--1 if not supported
+A negative error code on error, non negative otherwise. If `[`LIBSWSCALE_VERSION_MAJOR`](@ref) < 7`, returns -1 if not supported.
 """
 function sws_getColorspaceDetails(c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation)
     ccall((:sws_getColorspaceDetails, libswscale), Cint, (Ptr{SwsContext}, Ptr{Ptr{Cint}}, Ptr{Cint}, Ptr{Ptr{Cint}}, Ptr{Cint}, Ptr{Cint}, Ptr{Cint}, Ptr{Cint}), c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation)
@@ -19961,38 +20692,6 @@ function sws_normalizeVec(a, height::Cdouble)
     ccall((:sws_normalizeVec, libswscale), Cvoid, (Ptr{SwsVector}, Cdouble), a, height)
 end
 
-function sws_getConstVec(c::Cdouble, length::Integer)
-    ccall((:sws_getConstVec, libswscale), Ptr{SwsVector}, (Cdouble, Cint), c, length)
-end
-
-function sws_getIdentityVec()
-    ccall((:sws_getIdentityVec, libswscale), Ptr{SwsVector}, ())
-end
-
-function sws_convVec(a, b)
-    ccall((:sws_convVec, libswscale), Cvoid, (Ptr{SwsVector}, Ptr{SwsVector}), a, b)
-end
-
-function sws_addVec(a, b)
-    ccall((:sws_addVec, libswscale), Cvoid, (Ptr{SwsVector}, Ptr{SwsVector}), a, b)
-end
-
-function sws_subVec(a, b)
-    ccall((:sws_subVec, libswscale), Cvoid, (Ptr{SwsVector}, Ptr{SwsVector}), a, b)
-end
-
-function sws_shiftVec(a, shift::Integer)
-    ccall((:sws_shiftVec, libswscale), Cvoid, (Ptr{SwsVector}, Cint), a, shift)
-end
-
-function sws_cloneVec(a)
-    ccall((:sws_cloneVec, libswscale), Ptr{SwsVector}, (Ptr{SwsVector},), a)
-end
-
-function sws_printVec2(a, log_ctx, log_level::Integer)
-    ccall((:sws_printVec2, libswscale), Cvoid, (Ptr{SwsVector}, Ptr{AVClass}, Cint), a, log_ctx, log_level)
-end
-
 function sws_freeVec(a)
     ccall((:sws_freeVec, libswscale), Cvoid, (Ptr{SwsVector},), a)
 end
@@ -20026,12 +20725,9 @@ Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.
 The output frame will have the same packed format as the palette.
 
 ### Parameters
-* `src`: source frame buffer 
-
-* `dst`: destination frame buffer 
-
-* `num_pixels`: number of pixels to convert 
-
+* `src`: source frame buffer
+* `dst`: destination frame buffer
+* `num_pixels`: number of pixels to convert
 * `palette`: array with [256] entries, which must match color arrangement (RGB or BGR) of src
 """
 function sws_convertPalette8ToPacked32(src, dst, num_pixels::Integer, palette)
@@ -20046,12 +20742,9 @@ Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.
 With the palette format "ABCD", the destination frame ends up with the format "ABC".
 
 ### Parameters
-* `src`: source frame buffer 
-
-* `dst`: destination frame buffer 
-
-* `num_pixels`: number of pixels to convert 
-
+* `src`: source frame buffer
+* `dst`: destination frame buffer
+* `num_pixels`: number of pixels to convert
 * `palette`: array with [256] entries, which must match color arrangement (RGB or BGR) of src
 """
 function sws_convertPalette8ToPacked24(src, dst, num_pixels::Integer, palette)
@@ -20072,8 +20765,6 @@ end
 
 const AV_AAC_ADTS_HEADER_SIZE = 7
 
-const AV_INPUT_BUFFER_PADDING_SIZE = 64
-
 const AV_INPUT_BUFFER_MIN_SIZE = 16384
 
 const AV_CODEC_FLAG_UNALIGNED = 1 << 0
@@ -20088,6 +20779,12 @@ const AV_CODEC_FLAG_QPEL = 1 << 4
 
 const AV_CODEC_FLAG_DROPCHANGED = 1 << 5
 
+const AV_CODEC_FLAG_RECON_FRAME = 1 << 6
+
+const AV_CODEC_FLAG_COPY_OPAQUE = 1 << 7
+
+const AV_CODEC_FLAG_FRAME_DURATION = 1 << 8
+
 const AV_CODEC_FLAG_PASS1 = 1 << 9
 
 const AV_CODEC_FLAG_PASS2 = 1 << 10
@@ -20098,8 +20795,6 @@ const AV_CODEC_FLAG_GRAY = 1 << 13
 
 const AV_CODEC_FLAG_PSNR = 1 << 15
 
-const AV_CODEC_FLAG_TRUNCATED = 1 << 16
-
 const AV_CODEC_FLAG_INTERLACED_DCT = 1 << 18
 
 const AV_CODEC_FLAG_LOW_DELAY = 1 << 19
@@ -20120,8 +20815,6 @@ const AV_CODEC_FLAG2_NO_OUTPUT = 1 << 2
 
 const AV_CODEC_FLAG2_LOCAL_HEADER = 1 << 3
 
-const AV_CODEC_FLAG2_DROP_FRAME_TIMECODE = 1 << 13
-
 const AV_CODEC_FLAG2_CHUNKS = 1 << 15
 
 const AV_CODEC_FLAG2_IGNORE_CROP = 1 << 16
@@ -20134,6 +20827,8 @@ const AV_CODEC_FLAG2_SKIP_MANUAL = 1 << 29
 
 const AV_CODEC_FLAG2_RO_FLUSH_NOOP = 1 << 30
 
+const AV_CODEC_FLAG2_ICC_PROFILES = Cuint(1) << 31
+
 const AV_CODEC_EXPORT_DATA_MVS = 1 << 0
 
 const AV_CODEC_EXPORT_DATA_PRFT = 1 << 1
@@ -20148,12 +20843,6 @@ const AV_GET_ENCODE_BUFFER_FLAG_REF = 1 << 0
 
 const FF_COMPRESSION_DEFAULT = -1
 
-const FF_PRED_LEFT = 0
-
-const FF_PRED_PLANE = 1
-
-const FF_PRED_MEDIAN = 2
-
 const FF_CMP_SAD = 0
 
 const FF_CMP_SSE = 1
@@ -20200,14 +20889,6 @@ const FF_MB_DECISION_BITS = 1
 
 const FF_MB_DECISION_RD = 2
 
-const FF_CODER_TYPE_VLC = 0
-
-const FF_CODER_TYPE_AC = 1
-
-const FF_CODER_TYPE_RAW = 2
-
-const FF_CODER_TYPE_RLE = 3
-
 const FF_BUG_AUTODETECT = 1
 
 const FF_BUG_XVID_ILACE = 4
@@ -20238,16 +20919,6 @@ const FF_BUG_TRUNCATED = 16384
 
 const FF_BUG_IEDGE = 32768
 
-const FF_COMPLIANCE_VERY_STRICT = 2
-
-const FF_COMPLIANCE_STRICT = 1
-
-const FF_COMPLIANCE_NORMAL = 0
-
-const FF_COMPLIANCE_UNOFFICIAL = -1
-
-const FF_COMPLIANCE_EXPERIMENTAL = -2
-
 const FF_EC_GUESS_MVS = 1
 
 const FF_EC_DEBLOCK = 2
@@ -20284,22 +20955,6 @@ const FF_DEBUG_GREEN_MD = 0x00800000
 
 const FF_DEBUG_NOMC = 0x01000000
 
-const AV_EF_CRCCHECK = 1 << 0
-
-const AV_EF_BITSTREAM = 1 << 1
-
-const AV_EF_BUFFER = 1 << 2
-
-const AV_EF_EXPLODE = 1 << 3
-
-const AV_EF_IGNORE_ERR = 1 << 15
-
-const AV_EF_CAREFUL = 1 << 16
-
-const AV_EF_COMPLIANT = 1 << 17
-
-const AV_EF_AGGRESSIVE = 1 << 18
-
 const FF_DCT_AUTO = 0
 
 const FF_DCT_FASTINT = 1
@@ -20392,6 +21047,14 @@ const FF_PROFILE_DTS_HD_MA = 60
 
 const FF_PROFILE_DTS_EXPRESS = 70
 
+const FF_PROFILE_DTS_HD_MA_X = 61
+
+const FF_PROFILE_DTS_HD_MA_X_IMAX = 62
+
+const FF_PROFILE_EAC3_DDP_ATMOS = 30
+
+const FF_PROFILE_TRUEHD_ATMOS = 30
+
 const FF_PROFILE_MPEG2_422 = 0
 
 const FF_PROFILE_MPEG2_HIGH = 1
@@ -20504,6 +21167,8 @@ const FF_PROFILE_HEVC_MAIN_STILL_PICTURE = 3
 
 const FF_PROFILE_HEVC_REXT = 4
 
+const FF_PROFILE_HEVC_SCC = 9
+
 const FF_PROFILE_VVC_MAIN_10 = 1
 
 const FF_PROFILE_VVC_MAIN_10_444 = 33
@@ -20546,6 +21211,10 @@ const FF_PROFILE_KLVA_SYNC = 0
 
 const FF_PROFILE_KLVA_ASYNC = 1
 
+const FF_PROFILE_EVC_BASELINE = 0
+
+const FF_PROFILE_EVC_MAIN = 1
+
 const FF_LEVEL_UNKNOWN = -99
 
 const FF_SUB_CHARENC_MODE_DO_NOTHING = -1
@@ -20556,19 +21225,11 @@ const FF_SUB_CHARENC_MODE_PRE_DECODER = 1
 
 const FF_SUB_CHARENC_MODE_IGNORE = 2
 
-const FF_DEBUG_VIS_MV_P_FOR = 0x00000001
-
-const FF_DEBUG_VIS_MV_B_FOR = 0x00000002
-
-const FF_DEBUG_VIS_MV_B_BACK = 0x00000004
-
 const FF_CODEC_PROPERTY_LOSSLESS = 0x00000001
 
 const FF_CODEC_PROPERTY_CLOSED_CAPTIONS = 0x00000002
 
-const FF_SUB_TEXT_FMT_ASS = 0
-
-const FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS = 1
+const FF_CODEC_PROPERTY_FILM_GRAIN = 0x00000004
 
 const AV_HWACCEL_CODEC_CAP_EXPERIMENTAL = 0x0200
 
@@ -20578,6 +21239,8 @@ const AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH = 1 << 1
 
 const AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH = 1 << 2
 
+const AV_HWACCEL_FLAG_UNSAFE_OUTPUT = 1 << 3
+
 const AV_SUBTITLE_FLAG_FORCED = 0x00000001
 
 const AV_PARSER_PTS_NB = 4
@@ -20594,8 +21257,6 @@ const AV_CODEC_CAP_DRAW_HORIZ_BAND = 1 << 0
 
 const AV_CODEC_CAP_DR1 = 1 << 1
 
-const AV_CODEC_CAP_TRUNCATED = 1 << 3
-
 const AV_CODEC_CAP_DELAY = 1 << 5
 
 const AV_CODEC_CAP_SMALL_LAST_FRAME = 1 << 6
@@ -20614,16 +21275,10 @@ const AV_CODEC_CAP_PARAM_CHANGE = 1 << 14
 
 const AV_CODEC_CAP_OTHER_THREADS = 1 << 15
 
-const AV_CODEC_CAP_AUTO_THREADS = AV_CODEC_CAP_OTHER_THREADS
-
 const AV_CODEC_CAP_VARIABLE_FRAME_SIZE = 1 << 16
 
 const AV_CODEC_CAP_AVOID_PROBING = 1 << 17
 
-const AV_CODEC_CAP_INTRA_ONLY = 0x40000000
-
-const AV_CODEC_CAP_LOSSLESS = 0x80000000
-
 const AV_CODEC_CAP_HARDWARE = 1 << 18
 
 const AV_CODEC_CAP_HYBRID = 1 << 19
@@ -20632,6 +21287,8 @@ const AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE = 1 << 20
 
 const AV_CODEC_CAP_ENCODER_FLUSH = 1 << 21
 
+const AV_CODEC_CAP_ENCODER_RECON_FRAME = 1 << 22
+
 const AV_CODEC_PROP_INTRA_ONLY = 1 << 0
 
 const AV_CODEC_PROP_LOSSY = 1 << 1
@@ -20640,6 +21297,8 @@ const AV_CODEC_PROP_LOSSLESS = 1 << 2
 
 const AV_CODEC_PROP_REORDER = 1 << 3
 
+const AV_CODEC_PROP_FIELDS = 1 << 4
+
 const AV_CODEC_PROP_BITMAP_SUB = 1 << 16
 
 const AV_CODEC_PROP_TEXT_SUB = 1 << 17
@@ -20656,111 +21315,309 @@ const FF_DXVA2_WORKAROUND_SCALING_LIST_ZIGZAG = 1
 
 const FF_DXVA2_WORKAROUND_INTEL_CLEARVIDEO = 2
 
-const MAX_DWT_LEVELS = 5
+const AV_INPUT_BUFFER_PADDING_SIZE = 64
 
-const DV_PROFILE_BYTES = 6 * 80
+const AV_EF_CRCCHECK = 1 << 0
 
-const AV_PKT_DATA_QUALITY_FACTOR = AV_PKT_DATA_QUALITY_STATS
+const AV_EF_BITSTREAM = 1 << 1
 
-const AV_PKT_FLAG_KEY = 0x0001
+const AV_EF_BUFFER = 1 << 2
 
-const AV_PKT_FLAG_CORRUPT = 0x0002
+const AV_EF_EXPLODE = 1 << 3
 
-const AV_PKT_FLAG_DISCARD = 0x0004
+const AV_EF_IGNORE_ERR = 1 << 15
 
-const AV_PKT_FLAG_TRUSTED = 0x0008
+const AV_EF_CAREFUL = 1 << 16
 
-const AV_PKT_FLAG_DISPOSABLE = 0x0010
+const AV_EF_COMPLIANT = 1 << 17
 
-const LIBAVCODEC_VERSION_MAJOR = 58
+const AV_EF_AGGRESSIVE = 1 << 18
 
-const LIBAVCODEC_VERSION_MINOR = 134
+const FF_COMPLIANCE_VERY_STRICT = 2
 
-const LIBAVCODEC_VERSION_MICRO = 100
+const FF_COMPLIANCE_STRICT = 1
 
-const LIBAVCODEC_VERSION_INT = AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, LIBAVCODEC_VERSION_MICRO)
+const FF_COMPLIANCE_NORMAL = 0
 
-const LIBAVCODEC_VERSION = AV_VERSION(LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, LIBAVCODEC_VERSION_MICRO)
+const FF_COMPLIANCE_UNOFFICIAL = -1
 
-const LIBAVCODEC_BUILD = LIBAVCODEC_VERSION_INT
+const FF_COMPLIANCE_EXPERIMENTAL = -2
+
+const AV_PROFILE_UNKNOWN = -99
+
+const AV_PROFILE_RESERVED = -100
+
+const AV_PROFILE_AAC_MAIN = 0
+
+const AV_PROFILE_AAC_LOW = 1
+
+const AV_PROFILE_AAC_SSR = 2
+
+const AV_PROFILE_AAC_LTP = 3
+
+const AV_PROFILE_AAC_HE = 4
+
+const AV_PROFILE_AAC_HE_V2 = 28
+
+const AV_PROFILE_AAC_LD = 22
+
+const AV_PROFILE_AAC_ELD = 38
+
+const AV_PROFILE_MPEG2_AAC_LOW = 128
+
+const AV_PROFILE_MPEG2_AAC_HE = 131
+
+const AV_PROFILE_DNXHD = 0
+
+const AV_PROFILE_DNXHR_LB = 1
+
+const AV_PROFILE_DNXHR_SQ = 2
+
+const AV_PROFILE_DNXHR_HQ = 3
+
+const AV_PROFILE_DNXHR_HQX = 4
+
+const AV_PROFILE_DNXHR_444 = 5
+
+const AV_PROFILE_DTS = 20
+
+const AV_PROFILE_DTS_ES = 30
+
+const AV_PROFILE_DTS_96_24 = 40
+
+const AV_PROFILE_DTS_HD_HRA = 50
+
+const AV_PROFILE_DTS_HD_MA = 60
+
+const AV_PROFILE_DTS_EXPRESS = 70
+
+const AV_PROFILE_DTS_HD_MA_X = 61
+
+const AV_PROFILE_DTS_HD_MA_X_IMAX = 62
+
+const AV_PROFILE_EAC3_DDP_ATMOS = 30
+
+const AV_PROFILE_TRUEHD_ATMOS = 30
+
+const AV_PROFILE_MPEG2_422 = 0
+
+const AV_PROFILE_MPEG2_HIGH = 1
+
+const AV_PROFILE_MPEG2_SS = 2
+
+const AV_PROFILE_MPEG2_SNR_SCALABLE = 3
+
+const AV_PROFILE_MPEG2_MAIN = 4
+
+const AV_PROFILE_MPEG2_SIMPLE = 5
+
+const AV_PROFILE_H264_CONSTRAINED = 1 << 9
+
+const AV_PROFILE_H264_INTRA = 1 << 11
+
+const AV_PROFILE_H264_BASELINE = 66
+
+const AV_PROFILE_H264_CONSTRAINED_BASELINE = 66 | AV_PROFILE_H264_CONSTRAINED
+
+const AV_PROFILE_H264_MAIN = 77
+
+const AV_PROFILE_H264_EXTENDED = 88
+
+const AV_PROFILE_H264_HIGH = 100
+
+const AV_PROFILE_H264_HIGH_10 = 110
+
+const AV_PROFILE_H264_HIGH_10_INTRA = 110 | AV_PROFILE_H264_INTRA
+
+const AV_PROFILE_H264_MULTIVIEW_HIGH = 118
+
+const AV_PROFILE_H264_HIGH_422 = 122
+
+const AV_PROFILE_H264_HIGH_422_INTRA = 122 | AV_PROFILE_H264_INTRA
+
+const AV_PROFILE_H264_STEREO_HIGH = 128
+
+const AV_PROFILE_H264_HIGH_444 = 144
+
+const AV_PROFILE_H264_HIGH_444_PREDICTIVE = 244
+
+const AV_PROFILE_H264_HIGH_444_INTRA = 244 | AV_PROFILE_H264_INTRA
+
+const AV_PROFILE_H264_CAVLC_444 = 44
+
+const AV_PROFILE_VC1_SIMPLE = 0
+
+const AV_PROFILE_VC1_MAIN = 1
+
+const AV_PROFILE_VC1_COMPLEX = 2
+
+const AV_PROFILE_VC1_ADVANCED = 3
+
+const AV_PROFILE_MPEG4_SIMPLE = 0
+
+const AV_PROFILE_MPEG4_SIMPLE_SCALABLE = 1
+
+const AV_PROFILE_MPEG4_CORE = 2
+
+const AV_PROFILE_MPEG4_MAIN = 3
+
+const AV_PROFILE_MPEG4_N_BIT = 4
+
+const AV_PROFILE_MPEG4_SCALABLE_TEXTURE = 5
+
+const AV_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = 6
+
+const AV_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = 7
+
+const AV_PROFILE_MPEG4_HYBRID = 8
+
+const AV_PROFILE_MPEG4_ADVANCED_REAL_TIME = 9
+
+const AV_PROFILE_MPEG4_CORE_SCALABLE = 10
+
+const AV_PROFILE_MPEG4_ADVANCED_CODING = 11
+
+const AV_PROFILE_MPEG4_ADVANCED_CORE = 12
+
+const AV_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = 13
+
+const AV_PROFILE_MPEG4_SIMPLE_STUDIO = 14
+
+const AV_PROFILE_MPEG4_ADVANCED_SIMPLE = 15
+
+const AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 = 1
+
+const AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 = 2
+
+const AV_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = 32768
+
+const AV_PROFILE_JPEG2000_DCINEMA_2K = 3
+
+const AV_PROFILE_JPEG2000_DCINEMA_4K = 4
+
+const AV_PROFILE_VP9_0 = 0
+
+const AV_PROFILE_VP9_1 = 1
+
+const AV_PROFILE_VP9_2 = 2
+
+const AV_PROFILE_VP9_3 = 3
+
+const AV_PROFILE_HEVC_MAIN = 1
+
+const AV_PROFILE_HEVC_MAIN_10 = 2
+
+const AV_PROFILE_HEVC_MAIN_STILL_PICTURE = 3
+
+const AV_PROFILE_HEVC_REXT = 4
+
+const AV_PROFILE_HEVC_SCC = 9
 
-const FF_API_AVCTX_TIMEBASE = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_VVC_MAIN_10 = 1
 
-const FF_API_CODED_FRAME = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_VVC_MAIN_10_444 = 33
 
-const FF_API_SIDEDATA_ONLY_PKT = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_AV1_MAIN = 0
 
-const FF_API_VDPAU_PROFILE = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_AV1_HIGH = 1
 
-const FF_API_CONVERGENCE_DURATION = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_AV1_PROFESSIONAL = 2
 
-const FF_API_AVPICTURE = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT = 0xc0
 
-const FF_API_AVPACKET_OLD_API = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT = 0xc1
 
-const FF_API_RTP_CALLBACK = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT = 0xc2
 
-const FF_API_VBV_DELAY = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_MJPEG_HUFFMAN_LOSSLESS = 0xc3
 
-const FF_API_CODER_TYPE = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_MJPEG_JPEG_LS = 0xf7
 
-const FF_API_STAT_BITS = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_SBC_MSBC = 1
 
-const FF_API_PRIVATE_OPT = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_PRORES_PROXY = 0
 
-const FF_API_ASS_TIMING = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_PRORES_LT = 1
 
-const FF_API_OLD_BSF = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_PRORES_STANDARD = 2
 
-const FF_API_COPY_CONTEXT = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_PRORES_HQ = 3
 
-const FF_API_GET_CONTEXT_DEFAULTS = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_PRORES_4444 = 4
 
-const FF_API_NVENC_OLD_NAME = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_PRORES_XQ = 5
 
-const FF_API_STRUCT_VAAPI_CONTEXT = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_ARIB_PROFILE_A = 0
 
-const FF_API_MERGE_SD_API = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_ARIB_PROFILE_C = 1
 
-const FF_API_TAG_STRING = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_KLVA_SYNC = 0
 
-const FF_API_GETCHROMA = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_KLVA_ASYNC = 1
 
-const FF_API_CODEC_GET_SET = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_EVC_BASELINE = 0
 
-const FF_API_USER_VISIBLE_AVHWACCEL = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_PROFILE_EVC_MAIN = 1
 
-const FF_API_LOCKMGR = LIBAVCODEC_VERSION_MAJOR < 59
+const AV_LEVEL_UNKNOWN = -99
 
-const FF_API_NEXT = LIBAVCODEC_VERSION_MAJOR < 59
+const MAX_DWT_LEVELS = 5
+
+const DV_PROFILE_BYTES = 6 * 80
+
+const AV_PKT_DATA_QUALITY_FACTOR = AV_PKT_DATA_QUALITY_STATS
+
+const AV_PKT_FLAG_KEY = 0x0001
+
+const AV_PKT_FLAG_CORRUPT = 0x0002
+
+const AV_PKT_FLAG_DISCARD = 0x0004
+
+const AV_PKT_FLAG_TRUSTED = 0x0008
+
+const AV_PKT_FLAG_DISPOSABLE = 0x0010
+
+const LIBAVCODEC_VERSION_MINOR = 31
 
-const FF_API_UNSANITIZED_BITRATES = LIBAVCODEC_VERSION_MAJOR < 59
+const LIBAVCODEC_VERSION_MICRO = 102
 
-const FF_API_OPENH264_SLICE_MODE = LIBAVCODEC_VERSION_MAJOR < 59
+const LIBAVCODEC_VERSION_MAJOR = 60
 
-const FF_API_OPENH264_CABAC = LIBAVCODEC_VERSION_MAJOR < 59
+const LIBAVCODEC_VERSION_INT = AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, LIBAVCODEC_VERSION_MICRO)
+
+const LIBAVCODEC_VERSION = AV_VERSION(LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, LIBAVCODEC_VERSION_MICRO)
+
+const LIBAVCODEC_BUILD = LIBAVCODEC_VERSION_INT
+
+const FF_API_INIT_PACKET = LIBAVCODEC_VERSION_MAJOR < 61
+
+const FF_API_IDCT_NONE = LIBAVCODEC_VERSION_MAJOR < 61
+
+const FF_API_SVTAV1_OPTS = LIBAVCODEC_VERSION_MAJOR < 61
 
-const FF_API_UNUSED_CODEC_CAPS = LIBAVCODEC_VERSION_MAJOR < 59
+const FF_API_AYUV_CODECID = LIBAVCODEC_VERSION_MAJOR < 61
 
-const FF_API_AVPRIV_PUT_BITS = LIBAVCODEC_VERSION_MAJOR < 59
+const FF_API_VT_OUTPUT_CALLBACK = LIBAVCODEC_VERSION_MAJOR < 61
 
-const FF_API_OLD_ENCDEC = LIBAVCODEC_VERSION_MAJOR < 59
+const FF_API_AVCODEC_CHROMA_POS = LIBAVCODEC_VERSION_MAJOR < 61
 
-const FF_API_AVCODEC_PIX_FMT = LIBAVCODEC_VERSION_MAJOR < 59
+const FF_API_VT_HWACCEL_CONTEXT = LIBAVCODEC_VERSION_MAJOR < 61
 
-const FF_API_MPV_RC_STRATEGY = LIBAVCODEC_VERSION_MAJOR < 59
+const FF_API_AVCTX_FRAME_NUMBER = LIBAVCODEC_VERSION_MAJOR < 61
 
-const FF_API_PARSER_CHANGE = LIBAVCODEC_VERSION_MAJOR < 59
+const FF_API_SLICE_OFFSET = LIBAVCODEC_VERSION_MAJOR < 61
 
-const FF_API_THREAD_SAFE_CALLBACKS = LIBAVCODEC_VERSION_MAJOR < 60
+const FF_API_SUBFRAMES = LIBAVCODEC_VERSION_MAJOR < 61
 
-const FF_API_DEBUG_MV = LIBAVCODEC_VERSION_MAJOR < 60
+const FF_API_TICKS_PER_FRAME = LIBAVCODEC_VERSION_MAJOR < 61
 
-const FF_API_GET_FRAME_CLASS = LIBAVCODEC_VERSION_MAJOR < 60
+const FF_API_DROPCHANGED = LIBAVCODEC_VERSION_MAJOR < 61
 
-const FF_API_AUTO_THREADS = LIBAVCODEC_VERSION_MAJOR < 60
+const FF_API_AVFFT = LIBAVCODEC_VERSION_MAJOR < 62
 
-const FF_API_INIT_PACKET = LIBAVCODEC_VERSION_MAJOR < 60
+const FF_API_FF_PROFILE_LEVEL = LIBAVCODEC_VERSION_MAJOR < 62
+
+const FF_CODEC_CRYSTAL_HD = LIBAVCODEC_VERSION_MAJOR < 61
 
 const VORBIS_FLAG_HEADER = 0x00000001
 
@@ -20770,26 +21627,28 @@ const VORBIS_FLAG_SETUP = 0x00000004
 
 const AV_XVMC_ID = 0x1dc711c0
 
-const LIBAVDEVICE_VERSION_MAJOR = 58
-
-const LIBAVDEVICE_VERSION_MINOR = 13
+const LIBAVDEVICE_VERSION_MINOR = 3
 
 const LIBAVDEVICE_VERSION_MICRO = 100
 
+const LIBAVDEVICE_VERSION_MAJOR = 60
+
 const LIBAVDEVICE_VERSION_INT = AV_VERSION_INT(LIBAVDEVICE_VERSION_MAJOR, LIBAVDEVICE_VERSION_MINOR, LIBAVDEVICE_VERSION_MICRO)
 
 const LIBAVDEVICE_VERSION = AV_VERSION(LIBAVDEVICE_VERSION_MAJOR, LIBAVDEVICE_VERSION_MINOR, LIBAVDEVICE_VERSION_MICRO)
 
 const LIBAVDEVICE_BUILD = LIBAVDEVICE_VERSION_INT
 
-const FF_API_DEVICE_CAPABILITIES = LIBAVDEVICE_VERSION_MAJOR < 60
-
 const AVFILTER_FLAG_DYNAMIC_INPUTS = 1 << 0
 
 const AVFILTER_FLAG_DYNAMIC_OUTPUTS = 1 << 1
 
 const AVFILTER_FLAG_SLICE_THREADS = 1 << 2
 
+const AVFILTER_FLAG_METADATA_ONLY = 1 << 3
+
+const AVFILTER_FLAG_HWDEVICE = 1 << 4
+
 const AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC = 1 << 16
 
 const AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL = 1 << 17
@@ -20806,29 +21665,19 @@ const AV_BUFFERSINK_FLAG_PEEK = 1
 
 const AV_BUFFERSINK_FLAG_NO_REQUEST = 2
 
-const LIBAVFILTER_VERSION_MAJOR = 7
-
-const LIBAVFILTER_VERSION_MINOR = 110
+const LIBAVFILTER_VERSION_MINOR = 12
 
 const LIBAVFILTER_VERSION_MICRO = 100
 
+const LIBAVFILTER_VERSION_MAJOR = 9
+
 const LIBAVFILTER_VERSION_INT = AV_VERSION_INT(LIBAVFILTER_VERSION_MAJOR, LIBAVFILTER_VERSION_MINOR, LIBAVFILTER_VERSION_MICRO)
 
 const LIBAVFILTER_VERSION = AV_VERSION(LIBAVFILTER_VERSION_MAJOR, LIBAVFILTER_VERSION_MINOR, LIBAVFILTER_VERSION_MICRO)
 
 const LIBAVFILTER_BUILD = LIBAVFILTER_VERSION_INT
 
-const FF_API_OLD_FILTER_OPTS_ERROR = LIBAVFILTER_VERSION_MAJOR < 8
-
-const FF_API_LAVR_OPTS = LIBAVFILTER_VERSION_MAJOR < 8
-
-const FF_API_FILTER_GET_SET = LIBAVFILTER_VERSION_MAJOR < 8
-
-const FF_API_SWS_PARAM_OPTION = LIBAVFILTER_VERSION_MAJOR < 8
-
-const FF_API_FILTER_LINK_SET_CLOSED = LIBAVFILTER_VERSION_MAJOR < 8
-
-const FF_API_BUFFERSINK_ALLOC = LIBAVFILTER_VERSION_MAJOR < 9
+const FF_API_LIBPLACEBO_OPTS = LIBAVFILTER_VERSION_MAJOR < 10
 
 const AVPROBE_SCORE_RETRY = AVPROBE_SCORE_MAX ÷ 4
 
@@ -20844,6 +21693,8 @@ const AVFMT_NOFILE = 0x0001
 
 const AVFMT_NEEDNUMBER = 0x0002
 
+const AVFMT_EXPERIMENTAL = 0x0004
+
 const AVFMT_SHOW_IDS = 0x0008
 
 const AVFMT_GLOBALHEADER = 0x0040
@@ -20878,39 +21729,41 @@ const AVINDEX_KEYFRAME = 0x0001
 
 const AVINDEX_DISCARD_FRAME = 0x0002
 
-const AV_DISPOSITION_DEFAULT = 0x0001
+const AV_DISPOSITION_DEFAULT = 1 << 0
 
-const AV_DISPOSITION_DUB = 0x0002
+const AV_DISPOSITION_DUB = 1 << 1
 
-const AV_DISPOSITION_ORIGINAL = 0x0004
+const AV_DISPOSITION_ORIGINAL = 1 << 2
 
-const AV_DISPOSITION_COMMENT = 0x0008
+const AV_DISPOSITION_COMMENT = 1 << 3
 
-const AV_DISPOSITION_LYRICS = 0x0010
+const AV_DISPOSITION_LYRICS = 1 << 4
 
-const AV_DISPOSITION_KARAOKE = 0x0020
+const AV_DISPOSITION_KARAOKE = 1 << 5
 
-const AV_DISPOSITION_FORCED = 0x0040
+const AV_DISPOSITION_FORCED = 1 << 6
 
-const AV_DISPOSITION_HEARING_IMPAIRED = 0x0080
+const AV_DISPOSITION_HEARING_IMPAIRED = 1 << 7
 
-const AV_DISPOSITION_VISUAL_IMPAIRED = 0x0100
+const AV_DISPOSITION_VISUAL_IMPAIRED = 1 << 8
 
-const AV_DISPOSITION_CLEAN_EFFECTS = 0x0200
+const AV_DISPOSITION_CLEAN_EFFECTS = 1 << 9
 
-const AV_DISPOSITION_ATTACHED_PIC = 0x0400
+const AV_DISPOSITION_ATTACHED_PIC = 1 << 10
 
-const AV_DISPOSITION_TIMED_THUMBNAILS = 0x0800
+const AV_DISPOSITION_TIMED_THUMBNAILS = 1 << 11
 
-const AV_DISPOSITION_CAPTIONS = 0x00010000
+const AV_DISPOSITION_NON_DIEGETIC = 1 << 12
 
-const AV_DISPOSITION_DESCRIPTIONS = 0x00020000
+const AV_DISPOSITION_CAPTIONS = 1 << 16
 
-const AV_DISPOSITION_METADATA = 0x00040000
+const AV_DISPOSITION_DESCRIPTIONS = 1 << 17
 
-const AV_DISPOSITION_DEPENDENT = 0x00080000
+const AV_DISPOSITION_METADATA = 1 << 18
 
-const AV_DISPOSITION_STILL_IMAGE = 0x00100000
+const AV_DISPOSITION_DEPENDENT = 1 << 19
+
+const AV_DISPOSITION_STILL_IMAGE = 1 << 20
 
 const AV_PTS_WRAP_IGNORE = 0
 
@@ -20950,14 +21803,8 @@ const AVFMT_FLAG_FLUSH_PACKETS = 0x0200
 
 const AVFMT_FLAG_BITEXACT = 0x0400
 
-const AVFMT_FLAG_MP4A_LATM = 0x8000
-
 const AVFMT_FLAG_SORT_DTS = 0x00010000
 
-const AVFMT_FLAG_PRIV_OPT = 0x00020000
-
-const AVFMT_FLAG_KEEP_SIDE_DATA = 0x00040000
-
 const AVFMT_FLAG_FAST_SEEK = 0x00080000
 
 const AVFMT_FLAG_SHORTEST = 0x00100000
@@ -20970,6 +21817,8 @@ const AVFMT_EVENT_FLAG_METADATA_UPDATED = 0x0001
 
 const AVFMT_AVOID_NEG_TS_AUTO = -1
 
+const AVFMT_AVOID_NEG_TS_DISABLED = 0
+
 const AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE = 1
 
 const AVFMT_AVOID_NEG_TS_MAKE_ZERO = 2
@@ -21006,55 +21855,33 @@ const AVIO_FLAG_NONBLOCK = 8
 
 const AVIO_FLAG_DIRECT = 0x8000
 
-const LIBAVFORMAT_VERSION_MAJOR = 58
-
-const LIBAVFORMAT_VERSION_MINOR = 76
+const LIBAVFORMAT_VERSION_MINOR = 16
 
 const LIBAVFORMAT_VERSION_MICRO = 100
 
+const LIBAVFORMAT_VERSION_MAJOR = 60
+
 const LIBAVFORMAT_VERSION_INT = AV_VERSION_INT(LIBAVFORMAT_VERSION_MAJOR, LIBAVFORMAT_VERSION_MINOR, LIBAVFORMAT_VERSION_MICRO)
 
 const LIBAVFORMAT_VERSION = AV_VERSION(LIBAVFORMAT_VERSION_MAJOR, LIBAVFORMAT_VERSION_MINOR, LIBAVFORMAT_VERSION_MICRO)
 
 const LIBAVFORMAT_BUILD = LIBAVFORMAT_VERSION_INT
 
-const FF_API_COMPUTE_PKT_FIELDS2 = LIBAVFORMAT_VERSION_MAJOR < 59
-
-const FF_API_OLD_OPEN_CALLBACKS = LIBAVFORMAT_VERSION_MAJOR < 59
-
-const FF_API_LAVF_AVCTX = LIBAVFORMAT_VERSION_MAJOR < 59
-
-const FF_API_HTTP_USER_AGENT = LIBAVFORMAT_VERSION_MAJOR < 59
+const FF_API_COMPUTE_PKT_FIELDS2 = LIBAVFORMAT_VERSION_MAJOR < 61
 
-const FF_API_HLS_WRAP = LIBAVFORMAT_VERSION_MAJOR < 59
+const FF_API_GET_END_PTS = LIBAVFORMAT_VERSION_MAJOR < 61
 
-const FF_API_HLS_USE_LOCALTIME = LIBAVFORMAT_VERSION_MAJOR < 59
+const FF_API_AVIODIRCONTEXT = LIBAVFORMAT_VERSION_MAJOR < 61
 
-const FF_API_LAVF_KEEPSIDE_FLAG = LIBAVFORMAT_VERSION_MAJOR < 59
+const FF_API_AVFORMAT_IO_CLOSE = LIBAVFORMAT_VERSION_MAJOR < 61
 
-const FF_API_OLD_ROTATE_API = LIBAVFORMAT_VERSION_MAJOR < 59
+const FF_API_AVIO_WRITE_NONCONST = LIBAVFORMAT_VERSION_MAJOR < 61
 
-const FF_API_FORMAT_GET_SET = LIBAVFORMAT_VERSION_MAJOR < 59
+const FF_API_LAVF_SHORTEST = LIBAVFORMAT_VERSION_MAJOR < 61
 
-const FF_API_OLD_AVIO_EOF_0 = LIBAVFORMAT_VERSION_MAJOR < 59
+const FF_API_ALLOW_FLUSH = LIBAVFORMAT_VERSION_MAJOR < 61
 
-const FF_API_LAVF_FFSERVER = LIBAVFORMAT_VERSION_MAJOR < 59
-
-const FF_API_FORMAT_FILENAME = LIBAVFORMAT_VERSION_MAJOR < 59
-
-const FF_API_OLD_RTSP_OPTIONS = LIBAVFORMAT_VERSION_MAJOR < 59
-
-const FF_API_DASH_MIN_SEG_DURATION = LIBAVFORMAT_VERSION_MAJOR < 59
-
-const FF_API_LAVF_MP4A_LATM = LIBAVFORMAT_VERSION_MAJOR < 59
-
-const FF_API_AVIOFORMAT = LIBAVFORMAT_VERSION_MAJOR < 59
-
-const FF_API_DEMUXER_OPEN = LIBAVFORMAT_VERSION_MAJOR < 59
-
-const FF_API_CHAPTER_ID_INT = LIBAVFORMAT_VERSION_MAJOR < 59
-
-const FF_API_LAVF_PRIV_OPT = LIBAVFORMAT_VERSION_MAJOR < 60
+const FF_API_AVSTREAM_SIDE_DATA = LIBAVFORMAT_VERSION_MAJOR < 61
 
 const FF_API_R_FRAME_RATE = 1
 
@@ -21134,65 +21961,65 @@ const AV_BPRINT_SIZE_COUNT_ONLY = 0
 
 const AV_BUFFER_FLAG_READONLY = 1 << 0
 
-const AV_CH_FRONT_LEFT = 0x00000001
+const AV_CH_FRONT_LEFT = Culonglong(1) << AV_CHAN_FRONT_LEFT
 
-const AV_CH_FRONT_RIGHT = 0x00000002
+const AV_CH_FRONT_RIGHT = Culonglong(1) << AV_CHAN_FRONT_RIGHT
 
-const AV_CH_FRONT_CENTER = 0x00000004
+const AV_CH_FRONT_CENTER = Culonglong(1) << AV_CHAN_FRONT_CENTER
 
-const AV_CH_LOW_FREQUENCY = 0x00000008
+const AV_CH_LOW_FREQUENCY = Culonglong(1) << AV_CHAN_LOW_FREQUENCY
 
-const AV_CH_BACK_LEFT = 0x00000010
+const AV_CH_BACK_LEFT = Culonglong(1) << AV_CHAN_BACK_LEFT
 
-const AV_CH_BACK_RIGHT = 0x00000020
+const AV_CH_BACK_RIGHT = Culonglong(1) << AV_CHAN_BACK_RIGHT
 
-const AV_CH_FRONT_LEFT_OF_CENTER = 0x00000040
+const AV_CH_FRONT_LEFT_OF_CENTER = Culonglong(1) << AV_CHAN_FRONT_LEFT_OF_CENTER
 
-const AV_CH_FRONT_RIGHT_OF_CENTER = 0x00000080
+const AV_CH_FRONT_RIGHT_OF_CENTER = Culonglong(1) << AV_CHAN_FRONT_RIGHT_OF_CENTER
 
-const AV_CH_BACK_CENTER = 0x00000100
+const AV_CH_BACK_CENTER = Culonglong(1) << AV_CHAN_BACK_CENTER
 
-const AV_CH_SIDE_LEFT = 0x00000200
+const AV_CH_SIDE_LEFT = Culonglong(1) << AV_CHAN_SIDE_LEFT
 
-const AV_CH_SIDE_RIGHT = 0x00000400
+const AV_CH_SIDE_RIGHT = Culonglong(1) << AV_CHAN_SIDE_RIGHT
 
-const AV_CH_TOP_CENTER = 0x00000800
+const AV_CH_TOP_CENTER = Culonglong(1) << AV_CHAN_TOP_CENTER
 
-const AV_CH_TOP_FRONT_LEFT = 0x00001000
+const AV_CH_TOP_FRONT_LEFT = Culonglong(1) << AV_CHAN_TOP_FRONT_LEFT
 
-const AV_CH_TOP_FRONT_CENTER = 0x00002000
+const AV_CH_TOP_FRONT_CENTER = Culonglong(1) << AV_CHAN_TOP_FRONT_CENTER
 
-const AV_CH_TOP_FRONT_RIGHT = 0x00004000
+const AV_CH_TOP_FRONT_RIGHT = Culonglong(1) << AV_CHAN_TOP_FRONT_RIGHT
 
-const AV_CH_TOP_BACK_LEFT = 0x00008000
+const AV_CH_TOP_BACK_LEFT = Culonglong(1) << AV_CHAN_TOP_BACK_LEFT
 
-const AV_CH_TOP_BACK_CENTER = 0x00010000
+const AV_CH_TOP_BACK_CENTER = Culonglong(1) << AV_CHAN_TOP_BACK_CENTER
 
-const AV_CH_TOP_BACK_RIGHT = 0x00020000
+const AV_CH_TOP_BACK_RIGHT = Culonglong(1) << AV_CHAN_TOP_BACK_RIGHT
 
-const AV_CH_STEREO_LEFT = 0x20000000
+const AV_CH_STEREO_LEFT = Culonglong(1) << AV_CHAN_STEREO_LEFT
 
-const AV_CH_STEREO_RIGHT = 0x40000000
+const AV_CH_STEREO_RIGHT = Culonglong(1) << AV_CHAN_STEREO_RIGHT
 
-const AV_CH_WIDE_LEFT = Culonglong(0x0000000080000000)
+const AV_CH_WIDE_LEFT = Culonglong(1) << AV_CHAN_WIDE_LEFT
 
-const AV_CH_WIDE_RIGHT = Culonglong(0x0000000100000000)
+const AV_CH_WIDE_RIGHT = Culonglong(1) << AV_CHAN_WIDE_RIGHT
 
-const AV_CH_SURROUND_DIRECT_LEFT = Culonglong(0x0000000200000000)
+const AV_CH_SURROUND_DIRECT_LEFT = Culonglong(1) << AV_CHAN_SURROUND_DIRECT_LEFT
 
-const AV_CH_SURROUND_DIRECT_RIGHT = Culonglong(0x0000000400000000)
+const AV_CH_SURROUND_DIRECT_RIGHT = Culonglong(1) << AV_CHAN_SURROUND_DIRECT_RIGHT
 
-const AV_CH_LOW_FREQUENCY_2 = Culonglong(0x0000000800000000)
+const AV_CH_LOW_FREQUENCY_2 = Culonglong(1) << AV_CHAN_LOW_FREQUENCY_2
 
-const AV_CH_TOP_SIDE_LEFT = Culonglong(0x0000001000000000)
+const AV_CH_TOP_SIDE_LEFT = Culonglong(1) << AV_CHAN_TOP_SIDE_LEFT
 
-const AV_CH_TOP_SIDE_RIGHT = Culonglong(0x0000002000000000)
+const AV_CH_TOP_SIDE_RIGHT = Culonglong(1) << AV_CHAN_TOP_SIDE_RIGHT
 
-const AV_CH_BOTTOM_FRONT_CENTER = Culonglong(0x0000004000000000)
+const AV_CH_BOTTOM_FRONT_CENTER = Culonglong(1) << AV_CHAN_BOTTOM_FRONT_CENTER
 
-const AV_CH_BOTTOM_FRONT_LEFT = Culonglong(0x0000008000000000)
+const AV_CH_BOTTOM_FRONT_LEFT = Culonglong(1) << AV_CHAN_BOTTOM_FRONT_LEFT
 
-const AV_CH_BOTTOM_FRONT_RIGHT = Culonglong(0x0000010000000000)
+const AV_CH_BOTTOM_FRONT_RIGHT = Culonglong(1) << AV_CHAN_BOTTOM_FRONT_RIGHT
 
 const AV_CH_LAYOUT_NATIVE = Culonglong(0x8000000000000000)
 
@@ -21230,6 +22057,8 @@ const AV_CH_LAYOUT_6POINT0_FRONT = (AV_CH_LAYOUT_2_2 | AV_CH_FRONT_LEFT_OF_CENTE
 
 const AV_CH_LAYOUT_HEXAGONAL = AV_CH_LAYOUT_5POINT0_BACK | AV_CH_BACK_CENTER
 
+const AV_CH_LAYOUT_3POINT1POINT2 = (AV_CH_LAYOUT_3POINT1 | AV_CH_TOP_FRONT_LEFT) | AV_CH_TOP_FRONT_RIGHT
+
 const AV_CH_LAYOUT_6POINT1 = AV_CH_LAYOUT_5POINT1 | AV_CH_BACK_CENTER
 
 const AV_CH_LAYOUT_6POINT1_BACK = AV_CH_LAYOUT_5POINT1_BACK | AV_CH_BACK_CENTER
@@ -21246,13 +22075,25 @@ const AV_CH_LAYOUT_7POINT1_WIDE = (AV_CH_LAYOUT_5POINT1 | AV_CH_FRONT_LEFT_OF_CE
 
 const AV_CH_LAYOUT_7POINT1_WIDE_BACK = (AV_CH_LAYOUT_5POINT1_BACK | AV_CH_FRONT_LEFT_OF_CENTER) | AV_CH_FRONT_RIGHT_OF_CENTER
 
+const AV_CH_LAYOUT_5POINT1POINT2_BACK = (AV_CH_LAYOUT_5POINT1_BACK | AV_CH_TOP_FRONT_LEFT) | AV_CH_TOP_FRONT_RIGHT
+
 const AV_CH_LAYOUT_OCTAGONAL = ((AV_CH_LAYOUT_5POINT0 | AV_CH_BACK_LEFT) | AV_CH_BACK_CENTER) | AV_CH_BACK_RIGHT
 
+const AV_CH_LAYOUT_CUBE = (((AV_CH_LAYOUT_QUAD | AV_CH_TOP_FRONT_LEFT) | AV_CH_TOP_FRONT_RIGHT) | AV_CH_TOP_BACK_LEFT) | AV_CH_TOP_BACK_RIGHT
+
+const AV_CH_LAYOUT_5POINT1POINT4_BACK = (AV_CH_LAYOUT_5POINT1POINT2_BACK | AV_CH_TOP_BACK_LEFT) | AV_CH_TOP_BACK_RIGHT
+
+const AV_CH_LAYOUT_7POINT1POINT2 = (AV_CH_LAYOUT_7POINT1 | AV_CH_TOP_FRONT_LEFT) | AV_CH_TOP_FRONT_RIGHT
+
+const AV_CH_LAYOUT_7POINT1POINT4_BACK = (AV_CH_LAYOUT_7POINT1POINT2 | AV_CH_TOP_BACK_LEFT) | AV_CH_TOP_BACK_RIGHT
+
 const AV_CH_LAYOUT_HEXADECAGONAL = (((((((AV_CH_LAYOUT_OCTAGONAL | AV_CH_WIDE_LEFT) | AV_CH_WIDE_RIGHT) | AV_CH_TOP_BACK_LEFT) | AV_CH_TOP_BACK_RIGHT) | AV_CH_TOP_BACK_CENTER) | AV_CH_TOP_FRONT_CENTER) | AV_CH_TOP_FRONT_LEFT) | AV_CH_TOP_FRONT_RIGHT
 
 const AV_CH_LAYOUT_STEREO_DOWNMIX = AV_CH_STEREO_LEFT | AV_CH_STEREO_RIGHT
 
-const AV_CH_LAYOUT_22POINT2 = (((((((((((((((((AV_CH_LAYOUT_5POINT1_BACK | AV_CH_FRONT_LEFT_OF_CENTER) | AV_CH_FRONT_RIGHT_OF_CENTER) | AV_CH_BACK_CENTER) | AV_CH_LOW_FREQUENCY_2) | AV_CH_SIDE_LEFT) | AV_CH_SIDE_RIGHT) | AV_CH_TOP_FRONT_LEFT) | AV_CH_TOP_FRONT_RIGHT) | AV_CH_TOP_FRONT_CENTER) | AV_CH_TOP_CENTER) | AV_CH_TOP_BACK_LEFT) | AV_CH_TOP_BACK_RIGHT) | AV_CH_TOP_SIDE_LEFT) | AV_CH_TOP_SIDE_RIGHT) | AV_CH_TOP_BACK_CENTER) | AV_CH_BOTTOM_FRONT_CENTER) | AV_CH_BOTTOM_FRONT_LEFT) | AV_CH_BOTTOM_FRONT_RIGHT
+const AV_CH_LAYOUT_22POINT2 = (((((((((((AV_CH_LAYOUT_7POINT1POINT4_BACK | AV_CH_FRONT_LEFT_OF_CENTER) | AV_CH_FRONT_RIGHT_OF_CENTER) | AV_CH_BACK_CENTER) | AV_CH_LOW_FREQUENCY_2) | AV_CH_TOP_FRONT_CENTER) | AV_CH_TOP_CENTER) | AV_CH_TOP_SIDE_LEFT) | AV_CH_TOP_SIDE_RIGHT) | AV_CH_TOP_BACK_CENTER) | AV_CH_BOTTOM_FRONT_CENTER) | AV_CH_BOTTOM_FRONT_LEFT) | AV_CH_BOTTOM_FRONT_RIGHT
+
+const AV_CH_LAYOUT_7POINT1_TOP_BACK = AV_CH_LAYOUT_5POINT1POINT2_BACK
 
 const av_ceil_log2 = av_ceil_log2_c
 
@@ -21352,6 +22193,10 @@ const AV_CPU_FLAG_BMI2 = 0x00040000
 
 const AV_CPU_FLAG_AVX512 = 0x00100000
 
+const AV_CPU_FLAG_AVX512ICL = 0x00200000
+
+const AV_CPU_FLAG_SLOW_GATHER = 0x02000000
+
 const AV_CPU_FLAG_ALTIVEC = 0x0001
 
 const AV_CPU_FLAG_VSX = 0x0002
@@ -21374,12 +22219,42 @@ const AV_CPU_FLAG_ARMV8 = 1 << 6
 
 const AV_CPU_FLAG_VFP_VM = 1 << 7
 
+const AV_CPU_FLAG_DOTPROD = 1 << 8
+
+const AV_CPU_FLAG_I8MM = 1 << 9
+
 const AV_CPU_FLAG_SETEND = 1 << 16
 
 const AV_CPU_FLAG_MMI = 1 << 0
 
 const AV_CPU_FLAG_MSA = 1 << 1
 
+const AV_CPU_FLAG_LSX = 1 << 0
+
+const AV_CPU_FLAG_LASX = 1 << 1
+
+const AV_CPU_FLAG_RVI = 1 << 0
+
+const AV_CPU_FLAG_RVF = 1 << 1
+
+const AV_CPU_FLAG_RVD = 1 << 2
+
+const AV_CPU_FLAG_RVV_I32 = 1 << 3
+
+const AV_CPU_FLAG_RVV_F32 = 1 << 4
+
+const AV_CPU_FLAG_RVV_I64 = 1 << 5
+
+const AV_CPU_FLAG_RVV_F64 = 1 << 6
+
+const AV_CPU_FLAG_RVB_BASIC = 1 << 7
+
+const AV_CPU_FLAG_RVB_ADDR = 1 << 8
+
+const AV_DETECTION_BBOX_LABEL_NAME_MAX_SIZE = 64
+
+const AV_NUM_DETECTION_BBOX_CLASSIFY = 4
+
 const AV_DICT_MATCH_CASE = 1
 
 const AV_DICT_IGNORE_SUFFIX = 2
@@ -21394,6 +22269,8 @@ const AV_DICT_APPEND = 32
 
 const AV_DICT_MULTIKEY = 64
 
+const AV_DOVI_MAX_PIECES = 8
+
 const AVERROR_BSF_NOT_FOUND = FFERRTAG(0xf8, Cchar('B'), Cchar('S'), Cchar('F'))
 
 const AVERROR_BUG = FFERRTAG(Cchar('B'), Cchar('U'), Cchar('G'), Cchar('!'))
@@ -21450,14 +22327,22 @@ const AVERROR_HTTP_SERVER_ERROR = FFERRTAG(0xf8, Cchar('5'), Cchar('X'), Cchar('
 
 const AV_ERROR_MAX_STRING_SIZE = 64
 
-const FFMPEG_VERSION = "4.4"
+const FFMPEG_VERSION = "6.1.1"
+
+const AV_FIFO_FLAG_AUTO_GROW = 1 << 0
 
 const AV_NUM_DATA_POINTERS = 8
 
 const AV_FRAME_FLAG_CORRUPT = 1 << 0
 
+const AV_FRAME_FLAG_KEY = 1 << 1
+
 const AV_FRAME_FLAG_DISCARD = 1 << 2
 
+const AV_FRAME_FLAG_INTERLACED = 1 << 3
+
+const AV_FRAME_FLAG_TOP_FIELD_FIRST = 1 << 4
+
 const FF_DECODE_ERROR_INVALID_BITSTREAM = 1
 
 const FF_DECODE_ERROR_MISSING_REFERENCE = 2
@@ -21468,8 +22353,12 @@ const FF_DECODE_ERROR_DECODE_SLICES = 8
 
 const AV_HASH_MAX_SIZE = 64
 
+const AV_HDR_PLUS_MAX_PAYLOAD_SIZE = 907
+
 const AV_CUDA_USE_PRIMARY_CONTEXT = 1 << 0
 
+const AV_CUDA_USE_CURRENT_CONTEXT = 1 << 1
+
 const AV_LOG_QUIET = -8
 
 const AV_LOG_FATAL = 8
@@ -21504,10 +22393,36 @@ const AV_LZO_INPUT_PADDING = 8
 
 const AV_LZO_OUTPUT_PADDING = 12
 
+const M_Ef = Float32(2.718281828459045)
+
+const M_LN2f = Float32(0.6931471805599453)
+
+const M_LN10f = Float32(2.302585092994046)
+
 const M_LOG2_10 = 3.321928094887362
 
+const M_LOG2_10f = Float32(3.321928094887362)
+
 const M_PHI = 1.618033988749895
 
+const M_PHIf = Float32(1.618033988749895)
+
+const M_PIf = Float32(3.141592653589793)
+
+const M_PI_2f = Float32(1.5707963267948966)
+
+const M_PI_4f = Float32(0.7853981633974483)
+
+const M_1_PIf = Float32(0.3183098861837907)
+
+const M_2_PIf = Float32(0.6366197723675814)
+
+const M_2_SQRTPIf = Float32(1.1283791670955126)
+
+const M_SQRT1_2f = Float32(0.7071067811865476)
+
+const M_SQRT2f = Float32(1.4142135623730951)
+
 # Skipping MacroDefinition: av_malloc_attrib __attribute__ ( ( __malloc__ ) )
 
 const AV_OPT_FLAG_ENCODING_PARAM = 1
@@ -21558,8 +22473,6 @@ const AV_PIX_FMT_FLAG_PLANAR = 1 << 4
 
 const AV_PIX_FMT_FLAG_RGB = 1 << 5
 
-const AV_PIX_FMT_FLAG_PSEUDOPAL = 1 << 6
-
 const AV_PIX_FMT_FLAG_ALPHA = 1 << 7
 
 const AV_PIX_FMT_FLAG_BAYER = 1 << 8
@@ -21578,6 +22491,10 @@ const FF_LOSS_COLORQUANT = 0x0010
 
 const FF_LOSS_CHROMA = 0x0020
 
+const FF_LOSS_EXCESS_RESOLUTION = 0x0040
+
+const FF_LOSS_EXCESS_DEPTH = 0x0080
+
 const AVPALETTE_SIZE = 1024
 
 const AVPALETTE_COUNT = 256
@@ -21674,6 +22591,8 @@ const AV_PIX_FMT_GBRAP10 = @AV_PIX_FMT_NE(GBRAP10BE, GBRAP10LE)
 
 const AV_PIX_FMT_GBRAP12 = @AV_PIX_FMT_NE(GBRAP12BE, GBRAP12LE)
 
+const AV_PIX_FMT_GBRAP14 = @AV_PIX_FMT_NE(GBRAP14BE, GBRAP14LE)
+
 const AV_PIX_FMT_GBRAP16 = @AV_PIX_FMT_NE(GBRAP16BE, GBRAP16LE)
 
 const AV_PIX_FMT_BAYER_BGGR16 = @AV_PIX_FMT_NE(BAYER_BGGR16BE, BAYER_BGGR16LE)
@@ -21720,21 +22639,55 @@ const AV_PIX_FMT_AYUV64 = @AV_PIX_FMT_NE(AYUV64BE, AYUV64LE)
 
 const AV_PIX_FMT_P010 = @AV_PIX_FMT_NE(P010BE, P010LE)
 
+const AV_PIX_FMT_P012 = @AV_PIX_FMT_NE(P012BE, P012LE)
+
 const AV_PIX_FMT_P016 = @AV_PIX_FMT_NE(P016BE, P016LE)
 
 const AV_PIX_FMT_Y210 = @AV_PIX_FMT_NE(Y210BE, Y210LE)
 
+const AV_PIX_FMT_Y212 = @AV_PIX_FMT_NE(Y212BE, Y212LE)
+
+const AV_PIX_FMT_XV30 = @AV_PIX_FMT_NE(XV30BE, XV30LE)
+
+const AV_PIX_FMT_XV36 = @AV_PIX_FMT_NE(XV36BE, XV36LE)
+
 const AV_PIX_FMT_X2RGB10 = @AV_PIX_FMT_NE(X2RGB10BE, X2RGB10LE)
 
+const AV_PIX_FMT_X2BGR10 = @AV_PIX_FMT_NE(X2BGR10BE, X2BGR10LE)
+
+const AV_PIX_FMT_P210 = @AV_PIX_FMT_NE(P210BE, P210LE)
+
+const AV_PIX_FMT_P410 = @AV_PIX_FMT_NE(P410BE, P410LE)
+
+const AV_PIX_FMT_P212 = @AV_PIX_FMT_NE(P212BE, P212LE)
+
+const AV_PIX_FMT_P412 = @AV_PIX_FMT_NE(P412BE, P412LE)
+
+const AV_PIX_FMT_P216 = @AV_PIX_FMT_NE(P216BE, P216LE)
+
+const AV_PIX_FMT_P416 = @AV_PIX_FMT_NE(P416BE, P416LE)
+
+const AV_PIX_FMT_RGBAF16 = @AV_PIX_FMT_NE(RGBAF16BE, RGBAF16LE)
+
+const AV_PIX_FMT_RGBF32 = @AV_PIX_FMT_NE(RGBF32BE, RGBF32LE)
+
+const AV_PIX_FMT_RGBAF32 = @AV_PIX_FMT_NE(RGBAF32BE, RGBAF32LE)
+
 const AV_STEREO3D_FLAG_INVERT = 1 << 0
 
 const AV_TIMECODE_STR_SIZE = 23
 
 const AV_TS_MAX_STRING_SIZE = 32
 
-const LIBAVUTIL_VERSION_MAJOR = 56
+const AV_PRI_UUID = "%02hhx%02hhx%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx"
+
+const AV_PRI_URN_UUID = "urn:uuid:%02hhx%02hhx%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx"
+
+const AV_UUID_LEN = 16
 
-const LIBAVUTIL_VERSION_MINOR = 70
+const LIBAVUTIL_VERSION_MAJOR = 58
+
+const LIBAVUTIL_VERSION_MINOR = 29
 
 const LIBAVUTIL_VERSION_MICRO = 100
 
@@ -21744,29 +22697,33 @@ const LIBAVUTIL_VERSION = AV_VERSION(LIBAVUTIL_VERSION_MAJOR, LIBAVUTIL_VERSION_
 
 const LIBAVUTIL_BUILD = LIBAVUTIL_VERSION_INT
 
-const FF_API_VAAPI = LIBAVUTIL_VERSION_MAJOR < 57
+const FF_API_FIFO_PEEK2 = LIBAVUTIL_VERSION_MAJOR < 59
+
+const FF_API_FIFO_OLD_API = LIBAVUTIL_VERSION_MAJOR < 59
 
-const FF_API_FRAME_QP = LIBAVUTIL_VERSION_MAJOR < 57
+const FF_API_XVMC = LIBAVUTIL_VERSION_MAJOR < 59
 
-const FF_API_PLUS1_MINUS1 = LIBAVUTIL_VERSION_MAJOR < 57
+const FF_API_OLD_CHANNEL_LAYOUT = LIBAVUTIL_VERSION_MAJOR < 59
 
-const FF_API_ERROR_FRAME = LIBAVUTIL_VERSION_MAJOR < 57
+const FF_API_AV_FOPEN_UTF8 = LIBAVUTIL_VERSION_MAJOR < 59
 
-const FF_API_PKT_PTS = LIBAVUTIL_VERSION_MAJOR < 57
+const FF_API_PKT_DURATION = LIBAVUTIL_VERSION_MAJOR < 59
 
-const FF_API_CRYPTO_SIZE_T = LIBAVUTIL_VERSION_MAJOR < 57
+const FF_API_REORDERED_OPAQUE = LIBAVUTIL_VERSION_MAJOR < 59
 
-const FF_API_FRAME_GET_SET = LIBAVUTIL_VERSION_MAJOR < 57
+const FF_API_FRAME_PICTURE_NUMBER = LIBAVUTIL_VERSION_MAJOR < 59
 
-const FF_API_PSEUDOPAL = LIBAVUTIL_VERSION_MAJOR < 57
+const FF_API_HDR_VIVID_THREE_SPLINE = LIBAVUTIL_VERSION_MAJOR < 59
 
-const FF_API_CHILD_CLASS_NEXT = LIBAVUTIL_VERSION_MAJOR < 57
+const FF_API_FRAME_PKT = LIBAVUTIL_VERSION_MAJOR < 59
 
-const FF_API_BUFFER_SIZE_T = LIBAVUTIL_VERSION_MAJOR < 57
+const FF_API_INTERLACED_FRAME = LIBAVUTIL_VERSION_MAJOR < 59
 
-const FF_API_D2STR = LIBAVUTIL_VERSION_MAJOR < 58
+const FF_API_FRAME_KEY = LIBAVUTIL_VERSION_MAJOR < 59
 
-const FF_API_DECLARE_ALIGNED = LIBAVUTIL_VERSION_MAJOR < 58
+const FF_API_PALETTE_HAS_CHANGED = LIBAVUTIL_VERSION_MAJOR < 59
+
+const FF_API_VULKAN_CONTIGUOUS_MEMORY = LIBAVUTIL_VERSION_MAJOR < 59
 
 const SWS_FAST_BILINEAR = 1
 
@@ -21828,33 +22785,28 @@ const SWS_CS_DEFAULT = 5
 
 const SWS_CS_BT2020 = 9
 
-const LIBSWSCALE_VERSION_MAJOR = 5
-
-const LIBSWSCALE_VERSION_MINOR = 9
+const LIBSWSCALE_VERSION_MINOR = 5
 
 const LIBSWSCALE_VERSION_MICRO = 100
 
+const LIBSWSCALE_VERSION_MAJOR = 7
+
 const LIBSWSCALE_VERSION_INT = AV_VERSION_INT(LIBSWSCALE_VERSION_MAJOR, LIBSWSCALE_VERSION_MINOR, LIBSWSCALE_VERSION_MICRO)
 
 const LIBSWSCALE_VERSION = AV_VERSION(LIBSWSCALE_VERSION_MAJOR, LIBSWSCALE_VERSION_MINOR, LIBSWSCALE_VERSION_MICRO)
 
 const LIBSWSCALE_BUILD = LIBSWSCALE_VERSION_INT
 
-const FF_API_SWS_VECTOR = LIBSWSCALE_VERSION_MAJOR < 6
-
 struct_types = Type[]
 # Export everything
-for name in names(@__MODULE__; all=true)
-    if name in (:include, :eval) || startswith(string(name), "#")
-        continue
-    end
+for name in names(@__MODULE__, all = true)
+    name in [Symbol("#eval"), Symbol("#include"), :include, :eval] && continue
     @eval begin
         export $name
         $name isa Type && isstructtype($name) && push!(struct_types, $name)
     end
 end
 
-
 function Base.getproperty(x::Ptr{<:Union{struct_types...}}, f::Symbol)
     T = eltype(x)
     fieldpos = Base.fieldindex(T, f)
diff --git a/src/VideoIO.jl b/src/VideoIO.jl
index 4c898c1..4fefcce 100644
--- a/src/VideoIO.jl
+++ b/src/VideoIO.jl
@@ -105,7 +105,6 @@ function __init__()
     loglevel!(libffmpeg.AV_LOG_FATAL)
     # @info "VideoIO: Low-level FFMPEG reporting set to minimal (AV_LOG_FATAL). See `? VideoIO.loglevel!` for options"
     read_packet[] = @cfunction(_read_packet, Cint, (Ptr{AVInput}, Ptr{UInt8}, Cint))
-    av_register_all()
     libffmpeg.avdevice_register_all()
 end
 
diff --git a/src/avio.jl b/src/avio.jl
index 9287cad..a2cfa8c 100644
--- a/src/avio.jl
+++ b/src/avio.jl
@@ -832,10 +832,10 @@ get_frame_presentation_time(stream, frame) = convert(Rational, stream.time_base)
 function get_frame_period_timebase(r::VideoReader)
     # This is probably not valid for many codecs, frame period in timebase
     # units
-    stream = get_stream(s)
+    stream = get_stream(r)
     time_base = convert(Rational, stream.time_base)
     time_base == 0 && return nothing
-    frame_rate = convert(Rational, av_stream_get_r_frame_rate(stream))
+    frame_rate = convert(Rational, stream.r_frame_rate)
     frame_period_timebase = round(Int64, 1 / (frame_rate * time_base))
     return frame_period_timebase
 end
@@ -858,7 +858,7 @@ function seek_trim(r::VideoReader, seconds::Number)
     time_base = convert(Rational, stream.time_base)
     time_base == 0 && error("No time base")
     target_pts = seconds_to_timestamp(seconds, time_base)
-    frame_rate = convert(Rational, av_stream_get_r_frame_rate(stream))
+    frame_rate = convert(Rational, stream.r_frame_rate)
     frame_period_timebase = round(Int64, 1 / (frame_rate * time_base))
     gotframe = pump_until_frame(r, false)
     # If advancing another frame would still leave us before the target
@@ -1005,7 +1005,7 @@ function position(r::VideoReader)
     time_base == 0 && return nothing
     nqueued = n_queued_frames(r)
     nqueued == 0 && return last_pts * time_base
-    frame_rate = convert(Rational, av_stream_get_r_frame_rate(stream))
+    frame_rate = convert(Rational, stream.r_frame_rate)
     last_returned_pts = last_pts - round(Int, nqueued / (frame_rate * time_base))
     return last_returned_pts * time_base
 end
-- 
2.44.0

